<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
#region (c)2010-2042 Hawkynt
/*
  This file is part of Hawkynt's .NET Framework extensions.

    Hawkynt's .NET Framework extensions are free software:
    you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Hawkynt's .NET Framework extensions is distributed in the hope that
    it will be useful, but WITHOUT ANY WARRANTY; without even the implied
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
    the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Hawkynt's .NET Framework extensions.
    If not, see <http://www.gnu.org/licenses/>.
*/
#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */
<#
  const int LINEAR_BLOCK_COUNTX86 = 16;              // x86 can only copy 16-byte blocks without emitting loop constructs (rep movsb)
  const int LINEAR_BLOCK_COUNTX64 = 64;              // x64 uses vmovdqu for blocks up to 64-bytes
  const int MARSHALL_SWITCH_COUNT = 8;               // how many bytes we'll quickly process using a switch statement (must >= 7)
  const int MARSHALL_LOOP_UNROLL  = 0;               // doesn't give speedup when using Marshal.* because the calls are damn slow anyway
  const int INDEX_LOOP_UNROLL     = 8;               // ldc.i4 8 is the highest opcode available for index operations
  const int BYTE_COUNT_POINTER    = 1 * 1024 * 1024; // we'll use pointer pinning and block-copies when this many bytes need to be copied
  const int ELEMENT_COUNT_BLOCK   = 256;             // we'll use Array.Copy or Buffer.BlockCopy when more than this many elements are present
  
  var typeDatas = new List<TypeData>();
  typeDatas.Add(new TypeData{ name = "sbyte"  , size = 1, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "byte"   , size = 1, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "short"  , size = 2, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "ushort" , size = 2, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "int"    , size = 4, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "uint"   , size = 4, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "long"   , size = 8, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "ulong"  , size = 8, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "float"  , size = 4, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "double" , size = 8, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "char"   , size = 2, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "string"});
  typeDatas.Add(new TypeData{ name = "decimal", size = 16});
  typeDatas.Add(new TypeData{ name = "bool"   , size = 1});
  typeDatas.Add(new TypeData{ name = "IntPtr" , hasHandcraftedCopyToMethod = true, noArraySupport = true});
  typeDatas.Add(new TypeData{ name = "byte*"  , hasHandcraftedCopyToMethod = true, noArraySupport = true, isUnsafeOnly = true});
  
#>

using System.Runtime.InteropServices;
#if NET45
using System.Runtime.CompilerServices;
#endif

using Block1 = System.Byte;
using Block2 = System.UInt16;
using Block4 = System.UInt32;
using Block8 = System.UInt64;

// ReSharper disable UnusedMemberInSuper.Global
// ReSharper disable UnusedAutoPropertyAccessor.Global
// ReSharper disable PartialTypeWithSinglePart
// ReSharper disable UnusedMember.Global
// ReSharper disable MemberCanBePrivate.Global
namespace System {
  internal static partial class ArrayExtensions {
    
    #region nested types

#if PLATFORM_X86
<#  for(var i = 3;i <= LINEAR_BLOCK_COUNTX86; ++i) {#>
<#    if(i == 1 || i == 2 || i == 4 || i == 8 || i == 32 || i == 64) continue;#>
    [StructLayout(LayoutKind.Sequential, Size=<#=i#>)] private struct Block<#=i#>{ }
<#  }#>
#else
<#  for(var i = 3;i <= LINEAR_BLOCK_COUNTX64; ++i) {#>
<#    if(i == 1 || i == 2 || i == 4 || i == 8 || i == 32 || i == 64) continue;#>
    [StructLayout(LayoutKind.Sequential, Size=<#=i#>)] private struct Block<#=i#>{ }
<#  }#>
#endif

    #endregion

    // TODO: Clear for byte[], IntPtr, byte*, ushort[], short[], uint[], int[], ulong[], long[], float[], double[]
    // TODO: Fill for byte[], IntPtr, byte*, ushort[], short[], uint[], int[], ulong[], long[], float[], double[]
    // TODO: SequenceEquals for byte[], IntPtr, byte*, ushort[], short[], uint[], int[], ulong[], long[], float[], double[]

    #region Copy
<#  foreach(var typeData in typeDatas) {#>
<#    var typeName = typeData.name;#>
    #region Type: <#=typeName#>
<#    if(typeData.isUnsafeOnly) {#>
#if UNSAFE
<#    }#>
<#    if(!typeData.noArraySupport) {#>
    
    public static <#=(typeData.isUnsafeOnly ? "unsafe " : string.Empty)#><#=EmitTypeDef(typeData)#> Copy(<#=(typeData.isUnsafeOnly ? string.Empty : "this ")#><#=EmitTypeDef(typeData)#> @this) {
      if (@this == null)
        return null;

      var length = @this.Length;
      var result = new <#=typeName#>[length];
      _CopyTo(@this, 0, result, 0, length);
      return result;
    }

    public static <#=(typeData.isUnsafeOnly ? "unsafe " : string.Empty)#><#=EmitTypeDef(typeData)#> Copy(<#=(typeData.isUnsafeOnly ? string.Empty : "this ")#><#=EmitTypeDef(typeData)#> @this, int index) {
      if (@this == null)
        return null;

      <#=EmitOffsetTooSmallCheck()#>
      var length = @this.Length;
      <#=EmitOffsetTooLargeCheck()#>
      var count = length - index;
      var result = new <#=typeName#>[count];
      _CopyTo(@this, index, result, 0, count);
      return result;
    }

    public static <#=(typeData.isUnsafeOnly ? "unsafe " : string.Empty)#><#=EmitTypeDef(typeData)#> Copy(<#=(typeData.isUnsafeOnly ? string.Empty : "this ")#><#=EmitTypeDef(typeData)#> @this, int index, int count) {
      if (@this == null)
        return null;

      <#=EmitOffsetTooSmallCheck()#>
      var length = @this.Length;
      <#=EmitOffsetTooLargeCheck()#>
      <#=EmitCountTooSmallCheck()#>
      <#=EmitCountTooLargeCheck("length - index")#>

      var result = new <#=typeName#>[count];
      _CopyTo(@this, index, result, 0, count);
      return result;
    }
<#    }#>

<#    if(!typeData.NeedsCount) {#>
    public static <#=(typeData.isUnsafeOnly ? "unsafe " : string.Empty)#>void CopyTo(<#=(typeData.isUnsafeOnly ? string.Empty : "this ")#><#=EmitTypeDef(typeData)#> @this, <#=EmitTypeDef(typeData)#> target) {
<#      if(!typeData.IsValueType)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#      }#>
      var count = @this.Length;
      <#=EmitCountTooLargeCheck("count", "target.Length", "target")#>
      _CopyTo(@this, 0 , target, 0, count);
    }

    public static <#=(typeData.isUnsafeOnly ? "unsafe " : string.Empty)#>void CopyTo(<#=(typeData.isUnsafeOnly ? string.Empty : "this ")#><#=EmitTypeDef(typeData)#> @this, int srcIndex, <#=EmitTypeDef(typeData)#> target) {
<#      if(!typeData.IsValueType)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#      }#>
      <#=EmitOffsetTooSmallCheck("srcIndex")#>
      var length = @this.Length;
      <#=EmitOffsetTooLargeCheck("srcIndex", "length")#>
      var count = length - srcIndex;
      <#=EmitCountTooLargeCheck("count", "target.Length", "target")#>
      _CopyTo(@this, srcIndex , target, 0, count);
    }

    public static <#=(typeData.isUnsafeOnly ? "unsafe " : string.Empty)#>void CopyTo(<#=(typeData.isUnsafeOnly ? string.Empty : "this ")#><#=EmitTypeDef(typeData)#> @this, <#=EmitTypeDef(typeData)#> target, int tgtIndex) {
<#      if(!typeData.IsValueType)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#      }#>
      <#=EmitOffsetTooSmallCheck("tgtIndex")#>
      var length = target.Length;
      <#=EmitOffsetTooLargeCheck("tgtIndex", "length")#>
      var count = @this.Length;
      <#=EmitCountTooLargeCheck("count", "target.Length - tgtIndex", "@this")#>
      _CopyTo(@this, 0 , target, tgtIndex, count);
    }
<#    } else {#>
    public static <#=(typeData.isUnsafeOnly ? "unsafe " : string.Empty)#>void CopyTo(<#=(typeData.isUnsafeOnly ? string.Empty : "this ")#><#=EmitTypeDef(typeData)#> @this, int count, <#=EmitTypeDef(typeData)#> target) {
<#      if(!typeData.IsValueType)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#      }#>
      <#=EmitCountTooSmallCheck()#>
      _CopyTo(@this, 0 , target, 0, count);
    }

    public static <#=(typeData.isUnsafeOnly ? "unsafe " : string.Empty)#>void CopyTo(<#=(typeData.isUnsafeOnly ? string.Empty : "this ")#><#=EmitTypeDef(typeData)#> @this, int count, int srcIndex, <#=EmitTypeDef(typeData)#> target) {
<#      if(!typeData.IsValueType)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#      }#>
      <#=EmitOffsetTooSmallCheck("srcIndex")#>
      <#=EmitCountTooSmallCheck()#>
      _CopyTo(@this, srcIndex , target, 0, count);
    }

    public static <#=(typeData.isUnsafeOnly ? "unsafe " : string.Empty)#>void CopyTo(<#=(typeData.isUnsafeOnly ? string.Empty : "this ")#><#=EmitTypeDef(typeData)#> @this, int count, <#=EmitTypeDef(typeData)#> target, int tgtIndex) {
<#      if(!typeData.IsValueType)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#      }#>
      <#=EmitOffsetTooSmallCheck("tgtIndex")#>
      <#=EmitCountTooSmallCheck()#>
      _CopyTo(@this, 0 , target, tgtIndex, count);
    }
<#    }#>

    public static <#=(typeData.isUnsafeOnly ? "unsafe " : string.Empty)#>void CopyTo(<#=(typeData.isUnsafeOnly ? string.Empty : "this ")#><#=EmitTypeDef(typeData)#> @this, int srcIndex, <#=EmitTypeDef(typeData)#> target, int tgtIndex, int count) {
<#    if(!typeData.IsValueType)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#    }#>
      <#=EmitOffsetTooSmallCheck("srcIndex")#>
      <#=EmitOffsetTooSmallCheck("tgtIndex")#>
      <#=EmitCountTooSmallCheck()#>
<#    if(typeData.SupportsLength) {#>
      <#=EmitOffsetTooLargeCheck("srcIndex", "@this.Length")#>
      <#=EmitOffsetTooLargeCheck("tgtIndex", "target.Length")#>
      <#=EmitCountTooLargeCheck("count", "@this.Length - srcIndex")#>
      <#=EmitCountTooLargeCheck("count", "target.Length - tgtIndex")#>
<#    }#>
      _CopyTo(@this, srcIndex , target, tgtIndex, count);
    }
<#    if(typeData.allowByteConversion){#>
<#      foreach(var tgtTypeData in typeDatas.Where(i=>i.name != typeName && i.allowByteConversion)){#>

    public static <#=(typeData.isUnsafeOnly ? "unsafe " : string.Empty)#>void CopyTo(<#=(typeData.isUnsafeOnly ? string.Empty : "this ")#><#=EmitTypeDef(typeData)#> @this, int srcIndex, <#=EmitTypeDef(tgtTypeData)#> target, int tgtIndex, int count) {
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
      <#=EmitOffsetTooSmallCheck("srcIndex")#>
      <#=EmitOffsetTooSmallCheck("tgtIndex")#>
      <#=EmitOffsetTooLargeCheck("srcIndex", "@this.Length")#>
      <#=EmitOffsetTooLargeCheck("tgtIndex", "target.Length")#>
      <#=EmitCountTooLargeCheck("count", "@this.Length - srcIndex")#>
<#        if(tgtTypeData.size != typeData.size) {#>
      var bytesNeeded = count<#=EmitFastIntegerMultiply(typeData.size)#>;
      var bytesAvailable = (target.Length - tgtIndex)<#=EmitFastIntegerMultiply(tgtTypeData.size)#>;
      <#=EmitCountTooLargeCheck("bytesNeeded", "bytesAvailable", "count")#>
      if ((bytesNeeded<#=EmitFastIntegerModulo(tgtTypeData.size)#>) != 0) throw new ArgumentException("Need more items to fully cover target items", nameof(count));
<#        } else {#>
      <#=EmitCountTooLargeCheck("count", "target.Length - tgtIndex", "count")#>
<#        }#>
      _CopyTo(@this, srcIndex, target, tgtIndex, count);
    }
<#      }#>
<#    }#>
<#    if(typeData.isUnsafeOnly) {#>

#endif
<#    }#>
    #endregion
<#  }#>
<#  foreach(var typeData in typeDatas.Where(i=>!i.hasHandcraftedCopyToMethod)) {#>
<#    var typeName = typeData.name;#>
    
#if NET45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static void _CopyTo(<#=EmitTypeDef(typeData)#> source, int srcIndex,<#=EmitTypeDef(typeData)#> target, int tgtIndex, int count){
label:
      switch(count){
<#    for(var i = 0; i < INDEX_LOOP_UNROLL; ++i) {#>
<#      if(i == 0) {#>
        case 0: return;
<#      } else {#>
        case <#=i#>:
<#        for(var j = 0; j < i; ++j) {#>
          <#=EmitIndexCopy(j)#>
<#        }#>
          return;
<#      }#>
<#    }#>
      }

<#    if(BYTE_COUNT_POINTER > 0 && typeData.size > 0 && typeData.useBlockCopyInsteadOfArrayCopy) {#>
      if( count > <#=(BYTE_COUNT_POINTER / typeData.size)#>) {
#if UNSAFE
        unsafe {
          fixed(<#=typeData.name#>* sourceFixedPointer = &source[srcIndex])
          fixed(<#=typeData.name#>* targetFixedPointer = &target[tgtIndex])
            _CopyTo(<#=(typeData.name == "byte" ? string.Empty : "(byte*)")#>sourceFixedPointer, <#=(typeData.name == "byte" ? string.Empty : "(byte*)")#>targetFixedPointer, count<#=EmitFastIntegerMultiply(typeData.size)#>);
        }
#else
        using (var sourceFixedPointer = DisposableGCHandle.Pin(source))
        using (var targetFixedPointer = DisposableGCHandle.Pin(target))
          _CopyTo(sourceFixedPointer.AddrOfPinnedObject(), srcIndex<#=EmitFastIntegerMultiply(typeData.size)#>, targetFixedPointer.AddrOfPinnedObject(), tgtIndex<#=EmitFastIntegerMultiply(typeData.size)#>, count<#=EmitFastIntegerMultiply(typeData.size)#>);
#endif

        return;
      }

<#    }#>
<#    if(ELEMENT_COUNT_BLOCK > 0) {#>
      if(count > <#=ELEMENT_COUNT_BLOCK#>) {
        <#=(typeData.useBlockCopyInsteadOfArrayCopy ? "Buffer.BlockCopy" : "Array.Copy")#>(source, srcIndex<#=(typeData.useBlockCopyInsteadOfArrayCopy ? EmitFastIntegerMultiply(typeData.size) : string.Empty)#>, target, tgtIndex<#=(typeData.useBlockCopyInsteadOfArrayCopy ? EmitFastIntegerMultiply(typeData.size) : string.Empty)#>, count<#=(typeData.useBlockCopyInsteadOfArrayCopy ? EmitFastIntegerMultiply(typeData.size) : string.Empty)#>);
        return;
      }

<#    }#>
      while(count >= <#=INDEX_LOOP_UNROLL#>) {
<#    for(var i = 0; i < INDEX_LOOP_UNROLL; ++i) {#>
        <#=EmitIndexCopy(i)#>
<#    }#>
          
        srcIndex += <#=INDEX_LOOP_UNROLL#>;
        tgtIndex += <#=INDEX_LOOP_UNROLL#>;
        count -= <#=INDEX_LOOP_UNROLL#>;
      }

      goto label;
    }
<#    if(typeData.allowByteConversion){#>
<#      foreach(var tgtTypeData in typeDatas.Where(i=>i.name != typeName && i.allowByteConversion)){#>

#if NET45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static void _CopyTo(<#=EmitTypeDef(typeData)#> source, int srcIndex, <#=EmitTypeDef(tgtTypeData)#> target, int tgtIndex, int count)
      => Buffer.BlockCopy(source, srcIndex<#=EmitFastIntegerMultiply(typeData.size)#>, target, tgtIndex<#=EmitFastIntegerMultiply(tgtTypeData.size)#>, count<#=EmitFastIntegerMultiply(typeData.size)#>)
    ;
<#      }#>
<#    }#>
<#  }#>

#if UNSAFE

#if NET45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static unsafe void _CopyTo(byte* source, int srcIndex, byte* target, int tgtIndex, int count)
      => _CopyTo(source + srcIndex, target + tgtIndex, count)
    ;

#if NET45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static unsafe void _CopyTo(byte* source, byte* target, int count) {
byteLoop:

#if PLATFORM_X86

      switch(count) {
<#  for(var i = 0; i <= LINEAR_BLOCK_COUNTX86; ++i) {#>
<#    if(i == 0) {#>
        case 0: 
          return;
<#    } else {#>
        case <#=i#>: 
          <#=EmitCopyBlock(i, 0)#>
          return;
<#    }#>
<#  }#>
      }
      
      <#=EmitCopyBlock(LINEAR_BLOCK_COUNTX86, 0)#>
      count -= <#=LINEAR_BLOCK_COUNTX86#>;
      source += <#=LINEAR_BLOCK_COUNTX86#>;
      target += <#=LINEAR_BLOCK_COUNTX86#>;
      
      var blockCount = count<#=EmitFastIntegerDivide(LINEAR_BLOCK_COUNTX86)#>;
      count = count<#=EmitFastIntegerModulo(LINEAR_BLOCK_COUNTX86)#>;

blockLoop:

      switch (blockCount) {
<#  for(var i = 0; i <= INDEX_LOOP_UNROLL; ++i) {#>
<#    if(i == 0) {#>
        case 0: goto byteLoop;
<#    } else {#>
        case <#=i#>: goto blockDuff<#=(INDEX_LOOP_UNROLL - i)#>;
<#    }#>
<#  }#>
        default: goto blockDuffOut;
      }

<#  for(var i = 0; i < INDEX_LOOP_UNROLL; ++i) {#>
blockDuff<#=i#>: <#=EmitCopyBlock(LINEAR_BLOCK_COUNTX86, INDEX_LOOP_UNROLL - i - 1)#>
<#  }#>

      var processed = blockCount<#=EmitFastIntegerMultiply(LINEAR_BLOCK_COUNTX86)#>;
      source += processed;
      target += processed;
      goto byteLoop;

blockDuffOut:

      do {
<#  for(var j = 0; j < INDEX_LOOP_UNROLL; ++j){#>
        <#=EmitCopyBlock(LINEAR_BLOCK_COUNTX86, j)#>
<#  }#>
        source += <#=(INDEX_LOOP_UNROLL * LINEAR_BLOCK_COUNTX86)#>;
        target += <#=(INDEX_LOOP_UNROLL * LINEAR_BLOCK_COUNTX86)#>;
        blockCount -= <#=INDEX_LOOP_UNROLL#>;
      } while (blockCount >= <#=INDEX_LOOP_UNROLL#>);
      goto blockLoop;

#else

      switch(count) {
<#  for(var i = 0; i <= LINEAR_BLOCK_COUNTX64; ++i) {#>
<#    if(i == 0) {#>
        case 0: 
          return;
<#    } else {#>
        case <#=i#>: 
          <#=EmitCopyBlock(i, 0)#>
          return;
<#    }#>
<#  }#>
      }
      
      <#=EmitCopyBlock(LINEAR_BLOCK_COUNTX64, 0)#>
      count -= <#=LINEAR_BLOCK_COUNTX64#>;
      source += <#=LINEAR_BLOCK_COUNTX64#>;
      target += <#=LINEAR_BLOCK_COUNTX64#>;
      
      var blockCount = count<#=EmitFastIntegerDivide(LINEAR_BLOCK_COUNTX64)#>;
      count = count<#=EmitFastIntegerModulo(LINEAR_BLOCK_COUNTX64)#>;

blockLoop:

      switch (blockCount) {
<#  for(var i = 0; i <= INDEX_LOOP_UNROLL; ++i) {#>
<#    if(i == 0) {#>
        case 0: goto byteLoop;
<#    } else {#>
        case <#=i#>: goto blockDuff<#=(INDEX_LOOP_UNROLL - i)#>;
<#    }#>
<#  }#>
        default: goto blockDuffOut;
      }

<#  for(var i = 0; i < INDEX_LOOP_UNROLL; ++i) {#>
blockDuff<#=i#>: <#=EmitCopyBlock(LINEAR_BLOCK_COUNTX64, INDEX_LOOP_UNROLL - i - 1)#>
<#  }#>

      var processed = blockCount<#=EmitFastIntegerMultiply(LINEAR_BLOCK_COUNTX64)#>;
      source += processed;
      target += processed;
      goto byteLoop;

blockDuffOut:

      do {
<#  for(var j = 0; j < INDEX_LOOP_UNROLL; ++j){#>
        <#=EmitCopyBlock(LINEAR_BLOCK_COUNTX64, j)#>
<#  }#>
        source += <#=(INDEX_LOOP_UNROLL * LINEAR_BLOCK_COUNTX64)#>;
        target += <#=(INDEX_LOOP_UNROLL * LINEAR_BLOCK_COUNTX64)#>;
        blockCount -= <#=INDEX_LOOP_UNROLL#>;
      } while (blockCount >= <#=INDEX_LOOP_UNROLL#>);
      goto blockLoop;

#endif

    }
#endif

#if NET45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static void _CopyTo(IntPtr source, int srcIndex, IntPtr target, int tgtIndex, int count) {
#if UNSAFE
      unsafe { _CopyTo(&((byte*)source)[srcIndex], &((byte*)target)[tgtIndex], count); }
#else
byteLoop:
      switch(count) {
<#  for(var i = 0; i <= MARSHALL_SWITCH_COUNT; ++i) {#>
<#    if(i == 0) {#>
        case 0: return;
<#    } else {#>
        case <#=i#>:
          <#=string.Join("\r\n          ",EmitMarshalCopyBytes(i))#>
          return;
<#    }#>
<#  }#>
      }

<#  if(MARSHALL_LOOP_UNROLL>1){#>

      <#=string.Join("\r\n      ",EmitMarshalCopyBytes(MARSHALL_SWITCH_COUNT))#>
      count -= <#=MARSHALL_SWITCH_COUNT#>;
      srcIndex += <#=MARSHALL_SWITCH_COUNT#>;
      tgtIndex += <#=MARSHALL_SWITCH_COUNT#>;
    
      var qwordCount = count<#=EmitFastIntegerDivide(8)#>;
      count = count<#=EmitFastIntegerModulo(8)#>;

qwordLoop:

      switch (qwordCount) {
<#    for(var i = 0; i <= MARSHALL_LOOP_UNROLL; ++i) {#>
<#      if(i == 0) {#>
        case 0: goto byteLoop;
<#      } else {#>
        case <#=i#>: goto qwordDuff<#=(MARSHALL_LOOP_UNROLL - i)#>;
<#      }#>
<#    }#>
        default: goto qwordDuffOut;
      }

<#    for(var i = 0; i < MARSHALL_LOOP_UNROLL; ++i) {#>
qwordDuff<#=i#>: <#=EmitMarshalCopyQWord((MARSHALL_LOOP_UNROLL - i - 1) * 8)#>;
<#    }#>

      var processed = qwordCount<#=EmitFastIntegerMultiply(8)#>;
      srcIndex += processed;
      tgtIndex += processed;
      goto byteLoop;

qwordDuffOut:

      do {
        <#=string.Join("\r\n        ",EmitMarshalCopyBytes(MARSHALL_LOOP_UNROLL * 8))#>
        srcIndex += <#=(MARSHALL_LOOP_UNROLL * 8)#>;
        tgtIndex += <#=(MARSHALL_LOOP_UNROLL * 8)#>;
        qwordCount -= <#=MARSHALL_LOOP_UNROLL#>;
      } while (qwordCount >= <#=MARSHALL_LOOP_UNROLL#>);

      goto qwordLoop;
<#  } else {#>
      var qwordCount = count<#=EmitFastIntegerDivide(8)#>;
      count = count<#=EmitFastIntegerModulo(8)#>;
      do {
        <#=string.Join("\r\n        ",EmitMarshalCopyBytes(8))#>
        srcIndex += 8;
        tgtIndex += 8;
        --qwordCount;
      } while (qwordCount > 0);
      goto byteLoop;
<#  }#>

#endif
    }

    #endregion


  }
}

<#+

public struct TypeData {
  public string name;
  public int size;
  public bool useBlockCopyInsteadOfArrayCopy;
  public bool allowByteConversion;
  public bool noArraySupport;
  public bool hasHandcraftedCopyToMethod;
  public bool isUnsafeOnly;
  public bool NeedsCount {get{return this.noArraySupport; }}
  public bool SupportsLength {get{return !this.noArraySupport; }}
  public bool IsValueType {get{return this.noArraySupport; }}
}

double Log2(int i) => Math.Log(i) / Math.Log(2);

string EmitFastIntegerMultiply(int i) {
  var exponent = Log2(i);
  if(exponent == (int)exponent)
    return exponent == 0 ? string.Empty : " << " + exponent;
  else
    return " * " + i;
}

string EmitFastIntegerDivide(int i) {
  var exponent = Log2(i);
  if(exponent == (int)exponent)
    return exponent == 0 ? string.Empty : " >> " + exponent;
  else
    return " / " + i;
}
  
string EmitFastIntegerModulo(int i) {
  var exponent = Log2(i);
  if(exponent == (int)exponent)
    return exponent == 0 ? string.Empty : " & " + (exponent == 1 ? "1" : "0b" + new string('1', (int)exponent));
  else
    return " % " + i;
}

string EmitTypeDef(TypeData type) => type.noArraySupport ? type.name : type.name + "[]"; 

string EmitIndexCopy(int i) => string.Format(@"target[tgtIndex{0}] = source[srcIndex{0}];", i == 0 ? string.Empty : " + " + i);

string EmitCopyByte(int i)  => i == 0 ? "*target = *source;"                 : string.Format("target[{0}] = source[{0}];", i);
string EmitCopyWord(int i)  => i == 0 ? "*(short*)target = *(short*)source;" : string.Format("((short*)target)[{0}] = ((short*)source)[{0}];", i);
string EmitCopyDWord(int i) => i == 0 ? "*(int*)target = *(int*)source;"     : string.Format("((int*)target)[{0}] = ((int*)source)[{0}];", i);
string EmitCopyQWord(int i) => i == 0 ? "*(long*)target = *(long*)source;"   : string.Format("((long*)target)[{0}] = ((long*)source)[{0}];", i);

string EmitMarshalCopyByte(int i)  => string.Format("Marshal.WriteByte(target, tgtIndex{0}, Marshal.ReadByte(source, srcIndex{0}));", i == 0 ? string.Empty : " + " + i);
string EmitMarshalCopyWord(int i)  => string.Format("Marshal.WriteInt16(target, tgtIndex{0}, Marshal.ReadInt16(source, srcIndex{0}));", i == 0 ? string.Empty : " + " + i);
string EmitMarshalCopyDWord(int i) => string.Format("Marshal.WriteInt32(target, tgtIndex{0}, Marshal.ReadInt32(source, srcIndex{0}));", i == 0 ? string.Empty : " + " + i);
string EmitMarshalCopyQWord(int i) => string.Format("Marshal.WriteInt64(target, tgtIndex{0}, Marshal.ReadInt64(source, srcIndex{0}));", i == 0 ? string.Empty : " + " + i);

IEnumerable<string> EmitCopyBytes(int count) {
  var results = new List<string>();
  var offset = 0;
  while(count >= 8) {
    results.Add(EmitCopyQWord(offset >> 3));
    count -= 8;
    offset += 8;
  }
  if (count >= 4) {
    results.Add(EmitCopyDWord(offset >> 2));
    count -= 4;
    offset += 4;
  }
  if (count >= 2) {
    results.Add(EmitCopyWord(offset >> 1));
    count -= 2;
    offset += 2;
  }
  if (count >= 1) 
    results.Add(EmitCopyByte(offset));

  return results;
}

IEnumerable<string> EmitMarshalCopyBytes(int count) {
  var results = new List<string>();
  var offset = 0;
  if((count & 1) != 0) {
    results.Add(EmitMarshalCopyByte(offset));
    ++offset;
  }
  if((count & 2) != 0) {
    results.Add(EmitMarshalCopyWord(offset));
    offset += 2;
  }
  if((count & 4) != 0) {
    results.Add(EmitMarshalCopyDWord(offset));
    offset += 4;
  }
  count>>= 3;
  while(count > 0) {
    results.Add(EmitMarshalCopyQWord(offset));
    offset += 8;
    --count;
  }

  return results;
}

string EmitCopyBlock(int sizeInBytes, int index) {
  if (sizeInBytes == 1)
    return index == 0 ? "*target = *source;" : string.Format("target[{1}] = source[{1}];", sizeInBytes, index);
  else
    return index == 0 ? string.Format("*(Block{0}*)target = *(Block{0}*)source;", sizeInBytes) : string.Format("((Block{0}*)target)[{1}] = ((Block{0}*)source)[{1}];", sizeInBytes, index);
}


string EmitThisNullCheck() => @"if (@this == null) throw new NullReferenceException();";
string EmitArgNullCheck(string paramName) => string.Format(@"if ({0} == null) throw new ArgumentNullException(nameof({0}));", paramName);

string EmitOffsetTooSmallCheck(string paramName) => string.Format(@"if ({0} < 0) throw new ArgumentOutOfRangeException(nameof({0}), $""Index too small {{{0}}} < 0"");", paramName);
string EmitOffsetTooSmallCheck() => EmitOffsetTooSmallCheck("index");

string EmitOffsetTooLargeCheck(string paramName, string limit) => string.Format(@"if ({0} >= {1}) throw new ArgumentOutOfRangeException(nameof({0}), $""Index too large {{{0}}} >= {{{1}}}"");", paramName, limit);
string EmitOffsetTooLargeCheck(string limit) => EmitOffsetTooLargeCheck("index", limit);
string EmitOffsetTooLargeCheck() => EmitOffsetTooLargeCheck("length");

string EmitCountTooSmallCheck(string paramName) => string.Format(@"if ({0} < 0) throw new ArgumentOutOfRangeException(nameof({0}), $""Count too small {{{0}}} < 0"");", paramName);
string EmitCountTooSmallCheck() => EmitCountTooSmallCheck("count");

string EmitCountTooLargeCheck(string source, string length, string paramName) => string.Format(@"if ({0} > {1}) throw new ArgumentOutOfRangeException(nameof({2}), $""Count too large {{{0}}} > {{{1}}}"");", source, length, paramName);
string EmitCountTooLargeCheck(string source, string length) => EmitCountTooLargeCheck(source, length, source);
string EmitCountTooLargeCheck(string length) => EmitCountTooLargeCheck("count", length);
string EmitCountTooLargeCheck() => EmitCountTooLargeCheck("length");

    
#>
