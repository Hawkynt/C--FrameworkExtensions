<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
#region (c)2010-2042 Hawkynt
/*
  This file is part of Hawkynt's .NET Framework extensions.

    Hawkynt's .NET Framework extensions are free software:
    you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Hawkynt's .NET Framework extensions is distributed in the hope that
    it will be useful, but WITHOUT ANY WARRANTY; without even the implied
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
    the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Hawkynt's .NET Framework extensions.
    If not, see <http://www.gnu.org/licenses/>.
*/
#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */
<#
  const int LINEAR_BLOCK_COUNT = 16;
  const int MARSHALL_UNROLL_COUNT = 16;
  const int INDEX_LOOP_UNROLL = 8;
  const int ELEMENT_COUNT_BLOCK = 256;
  const int BYTE_COUNT_POINTER = 1 * 1024 * 1024;

  var typeDatas = new List<TypeData>();
  typeDatas.Add(new TypeData{ name = "sbyte", size = 1, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "byte", size = 1, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "short", size = 2, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "ushort", size = 2, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "int", size = 4, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "uint", size = 4, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "long", size = 8, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "ulong", size = 8, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "float", size = 4, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "double", size = 8, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "char", size = 2, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "string"});
  typeDatas.Add(new TypeData{ name = "decimal", size = 16});
  typeDatas.Add(new TypeData{ name = "bool", size = 1});
  typeDatas.Add(new TypeData{ name = "IntPtr", hasHandcraftedCopyToMethod = true, noArraySupport = true});
  typeDatas.Add(new TypeData{ name = "byte*", hasHandcraftedCopyToMethod = true, noArraySupport = true, isUnsafeOnly = true});
    
  Func<int, string> EmitFastIntegerMultiply = i => {
    switch(i) {
      case 1:  return string.Empty;
      case 2:  return " << 1";
      case 4:  return " << 2";
      case 8:  return " << 3";
      case 16: return " << 4";
      case 32: return " << 5";
      case 64: return " << 6";
      case 128:return " << 7";
      default: return " * " + i;
    }
    };

  Func<int, string> EmitFastIntegerDivide = i => {
    switch(i) {
      case 1:  return string.Empty;
      case 2:  return " >> 1";
      case 4:  return " >> 2";
      case 8:  return " >> 3";
      case 16: return " >> 4";
      case 32: return " >> 5";
      case 64: return " >> 6";
      case 128:return " >> 7";
      default: return " / " + i;
    }
    };
  
  Func<int, string> EmitFastIntegerModulo = i => {
    switch(i) {
      case 1:  return string.Empty;
      case 2:  return " & 1";
      case 4:  return " & 0b11";
      case 8:  return " & 0b111";
      case 16: return " & 0b1111";
      case 32: return " & 0b11111";
      case 64: return " & 0b111111";
      case 128:return " & 0b1111111";
      default: return " % " + i;
    }
    };
  
  Func<int, int, string> EmitCopyBlock2 = (n, i) => {
    if (n == 1)
      return i == 0 ? "*target = *source;" : string.Format("target[{0}] = source[{0}];", n, i);
    else
      return i == 0 ? string.Format("*(Block{0}*)target = *(Block{0}*)source;", n) : string.Format("((Block{0}*)target)[{1}] = ((Block{0}*)source)[{1}];", n, i);
  };

  Func<int, string> EmitCopyByte1 = i => i == 0 ? "*target = *source;" : string.Format("target[{0}] = source[{0}];", i);
  Func<int, string> EmitCopyWord1 = i => i == 0 ? "*(short*)target = *(short*)source;" : string.Format("((short*)target)[{0}] = ((short*)source)[{0}];", i);
  Func<int, string> EmitCopyDWord1 = i => i == 0 ? "*(int*)target = *(int*)source;" : string.Format("((int*)target)[{0}] = ((int*)source)[{0}];", i);
  Func<int, string> EmitCopyQWord1 = i => i == 0 ? "*(long*)target = *(long*)source;" : string.Format("((long*)target)[{0}] = ((long*)source)[{0}];", i);

  Func<int, string> EmitMarshalCopyByte1 = i => string.Format("Marshal.WriteByte(target, tgtIndex{0}, Marshal.ReadByte(source, srcIndex{0}));", i == 0 ? string.Empty : " + " + i);
  Func<int, string> EmitMarshalCopyWord1 = i => string.Format("Marshal.WriteInt16(target, tgtIndex{0}, Marshal.ReadInt16(source, srcIndex{0}));", i == 0 ? string.Empty : " + " + i);
  Func<int, string> EmitMarshalCopyDWord1 = i => string.Format("Marshal.WriteInt32(target, tgtIndex{0}, Marshal.ReadInt32(source, srcIndex{0}));", i == 0 ? string.Empty : " + " + i);
  Func<int, string> EmitMarshalCopyQWord1 = i => string.Format("Marshal.WriteInt64(target, tgtIndex{0}, Marshal.ReadInt64(source, srcIndex{0}));", i == 0 ? string.Empty : " + " + i);
    
  Func<int, IEnumerable<string>> EmitCopyBytes1 = c => {
    var results = new List<string>();
    var o = 0;
    while(c >= 8) {
      results.Add(EmitCopyQWord1(o >> 3));
      c -= 8;
      o += 8;
    }
    if (c >= 4) {
      results.Add(EmitCopyDWord1(o >> 2));
      c -= 4;
      o += 4;
    }
    if (c >= 2) {
      results.Add(EmitCopyWord1(o >> 1));
      c -= 2;
      o += 2;
    }
    if (c >= 1) 
      results.Add(EmitCopyByte1(o));

    return results;
    }; 

  Func<int, IEnumerable<string>> EmitMarshalCopyBytes1 = c => {
    var results = new List<string>();
    var o = 0;
    if((c & 1) != 0) {
      results.Add(EmitMarshalCopyByte1(o));
      ++o;
    }
    if((c & 2) != 0) {
      results.Add(EmitMarshalCopyWord1(o));
      o += 2;
    }
    if((c & 4) != 0) {
      results.Add(EmitMarshalCopyDWord1(o));
      o += 4;
    }
    c >>= 3;
    while(c > 0) {
      results.Add(EmitMarshalCopyQWord1(o));
      o += 8;
      --c;
    }

    return results;
  }; 

  Func<TypeData, string> EmitTypeDef = i => i.noArraySupport ? i.name : i.name + "[]"; 

  Func<string, string> EmitOffsetTooSmallCheck1 = s => string.Format(@"if ({0} < 0) throw new ArgumentOutOfRangeException(nameof({0}), $""Index too small {{{0}}} < 0"");", s);
  Func<string> EmitOffsetTooSmallCheck = () => EmitOffsetTooSmallCheck1("index");

  Func<string, string, string> EmitOffsetTooLargeCheck2 = (s, l) => string.Format(@"if ({0} >= {1}) throw new ArgumentOutOfRangeException(nameof({0}), $""Index too large {{{0}}} >= {{{1}}}"");", s, l);
  Func<string, string> EmitOffsetTooLargeCheck1 = l => EmitOffsetTooLargeCheck2("index", l);
  Func<string> EmitOffsetTooLargeCheck = () => EmitOffsetTooLargeCheck1("length");

  Func<string, string> EmitCountTooSmallCheck1 = s => string.Format(@"if ({0} < 0) throw new ArgumentOutOfRangeException(nameof({0}), $""Count too small {{{0}}} < 0"");", s);
  Func<string> EmitCountTooSmallCheck = () => EmitCountTooSmallCheck1("count");

  Func<string, string, string, string> EmitCountTooLargeCheck3 = (s, l, a) => string.Format(@"if ({0} > {1}) throw new ArgumentOutOfRangeException(nameof({2}), $""Count too large {{{0}}} > {{{1}}}"");", s, l, a);
  Func<string, string, string> EmitCountTooLargeCheck2 = (s, l) => EmitCountTooLargeCheck3(s, l, s);
  Func<string, string> EmitCountTooLargeCheck1 = l => EmitCountTooLargeCheck2("count", l);
  Func<string> EmitCountTooLargeCheck = () => EmitCountTooLargeCheck1("length");

  Func<int, string> EmitIndexCopy = i => string.Format(@"target[tgtIndex{0}] = source[srcIndex{0}];", i == 0 ? string.Empty : " + " + i);
  
  Func<string> EmitThisNullCheck = () => @"if (@this == null) throw new NullReferenceException();";
  Func<string, string> EmitArgNullCheck = s => string.Format(@"if ({0} == null) throw new ArgumentNullException(nameof({0}));", s);
#>

using System.Runtime.InteropServices;
#if NET45
using System.Runtime.CompilerServices;
#endif

using Block1 = System.Byte;
using Block2 = System.UInt16;
using Block4 = System.UInt32;
using Block8 = System.UInt64;

// ReSharper disable UnusedMemberInSuper.Global
// ReSharper disable UnusedAutoPropertyAccessor.Global
// ReSharper disable PartialTypeWithSinglePart
// ReSharper disable UnusedMember.Global
// ReSharper disable MemberCanBePrivate.Global
namespace System {
  internal static partial class ArrayExtensions {
    
    #region nested types

<#  for(var i = 3;i <= LINEAR_BLOCK_COUNT; ++i) {#>
<#    if(i == 1 || i == 2 || i == 4 || i == 8 || i == 64) continue;#>
    [StructLayout(LayoutKind.Sequential, Size=<#=i#>)] private struct Block<#=i#>{ }
<#  }#>

    #endregion

    // TODO: copy byte* using Block64, Block2-Block16
    // TODO: Clear for byte[], IntPtr, byte*, ushort[], short[], uint[], int[], ulong[], long[], float[], double[]
    // TODO: Fill for byte[], IntPtr, byte*, ushort[], short[], uint[], int[], ulong[], long[], float[], double[]
    // TODO: SequenceEquals for byte[], IntPtr, byte*, ushort[], short[], uint[], int[], ulong[], long[], float[], double[]

    #region Copy
<#  foreach(var typeData in typeDatas) {#>
<#    var typeName = typeData.name;#>
<#    if(typeData.isUnsafeOnly) {#>

#if UNSAFE
<#    }#>
<#    if(!typeData.noArraySupport) {#>
    
    public static <#=(typeData.isUnsafeOnly ? "unsafe " : string.Empty)#><#=EmitTypeDef(typeData)#> Copy(<#=(typeData.isUnsafeOnly ? string.Empty : "this ")#><#=EmitTypeDef(typeData)#> @this) {
      if (@this == null)
        return null;

      var length = @this.Length;
      var result = new <#=typeName#>[length];
      _CopyTo(@this, 0, result, 0, length);
      return result;
    }

    public static <#=(typeData.isUnsafeOnly ? "unsafe " : string.Empty)#><#=EmitTypeDef(typeData)#> Copy(<#=(typeData.isUnsafeOnly ? string.Empty : "this ")#><#=EmitTypeDef(typeData)#> @this, int index) {
      if (@this == null)
        return null;

      <#=EmitOffsetTooSmallCheck()#>
      var length = @this.Length;
      <#=EmitOffsetTooLargeCheck()#>
      var count = length - index;
      var result = new <#=typeName#>[count];
      _CopyTo(@this, index, result, 0, count);
      return result;
    }

    public static <#=(typeData.isUnsafeOnly ? "unsafe " : string.Empty)#><#=EmitTypeDef(typeData)#> Copy(<#=(typeData.isUnsafeOnly ? string.Empty : "this ")#><#=EmitTypeDef(typeData)#> @this, int index, int count) {
      if (@this == null)
        return null;

      <#=EmitOffsetTooSmallCheck()#>
      var length = @this.Length;
      <#=EmitOffsetTooLargeCheck()#>
      <#=EmitCountTooSmallCheck()#>
      <#=EmitCountTooLargeCheck1("length - index")#>

      var result = new <#=typeName#>[count];
      _CopyTo(@this, index, result, 0, count);
      return result;
    }
<#    }#>

<#    if(!typeData.NeedsCount) {#>
    public static <#=(typeData.isUnsafeOnly ? "unsafe " : string.Empty)#>void CopyTo(<#=(typeData.isUnsafeOnly ? string.Empty : "this ")#><#=EmitTypeDef(typeData)#> @this, <#=EmitTypeDef(typeData)#> target) {
<#      if(!typeData.IsValueType)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#      }#>
      var count = @this.Length;
      <#=EmitCountTooLargeCheck3("count", "target.Length", "target")#>
      _CopyTo(@this, 0 , target, 0, count);
    }

    public static <#=(typeData.isUnsafeOnly ? "unsafe " : string.Empty)#>void CopyTo(<#=(typeData.isUnsafeOnly ? string.Empty : "this ")#><#=EmitTypeDef(typeData)#> @this, int srcIndex, <#=EmitTypeDef(typeData)#> target) {
<#      if(!typeData.IsValueType)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#      }#>
      <#=EmitOffsetTooSmallCheck1("srcIndex")#>
      var length = @this.Length;
      <#=EmitOffsetTooLargeCheck2("srcIndex", "length")#>
      var count = length - srcIndex;
      <#=EmitCountTooLargeCheck3("count", "target.Length", "target")#>
      _CopyTo(@this, srcIndex , target, 0, count);
    }

    public static <#=(typeData.isUnsafeOnly ? "unsafe " : string.Empty)#>void CopyTo(<#=(typeData.isUnsafeOnly ? string.Empty : "this ")#><#=EmitTypeDef(typeData)#> @this, <#=EmitTypeDef(typeData)#> target, int tgtIndex) {
<#      if(!typeData.IsValueType)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#      }#>
      <#=EmitOffsetTooSmallCheck1("tgtIndex")#>
      var length = target.Length;
      <#=EmitOffsetTooLargeCheck2("tgtIndex", "length")#>
      var count = @this.Length;
      <#=EmitCountTooLargeCheck3("count", "target.Length - tgtIndex", "@this")#>
      _CopyTo(@this, 0 , target, tgtIndex, count);
    }
<#    } else {#>
    public static <#=(typeData.isUnsafeOnly ? "unsafe " : string.Empty)#>void CopyTo(<#=(typeData.isUnsafeOnly ? string.Empty : "this ")#><#=EmitTypeDef(typeData)#> @this, int count, <#=EmitTypeDef(typeData)#> target) {
<#      if(!typeData.IsValueType)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#      }#>
      <#=EmitCountTooSmallCheck()#>
      _CopyTo(@this, 0 , target, 0, count);
    }

    public static <#=(typeData.isUnsafeOnly ? "unsafe " : string.Empty)#>void CopyTo(<#=(typeData.isUnsafeOnly ? string.Empty : "this ")#><#=EmitTypeDef(typeData)#> @this, int count, int srcIndex, <#=EmitTypeDef(typeData)#> target) {
<#      if(!typeData.IsValueType)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#      }#>
      <#=EmitOffsetTooSmallCheck1("srcIndex")#>
      <#=EmitCountTooSmallCheck()#>
      _CopyTo(@this, srcIndex , target, 0, count);
    }

    public static <#=(typeData.isUnsafeOnly ? "unsafe " : string.Empty)#>void CopyTo(<#=(typeData.isUnsafeOnly ? string.Empty : "this ")#><#=EmitTypeDef(typeData)#> @this, int count, <#=EmitTypeDef(typeData)#> target, int tgtIndex) {
<#      if(!typeData.IsValueType)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#      }#>
      <#=EmitOffsetTooSmallCheck1("tgtIndex")#>
      <#=EmitCountTooSmallCheck()#>
      _CopyTo(@this, 0 , target, tgtIndex, count);
    }
<#    }#>

    public static <#=(typeData.isUnsafeOnly ? "unsafe " : string.Empty)#>void CopyTo(<#=(typeData.isUnsafeOnly ? string.Empty : "this ")#><#=EmitTypeDef(typeData)#> @this, int srcIndex, <#=EmitTypeDef(typeData)#> target, int tgtIndex, int count) {
<#    if(!typeData.IsValueType)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#    }#>
      <#=EmitOffsetTooSmallCheck1("srcIndex")#>
      <#=EmitOffsetTooSmallCheck1("tgtIndex")#>
      <#=EmitCountTooSmallCheck()#>
<#    if(typeData.SupportsLength) {#>
      <#=EmitOffsetTooLargeCheck2("srcIndex", "@this.Length")#>
      <#=EmitOffsetTooLargeCheck2("tgtIndex", "target.Length")#>
      <#=EmitCountTooLargeCheck2("count", "@this.Length - srcIndex")#>
      <#=EmitCountTooLargeCheck2("count", "target.Length - tgtIndex")#>
<#    }#>
      _CopyTo(@this, srcIndex , target, tgtIndex, count);
    }
<#    if(typeData.allowByteConversion){#>
<#      foreach(var tgtTypeData in typeDatas.Where(i=>i.name != typeName && i.allowByteConversion)){#>

    public static <#=(typeData.isUnsafeOnly ? "unsafe " : string.Empty)#>void CopyTo(<#=(typeData.isUnsafeOnly ? string.Empty : "this ")#><#=EmitTypeDef(typeData)#> @this, int srcIndex, <#=EmitTypeDef(tgtTypeData)#> target, int tgtIndex, int count) {
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
      <#=EmitOffsetTooSmallCheck1("srcIndex")#>
      <#=EmitOffsetTooSmallCheck1("tgtIndex")#>
      <#=EmitOffsetTooLargeCheck2("srcIndex", "@this.Length")#>
      <#=EmitOffsetTooLargeCheck2("tgtIndex", "target.Length")#>
      <#=EmitCountTooLargeCheck2("count", "@this.Length - srcIndex")#>
<#        if(tgtTypeData.size != typeData.size) {#>
      var bytesNeeded = count<#=EmitFastIntegerMultiply(typeData.size)#>;
      var bytesAvailable = (target.Length - tgtIndex)<#=EmitFastIntegerMultiply(tgtTypeData.size)#>;
      <#=EmitCountTooLargeCheck3("bytesNeeded", "bytesAvailable", "count")#>
      if ((bytesNeeded<#=EmitFastIntegerModulo(tgtTypeData.size)#>) != 0) throw new ArgumentException("Need more items to fully cover target items", nameof(count));
<#        } else {#>
      <#=EmitCountTooLargeCheck3("count", "target.Length - tgtIndex", "count")#>
<#        }#>
      _CopyTo(@this, srcIndex, target, tgtIndex, count);
    }
<#      }#>
<#    }#>
<#    if(typeData.isUnsafeOnly) {#>

#endif
<#    }#>
<#  }#>
<#  foreach(var typeData in typeDatas.Where(i=>!i.hasHandcraftedCopyToMethod)) {#>
<#    var typeName = typeData.name;#>
    
#if NET45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static void _CopyTo(<#=EmitTypeDef(typeData)#> source, int srcIndex,<#=EmitTypeDef(typeData)#> target, int tgtIndex, int count){
label:
      switch(count){
<#    for(var i = 0; i < INDEX_LOOP_UNROLL; ++i) {#>
<#      if(i == 0) {#>
        case 0: return;
<#      } else {#>
        case <#=i#>:
<#        for(var j = 0; j < i; ++j) {#>
          <#=EmitIndexCopy(j)#>
<#        }#>
          return;
<#      }#>
<#    }#>
      }

<#    if(BYTE_COUNT_POINTER > 0 && typeData.size > 0 && typeData.useBlockCopyInsteadOfArrayCopy) {#>
      if( count > <#=(BYTE_COUNT_POINTER / typeData.size)#>) {
#if UNSAFE
        unsafe {
          fixed(<#=typeData.name#>* sourceFixedPointer = &source[srcIndex])
          fixed(<#=typeData.name#>* targetFixedPointer = &target[tgtIndex])
            _CopyTo(<#=(typeData.name == "byte" ? string.Empty : "(byte*)")#>sourceFixedPointer, <#=(typeData.name == "byte" ? string.Empty : "(byte*)")#>targetFixedPointer, count<#=EmitFastIntegerMultiply(typeData.size)#>);
        }
#else
        using (var sourceFixedPointer = DisposableGCHandle.Pin(source))
        using (var targetFixedPointer = DisposableGCHandle.Pin(target))
          _CopyTo(sourceFixedPointer.AddrOfPinnedObject(), srcIndex<#=EmitFastIntegerMultiply(typeData.size)#>, targetFixedPointer.AddrOfPinnedObject(), tgtIndex<#=EmitFastIntegerMultiply(typeData.size)#>, count<#=EmitFastIntegerMultiply(typeData.size)#>);
#endif

        return;
      }

<#    }#>
<#    if(ELEMENT_COUNT_BLOCK > 0) {#>
      if(count > <#=ELEMENT_COUNT_BLOCK#>) {
        <#=(typeData.useBlockCopyInsteadOfArrayCopy ? "Buffer.BlockCopy" : "Array.Copy")#>(source, srcIndex<#=(typeData.useBlockCopyInsteadOfArrayCopy ? EmitFastIntegerMultiply(typeData.size) : string.Empty)#>, target, tgtIndex<#=(typeData.useBlockCopyInsteadOfArrayCopy ? EmitFastIntegerMultiply(typeData.size) : string.Empty)#>, count<#=(typeData.useBlockCopyInsteadOfArrayCopy ? EmitFastIntegerMultiply(typeData.size) : string.Empty)#>);
        return;
      }

<#    }#>
      while(count >= <#=INDEX_LOOP_UNROLL#>) {
<#    for(var i = 0; i < INDEX_LOOP_UNROLL; ++i) {#>
        <#=EmitIndexCopy(i)#>
<#    }#>
          
        srcIndex += <#=INDEX_LOOP_UNROLL#>;
        tgtIndex += <#=INDEX_LOOP_UNROLL#>;
        count -= <#=INDEX_LOOP_UNROLL#>;
      }

      goto label;
    }
<#    if(typeData.allowByteConversion){#>
<#      foreach(var tgtTypeData in typeDatas.Where(i=>i.name != typeName && i.allowByteConversion)){#>

#if NET45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static void _CopyTo(<#=EmitTypeDef(typeData)#> source, int srcIndex, <#=EmitTypeDef(tgtTypeData)#> target, int tgtIndex, int count)
      => Buffer.BlockCopy(source, srcIndex<#=EmitFastIntegerMultiply(typeData.size)#>, target, tgtIndex<#=EmitFastIntegerMultiply(tgtTypeData.size)#>, count<#=EmitFastIntegerMultiply(typeData.size)#>)
    ;
<#      }#>
<#    }#>
<#  }#>

#if UNSAFE

#if NET45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static unsafe void _CopyTo(byte* source, int srcIndex, byte* target, int tgtIndex, int count)
      => _CopyTo(source + srcIndex, target + tgtIndex, count)
    ;

#if NET45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static unsafe void _CopyTo(byte* source, byte* target, int count) {
byteLoop:
      switch(count) {
<#  for(var i = 0; i <= LINEAR_BLOCK_COUNT; ++i) {#>
<#    if(i == 0) {#>
        case 0: 
          return;
<#    } else {#>
        case <#=i#>: 
          <#=EmitCopyBlock2(i, 0)#>
          return;
<#    }#>
<#  }#>
      }
      
      <#=EmitCopyBlock2(LINEAR_BLOCK_COUNT, 0)#>
      count -= <#=LINEAR_BLOCK_COUNT#>;
      source += <#=LINEAR_BLOCK_COUNT#>;
      target += <#=LINEAR_BLOCK_COUNT#>;
      
      var blockCount = count<#=EmitFastIntegerDivide(LINEAR_BLOCK_COUNT)#>;
      count = count<#=EmitFastIntegerModulo(LINEAR_BLOCK_COUNT)#>;

blockLoop:

      switch (blockCount) {
<#  for(var i = 0; i <= INDEX_LOOP_UNROLL; ++i) {#>
<#    if(i == 0) {#>
        case 0: goto byteLoop;
<#    } else {#>
        case <#=i#>: goto blockDuff<#=(INDEX_LOOP_UNROLL - i)#>;
<#    }#>
<#  }#>
        default: goto blockDuffOut;
      }

<#  for(var i = 0; i < INDEX_LOOP_UNROLL; ++i) {#>
blockDuff<#=i#>: <#=EmitCopyBlock2(LINEAR_BLOCK_COUNT, INDEX_LOOP_UNROLL - i - 1)#>
<#  }#>

      var processed = blockCount<#=EmitFastIntegerMultiply(LINEAR_BLOCK_COUNT)#>;
      source += processed;
      target += processed;
      goto byteLoop;

blockDuffOut:

      do {
<#  for(var j = 0; j < INDEX_LOOP_UNROLL; ++j){#>
        <#=EmitCopyBlock2(LINEAR_BLOCK_COUNT, j)#>
<#  }#>
        source += <#=(INDEX_LOOP_UNROLL * LINEAR_BLOCK_COUNT)#>;
        target += <#=(INDEX_LOOP_UNROLL * LINEAR_BLOCK_COUNT)#>;
        blockCount -= <#=INDEX_LOOP_UNROLL#>;
      } while (blockCount >= <#=INDEX_LOOP_UNROLL#>);

      goto blockLoop;
    }
#endif

#if NET45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static void _CopyTo(IntPtr source, int srcIndex, IntPtr target, int tgtIndex, int count) {
byteLoop:
      switch(count) {
<#  for(var i = 0; i <= MARSHALL_UNROLL_COUNT; ++i) {#>
<#    if(i == 0) {#>
        case 0: return;
<#    } else {#>
        case <#=i#>:
          <#=string.Join("\r\n          ",EmitMarshalCopyBytes1(i))#>
          return;
<#    }#>
<#  }#>
      }

      <#=string.Join("\r\n      ",EmitMarshalCopyBytes1(MARSHALL_UNROLL_COUNT))#>
      count -= <#=MARSHALL_UNROLL_COUNT#>;
      srcIndex += <#=MARSHALL_UNROLL_COUNT#>;
      tgtIndex += <#=MARSHALL_UNROLL_COUNT#>;
          
      var qwordCount = count<#=EmitFastIntegerDivide(8)#>;
      count = count<#=EmitFastIntegerModulo(8)#>;

qwordLoop:

      switch (qwordCount) {
<#  for(var i = 0; i <= INDEX_LOOP_UNROLL; ++i) {#>
<#    if(i == 0) {#>
        case 0: goto byteLoop;
<#    } else {#>
        case <#=i#>: goto qwordDuff<#=(INDEX_LOOP_UNROLL - i)#>;
<#    }#>
<#  }#>
        default: goto qwordDuffOut;
      }

<#  for(var i = 0; i < INDEX_LOOP_UNROLL; ++i) {#>
qwordDuff<#=i#>: <#=EmitMarshalCopyQWord1((INDEX_LOOP_UNROLL - i - 1) * 8)#>;
<#  }#>

      var processed = qwordCount<#=EmitFastIntegerMultiply(8)#>;
      srcIndex += processed;
      tgtIndex += processed;
      goto byteLoop;

qwordDuffOut:

      do {
        <#=string.Join("\r\n        ",EmitMarshalCopyBytes1(INDEX_LOOP_UNROLL * 8))#>
        srcIndex += <#=(INDEX_LOOP_UNROLL * 8)#>;
        tgtIndex += <#=(INDEX_LOOP_UNROLL * 8)#>;
        qwordCount -= <#=INDEX_LOOP_UNROLL#>;
      } while (qwordCount >= <#=INDEX_LOOP_UNROLL#>);

      goto qwordLoop;
    }

    #endregion


  }
}

<#+
public struct TypeData {
  public string name;
  public int size;
  public bool useBlockCopyInsteadOfArrayCopy;
  public bool allowByteConversion;
  public bool noArraySupport;
  public bool hasHandcraftedCopyToMethod;
  public bool isUnsafeOnly;
  public bool NeedsCount {get{return this.noArraySupport; }}
  public bool SupportsLength {get{return !this.noArraySupport; }}
  public bool IsValueType {get{return this.noArraySupport; }}
}
#>
