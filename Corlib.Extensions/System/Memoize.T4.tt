<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#region (c)2010-2042 Hawkynt

// This file is part of Hawkynt's .NET Framework extensions.
// 
// Hawkynt's .NET Framework extensions are free software:
// you can redistribute and/or modify it under the terms
// given in the LICENSE file.
// 
// Hawkynt's .NET Framework extensions is distributed in the hope that
// it will be useful, but WITHOUT ANY WARRANTY without even the implied
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the LICENSE file for more details.
// 
// You should have received a copy of the License along with Hawkynt's
// .NET Framework extensions. If not, see
// <https://github.com/Hawkynt/C--FrameworkExtensions/blob/master/LICENSE>.

#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */

using System;
using System.Collections.Concurrent;
using System.Runtime.CompilerServices;
// ReSharper disable ExplicitCallerInfoArgument

/// <summary>
/// Provides methods for memoizing functions with multiple input arguments.
/// </summary>
public static class Memoize {
<# for (int i = 1; i <= 8; ++i) { #>
<#
  // Generate generic argument lists like "<TArg1, TArg2, TResult>"
  var genericArgs = string.Join(", ", Enumerable.Range(1, i).Select(n => $"TArg{n}"));
  var fullGenericArgs = $"{genericArgs}, TResult";

  // Generate parameter lists like "(Func<TArg1, TArg2, TResult> funcToMemoize, ...)"
  var funcType = $"Func<{fullGenericArgs}>";
  var methodParams = $"{funcType} funcToMemoize";

  // Generate ValueTuple types for cache keys like "<(TArg1, TArg2), TResult>"
  var tupleArgs = string.Join(", ", Enumerable.Range(1, i).Select(n => $"TArg{n}"));
  var cacheKeyType = i == 1 ? genericArgs : $"({tupleArgs})";
    
  // Generate parameter names for the final lambda like "(TArg1 arg1, TArg2 arg2)"
  var lambdaParams = string.Join(", ", Enumerable.Range(1, i).Select(n => $"arg{n}"));
    
  // Generate key creation for GetOrAdd like "(arg1, arg2)"
  var keyCreation = i == 1 ? "arg1" : $"({string.Join(", ", Enumerable.Range(1, i).Select(n => $"arg{n}"))})";
    
  // Generate parameters for calling the original function like "key.Item1, key.Item2"
  var funcCallParams = i == 1 ? "key" : string.Join(", ", Enumerable.Range(1, i).Select(n => $"key.Item{n}"));
#>
  /// <summary>
  /// Memoizes the specified function with <#=i#> input arguments, caching computed results based on the argument combination.
  /// This method is designed to be called inline within the function body to automatically add memoization to pure functions.
  /// </summary>
  <# for (int j = 1; j <= i; ++j) { #>
  /// <typeparam name="TArg<#=j#>">The type of argument <#=j#>.</typeparam>
  <# } #>
  /// <typeparam name="TResult">The return type of the function.</typeparam>
  /// <param name="funcToMemoize">The function to memoize. The function will be wrapped and cached automatically per input combination.</param>
  /// <param name="path">The source code location filename where the value is defined; filled by compiler - leave empty!</param>
  /// <param name="line">The source code location line number where the value is defined; filled by compiler - leave empty!</param>
  /// <returns>
  /// A function wrapper that performs memoization for the given <paramref name="funcToMemoize"/>.
  /// </returns>
  /// <example>
  /// <code>
  /// int Sum(int a, int b) =>
  ///   Memoize.GetOrAdd((int a, int b) => 
  ///     a + b)(a, b);
  ///
  /// int result1 = Sum(1,2);  // Computed and cached
  /// int result2 = Sum(1,2);  // Retrieved from cache
  /// </code>
  /// </example>
  public static <#= funcType #> GetOrAdd<<#= fullGenericArgs #>>(
      <#= methodParams #>,
      [CallerFilePath] string path = null,
      [CallerLineNumber] int line = 0
  ) {
    var cache = StaticMethodLocal<ConcurrentDictionary<<#= cacheKeyType #>, TResult>>.GetOrAdd(path, line);
    return (<#= lambdaParams #>) => cache.Ref.GetOrAdd(<#= keyCreation #>, <#= i == 1 ? "funcToMemoize" : $"key => funcToMemoize({funcCallParams})" #>);
  }

<# } #>
}
