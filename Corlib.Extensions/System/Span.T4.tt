<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Runtime.InteropServices" #>
<#@ output extension=".cs" #>
<#
  var ops = new[] {
    ("And",  "*s & *o"),
    ("Or",   "*s | *o"),
    ("Xor",  "*s ^ *o"),
    ("Nand", "~(*s & *o)"),
    ("Nor",  "~(*s | *o)"),
    ("Equ",  "~(*s ^ *o)")
  };

  var convertibleTypes =  new[] {
    "sbyte",
    "ushort",
    "short",
    "uint",
    "int",
    "ulong",
    "long",
    "bool"
  };

  const int MAX_REGISTER_USAGE = 8;
  int MAX_BYTES_PER_LOOP;
#>
#region (c)2010-2042 Hawkynt

// This file is part of Hawkynt's .NET Framework extensions.
// 
// Hawkynt's .NET Framework extensions are free software:
// you can redistribute and/or modify it under the terms
// given in the LICENSE file.
// 
// Hawkynt's .NET Framework extensions is distributed in the hope that
// it will be useful, but WITHOUT ANY WARRANTY without even the implied
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the LICENSE file for more details.
// 
// You should have received a copy of the License along with Hawkynt's
// .NET Framework extensions. If not, see
// <https://github.com/Hawkynt/C--FrameworkExtensions/blob/master/LICENSE>.

#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using MethodImplOptions = Utilities.MethodImplOptions;

#if SUPPORTS_VECTOR_512 || SUPPORTS_VECTOR_256 || SUPPORTS_VECTOR_128
using System.Runtime.Intrinsics;
#endif

using Guard;

// ReSharper disable UnusedMember.Global
// ReSharper disable RedundantCast
// ReSharper disable CompareOfFloatsByEqualityOperator
namespace System;

public static partial class SpanExtensions {

<# foreach(var (name, math) in ops) { #>
  public static unsafe void <#=name#>(this Span<byte> @this, ReadOnlySpan<byte> operand) {
    Against.False(@this.Length == operand.Length);

    if(@this.IsEmpty)
      return;

    fixed (byte* targetPin  = @this)
    fixed (byte* operandPin = operand)
      _Unmanaged<#=name#>(targetPin, operandPin, (uint)@this.Length);
  }

  public static unsafe void <#=name#>(this ReadOnlySpan<byte> @this, ReadOnlySpan<byte> operand, Span<byte> target) {
    Against.False(@this.Length == operand.Length);
    Against.False(@this.Length == target.Length);

    if(@this.IsEmpty)
      return;

    fixed (byte* sourcePin  = @this)
    fixed (byte* targetPin  = target)
    fixed (byte* operandPin = operand)
      _Unmanaged<#=name#>(targetPin, sourcePin, operandPin, (uint)@this.Length);
  }
  

#if PLATFORM_X86

  private static unsafe void _Unmanaged<#=name#>(byte* targetPointer, byte* operandPointer, uint count) {
<# MAX_BYTES_PER_LOOP = 4 * MAX_REGISTER_USAGE; #>
    for (;;)
      switch (count) {
        case 0: goto Exit;
<#
   for (var i = 1; i <= MAX_BYTES_PER_LOOP; ++i)
     GenerateCase(i, math, true, "targetPointer", "operandPointer");
#>

        default: {
          var blocks = count / <#=MAX_BYTES_PER_LOOP#>;
          count %= <#=MAX_BYTES_PER_LOOP#>;
          do {
<# for (var i = 0; i < MAX_REGISTER_USAGE; ++i) { #>
            var r<#=i#> = ((uint*)targetPointer)[<#=i#>];
<# } #>
<# for (var i = 0; i < MAX_REGISTER_USAGE; ++i) { #>
            r<#=i#> = <#=math.Replace("*s", $"r{i}").Replace("*o", $"((uint*)operandPointer)[{i}]")#>;
<# } #>
<# for (var i = 0; i < MAX_REGISTER_USAGE; ++i) { #>
            ((uint*)targetPointer)[<#=i#>] = r<#=i#>;
<# } #>
            targetPointer += <#=MAX_BYTES_PER_LOOP#>;
            operandPointer += <#=MAX_BYTES_PER_LOOP#>;
          } while (--blocks > 0);
          continue;
        } // default
      } // switch
    // for
    Exit:
      return;
  }

  private static unsafe void _Unmanaged<#=name#>(byte* targetPointer, byte* sourcePointer, byte* operandPointer, uint count) {
    for (;;)
      switch (count) {
        case 0: goto Exit;
<#
   for (var i = 1; i <= MAX_BYTES_PER_LOOP; ++i)
     GenerateCase(i, math, true, "sourcePointer", "operandPointer", "targetPointer");
#>

        default: {
          var blocks = count / <#=MAX_BYTES_PER_LOOP#>;
          count %= <#=MAX_BYTES_PER_LOOP#>;
          do {
<# for (var i = 0; i < MAX_REGISTER_USAGE; ++i) { #>
            var r<#=i#> = ((uint*)sourcePointer)[<#=i#>];
<# } #>
<# for (var i = 0; i < MAX_REGISTER_USAGE; ++i) { #>
            r<#=i#> = <#=math.Replace("*s", $"r{i}").Replace("*o", $"((uint*)operandPointer)[{i}]")#>;
<# } #>
<# for (var i = 0; i < MAX_REGISTER_USAGE; ++i) { #>
            ((uint*)targetPointer)[<#=i#>] = r<#=i#>;
<# } #>
            sourcePointer += <#=MAX_BYTES_PER_LOOP#>;            
            targetPointer += <#=MAX_BYTES_PER_LOOP#>;
            operandPointer += <#=MAX_BYTES_PER_LOOP#>;
          } while (--blocks > 0);
          continue;
        } // default
      } // switch
    // for
    Exit:
      return;
  }

#else

  private static unsafe void _Unmanaged<#=name#>(byte* targetPointer, byte* operandPointer, uint count) {
<# MAX_BYTES_PER_LOOP = 8 * MAX_REGISTER_USAGE; #>
    for (;;)
      switch (count) {
        case 0: goto Exit;
<#
   for (var i = 1; i <= MAX_BYTES_PER_LOOP; ++i)
     GenerateCase(i, math, false, "targetPointer", "operandPointer");
#>

        default: {
          var blocks = count / <#=MAX_BYTES_PER_LOOP#>;
          count %= <#=MAX_BYTES_PER_LOOP#>;
          do {
<# for (var i = 0; i < MAX_REGISTER_USAGE; ++i) { #>
            var r<#=i#> = ((ulong*)targetPointer)[<#=i#>];
<# } #>
<# for (var i = 0; i < MAX_REGISTER_USAGE; ++i) { #>
            r<#=i#> = <#=math.Replace("*s", $"r{i}").Replace("*o", $"((ulong*)operandPointer)[{i}]")#>;
<# } #>
<# for (var i = 0; i < MAX_REGISTER_USAGE; ++i) { #>
            ((ulong*)targetPointer)[<#=i#>] = r<#=i#>;
<# } #>
            targetPointer += <#=MAX_BYTES_PER_LOOP#>;
            operandPointer += <#=MAX_BYTES_PER_LOOP#>;
          } while (--blocks > 0);
          continue;
        } // default
      } // switch
    // for
    Exit:
      return;
  }

  private static unsafe void _Unmanaged<#=name#>(byte* targetPointer, byte* sourcePointer, byte* operandPointer, uint count) {
    for (;;)
      switch (count) {
        case 0: goto Exit;
<#
   for (var i = 1; i <= MAX_BYTES_PER_LOOP; ++i)
     GenerateCase(i, math, false, "sourcePointer", "operandPointer", "targetPointer");
#>

        default: {
          var blocks = count / <#=MAX_BYTES_PER_LOOP#>;
          count %= <#=MAX_BYTES_PER_LOOP#>;
          do {
<# for (var i = 0; i < MAX_REGISTER_USAGE; ++i) { #>
            var r<#=i#> = ((ulong*)sourcePointer)[<#=i#>];
<# } #>
<# for (var i = 0; i < MAX_REGISTER_USAGE; ++i) { #>
            r<#=i#> = <#=math.Replace("*s", $"r{i}").Replace("*o", $"((ulong*)operandPointer)[{i}]")#>;
<# } #>
<# for (var i = 0; i < MAX_REGISTER_USAGE; ++i) { #>
            ((ulong*)targetPointer)[<#=i#>] = r<#=i#>;
<# } #>
            sourcePointer += <#=MAX_BYTES_PER_LOOP#>;
            targetPointer += <#=MAX_BYTES_PER_LOOP#>;
            operandPointer += <#=MAX_BYTES_PER_LOOP#>;
          } while (--blocks > 0);
          continue;
        } // default
      } // switch
    // for
    Exit:
      return;
  }

#endif

<# } #>

<# foreach(var type in convertibleTypes) { #>
<#   foreach(var (name, math) in ops) { #>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void <#=name#>(this Span<<#=type#>> @this, ReadOnlySpan<<#=type#>> operand) => <#=name#>(
    MemoryMarshal.AsBytes(@this),
    MemoryMarshal.AsBytes(operand)
  );

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void <#=name#>(this ReadOnlySpan<<#=type#>> @this, ReadOnlySpan<<#=type#>> operand, Span<<#=type#>> target) => <#=name#>(
    MemoryMarshal.AsBytes(@this),
    MemoryMarshal.AsBytes(operand),
    MemoryMarshal.AsBytes(target)
  );

<#   } #>
<# } #>
<# foreach(var type in convertibleTypes) { #>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Not(this Span<<#=type#>> @this) => Not(MemoryMarshal.AsBytes(@this));

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Not(this ReadOnlySpan<<#=type#>> @this, Span<<#=type#>> target) => Not(
    MemoryMarshal.AsBytes(@this),
    MemoryMarshal.AsBytes(target)
  );

<# } #>

}

<#+
  string EmitOperation<T>(string operation, string sName, string oName, string tName = null, int offset = 0, bool needsCast = false) {
    
    var typeName = 
      typeof(T)  == typeof(byte) ? "byte" :
      typeof(T)  == typeof(ushort) ? "ushort" :
      typeof(T)  == typeof(uint) ? "uint" :
      typeof(T)  == typeof(ulong) ? "ulong" :
      throw new NotSupportedException()
      ;

    tName ??= sName;
    var pointerCast = typeof(T)  == typeof(byte) ? string.Empty : $"({typeName}*)";
    string MakeAdress(string pName, int offset) => offset == 0 ? pName : $"({pName} + {offset})";

    return $"*{pointerCast}{MakeAdress(tName, offset)} = {(needsCast ? $"({typeName})(" : string.Empty)}{operation.Replace("*s", $"*{pointerCast}{MakeAdress(sName, offset)}").Replace("*o",$"*{pointerCast}{MakeAdress(oName, offset)}")}{(needsCast ? ")" : string.Empty)};";
  }

  void GenerateCase(int numberOfBytes, string operation, bool force32Bit, string sName, string oName, string tName = null) {
    int offset = 0;
#>
        case <#=numberOfBytes#>:
<#+
    if (!force32Bit) 
      while(numberOfBytes >= 8) {
#>
          <#=EmitOperation<ulong>(operation, sName, oName, tName, offset)#>
<#+
        offset += 8;
        numberOfBytes -= 8;
      }

    while(numberOfBytes >= 4) {
#>
          <#=EmitOperation<uint>(operation, sName, oName, tName, offset)#>
<#+
      offset += 4;
      numberOfBytes -= 4;
    }

    while(numberOfBytes >= 2) {
#>
          <#=EmitOperation<ushort>(operation, sName, oName, tName, offset, true)#>
<#+
      offset += 2;
      numberOfBytes -= 2;
    }
    
    for(; numberOfBytes > 0; ++offset, --numberOfBytes) {
#>
          <#=EmitOperation<byte>(operation, sName, oName, tName, offset, true)#>
<#+
    }
   
#>
          goto Exit;
<#+
  }
#>