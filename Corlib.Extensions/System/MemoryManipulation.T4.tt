<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#
var fileManager = GenerationEnvironment;
for(var blockSize = 1; blockSize <= MAX_SIZE; ++blockSize) {
  
  //string currentFileName = Path.Combine(this.Host.ResolvePath(".") , $"MemoryManipulation.Block{blockSize}.T4.cs");  
  string currentFileName = null;

  if(currentFileName != null)
    GenerationEnvironment = new StringBuilder();
#>
#region (c)2010-2042 Hawkynt

// This file is part of Hawkynt's .NET Framework extensions.
// 
// Hawkynt's .NET Framework extensions are free software:
// you can redistribute and/or modify it under the terms
// given in the LICENSE file.
// 
// Hawkynt's .NET Framework extensions is distributed in the hope that
// it will be useful, but WITHOUT ANY WARRANTY without even the implied
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the LICENSE file for more details.
// 
// You should have received a copy of the License along with Hawkynt's
// .NET Framework extensions. If not, see
// <https://github.com/Hawkynt/C--FrameworkExtensions/blob/master/LICENSE>.

#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */

namespace Corlib {
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using MethodImplOptions = Utilities.MethodImplOptions;

// ReSharper disable UnusedMember.Local
internal static partial class MemoryManipulation {  
  
  [StructLayout(LayoutKind.Sequential, Size = <#=blockSize#>)] 
  public struct Block<#=blockSize#> {

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe bool AreEqual(Block<#=blockSize#>* @this, Block<#=blockSize#>* other) =>
#if PLATFORM_X86
      _AreEqualx86(@this, other)
#else
      _AreEqualx64(@this, other)
#endif
      ;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static unsafe bool _AreEqualx64(Block<#=blockSize#>* @this, Block<#=blockSize#>* other) {
<#
    {
      if(blockSize == 1 || blockSize == 2 || blockSize == 4 || blockSize == 8) {
#>
      return *(<#=GetDataTypeForByteCount(blockSize)#>*)@this == *(<#=GetDataTypeForByteCount(blockSize)#>*) other;
<#
      } else {
      
        DoFullLoop("var result{0} = {1}", blockSize, 8, "@this");
        var resultCount = DoFullLoop("result{0} ^= {1}", blockSize, 8, "other");
#>
      return 
<#      for (var i = 0; i < resultCount; ++i){#>
        <#if(i > 0) {#>&& <#}#>result<#=i#> == 0
<#      }#>
        ;
<#
      }
    }
#>
    }
        
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static unsafe bool _AreEqualx86(Block<#=blockSize#>* @this, Block<#=blockSize#>* other) {
<#
    {
      if(blockSize == 1 || blockSize == 2 || blockSize == 4) {
#>
      return *(<#=GetDataTypeForByteCount(blockSize)#>*)@this == *(<#=GetDataTypeForByteCount(blockSize)#>*) other;
<#
      } else {

        DoFullLoop("var result{0} = {1}", blockSize, 4, "@this");
        var resultCount = DoFullLoop("result{0} ^= {1}", blockSize, 4, "other");
#>
      return 
<#      for (var i = 0; i < resultCount; ++i){#>
        <#if(i > 0) {#>&& <#}#>result<#=i#> == 0
<#      }#>
        ;
<#
      }
    }
#>
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void Fill(Block<#=blockSize#>* @this, byte value) =>
#if PLATFORM_X86
      _Fillx86(@this, value)
#else
      _Fillx64(@this, value)
#endif
      ;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static unsafe void _Fillx64(Block<#=blockSize#>* @this, byte value) {
<#
    {
      var bytesLeft = blockSize;
      var resultCount = 0;
      var byteOffset = 0;
      
      if (bytesLeft >= 8) {
#>
      var qword = 0x0101010101010101UL * value;
<#
        DoOperationLoop("{1} = qword", ref bytesLeft, ref byteOffset, ref resultCount, 8, "@this");
      }

      if (bytesLeft >= 4) {
#>
      var dword = 0x01010101U * value;
<#
        DoOperationLoop("{1} = dword", ref bytesLeft, ref byteOffset, ref resultCount, 4, "@this");
      }

      if (bytesLeft >= 2) {
#>
      var word = (ushort)(0x0101 * value);
<#
        DoOperationLoop("{1} = word", ref bytesLeft, ref byteOffset, ref resultCount, 2, "@this");
      }

      if (bytesLeft > 0)
        DoOperationLoop("{1} = value", ref bytesLeft, ref byteOffset, ref resultCount, 1, "@this");

    }
#>
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static unsafe void _Fillx86(Block<#=blockSize#>* @this, byte value) {
<#
    {
      var bytesLeft = blockSize;
      var resultCount = 0;
      var byteOffset = 0;
      
      if (bytesLeft >= 4) {
#>
      var dword = 0x01010101U * value;
<#
        DoOperationLoop("{1} = dword", ref bytesLeft, ref byteOffset, ref resultCount, 4, "@this");
      }

      if (bytesLeft >= 2) {
#>
      var word = (ushort)(0x0101 * value);
<#
        DoOperationLoop("{1} = word", ref bytesLeft, ref byteOffset, ref resultCount, 2, "@this");
      }

      if (bytesLeft > 0)
        DoOperationLoop("{1} = value", ref bytesLeft, ref byteOffset, ref resultCount, 1, "@this");
    }
#>
    }
<#if (blockSize % 2 == 0) {#>

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void Fill(Block<#=blockSize#>* @this, ushort value) =>
#if PLATFORM_X86
      _Fillx86(@this, value)
#else
      _Fillx64(@this, value)
#endif
      ;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static unsafe void _Fillx64(Block<#=blockSize#>* @this, ushort value) {
<#
    {
      var bytesLeft = blockSize;
      var resultCount = 0;
      var byteOffset = 0;
      
      if (bytesLeft >= 8) {
#>
      var qword = 0x0001000100010001UL * value;
<#
        DoOperationLoop("{1} = qword", ref bytesLeft, ref byteOffset, ref resultCount, 8, "@this");
      }

      if (bytesLeft >= 4) {
#>
      var dword = 0x00010001U * value;
<#
        DoOperationLoop("{1} = dword", ref bytesLeft, ref byteOffset, ref resultCount, 4, "@this");
      }

      if (bytesLeft >= 2)
        DoOperationLoop("{1} = value", ref bytesLeft, ref byteOffset, ref resultCount, 2, "@this");

    }
#>
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static unsafe void _Fillx86(Block<#=blockSize#>* @this, ushort value) {
<#
    {
      var bytesLeft = blockSize;
      var resultCount = 0;
      var byteOffset = 0;
      
      if (bytesLeft >= 4) {
#>
      var dword = 0x00010001U * value;
<#
        DoOperationLoop("{1} = dword", ref bytesLeft, ref byteOffset, ref resultCount, 4, "@this");
      }

      if (bytesLeft >= 2)
        DoOperationLoop("{1} = value", ref bytesLeft, ref byteOffset, ref resultCount, 2, "@this");

    }
#>
    }
<#}#>
<#if (blockSize % 4 == 0) {#>

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void Fill(Block<#=blockSize#>* @this, uint value) =>
#if PLATFORM_X86
      _Fillx86(@this, value)
#else
      _Fillx64(@this, value)
#endif
      ;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static unsafe void _Fillx64(Block<#=blockSize#>* @this, uint value) {
<#
    {
      var bytesLeft = blockSize;
      var resultCount = 0;
      var byteOffset = 0;
      
      if (bytesLeft >= 8) {
#>
      var qword = 0x0000000100000001UL * value;
<#
        DoOperationLoop("{1} = qword", ref bytesLeft, ref byteOffset, ref resultCount, 8, "@this");
      }

      if (bytesLeft >= 4)
        DoOperationLoop("{1} = value", ref bytesLeft, ref byteOffset, ref resultCount, 4, "@this");

    }
#>
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static unsafe void _Fillx86(Block<#=blockSize#>* @this, uint value) {
<#
    {
      var bytesLeft = blockSize;
      var resultCount = 0;
      var byteOffset = 0;
      
      DoOperationLoop("{1} = value", ref bytesLeft, ref byteOffset, ref resultCount, 4, "@this");
    }
#>
    }
<#}#>
<#if (blockSize % 8 == 0) {#>

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void Fill(Block<#=blockSize#>* @this, ulong value) {
<#
    {
      var bytesLeft = blockSize;
      var resultCount = 0;
      var byteOffset = 0;
      
      DoOperationLoop("{1} = value", ref bytesLeft, ref byteOffset, ref resultCount, 8, "@this");
    }
#>
    }
<#}#>

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void Clear(Block<#=blockSize#>* @this) =>
#if PLATFORM_X86
      _Clearx86(@this)
#else
      _Clearx64(@this)
#endif
      ;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static unsafe void _Clearx64(Block<#=blockSize#>* @this) {
<#
    {
      var bytesLeft = blockSize;
      var resultCount = 0;
      var byteOffset = 0;
      
      if (bytesLeft >= 8)
        DoOperationLoop("{1} = 0", ref bytesLeft, ref byteOffset, ref resultCount, 8, "@this");
      
      if (bytesLeft >= 4)
        DoOperationLoop("{1} = 0", ref bytesLeft, ref byteOffset, ref resultCount, 4, "@this");

      if (bytesLeft >= 2)
        DoOperationLoop("{1} = 0", ref bytesLeft, ref byteOffset, ref resultCount, 2, "@this");

      if (bytesLeft > 0)
        DoOperationLoop("{1} = 0", ref bytesLeft, ref byteOffset, ref resultCount, 1, "@this");

    }
#>
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static unsafe void _Clearx86(Block<#=blockSize#>* @this) {
<#
    {
      var bytesLeft = blockSize;
      var resultCount = 0;
      var byteOffset = 0;
      
      if (bytesLeft >= 4)
        DoOperationLoop("{1} = 0", ref bytesLeft, ref byteOffset, ref resultCount, 4, "@this");
      
      if (bytesLeft >= 2)
        DoOperationLoop("{1} = 0", ref bytesLeft, ref byteOffset, ref resultCount, 2, "@this");
      
      if (bytesLeft > 0)
        DoOperationLoop("{1} = 0", ref bytesLeft, ref byteOffset, ref resultCount, 1, "@this");

    }
#>
    }

<#
    GenerateThreeOperandBitwiseOperation("And", "&", false, blockSize);
    GenerateThreeOperandBitwiseOperation("Nand", "&", true, blockSize);
    GenerateThreeOperandBitwiseOperation("Or", "|", false, blockSize);
    GenerateThreeOperandBitwiseOperation("Nor", "|", true, blockSize);
    GenerateThreeOperandBitwiseOperation("Xor", "^", false, blockSize);
    GenerateThreeOperandBitwiseOperation("Xnor", "^", true, blockSize);
#>

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void Not(Block<#=blockSize#>* @this, Block<#=blockSize#>* target) =>
#if PLATFORM_X86
      _Notx86(@this, target)
#else
      _Notx64(@this, target)
#endif
      ;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void Not(Block<#=blockSize#>* @this) =>
      Not(@this, @this)
      ;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static unsafe void _Notx64(Block<#=blockSize#>* @this, Block<#=blockSize#>* target) {
<#
    {
      DoFullLoop("var result{0} = {1}", blockSize, 8, "@this");
      DoFullLoop("result{0} = _Not(result{0})", blockSize, 8);
      DoFullLoop("{1} = result{0}", blockSize, 8, "target");
    }
#>
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static unsafe void _Notx86(Block<#=blockSize#>* @this, Block<#=blockSize#>* target) {
<#
    {
      DoFullLoop("var result{0} = {1}", blockSize, 4, "@this");
      DoFullLoop("result{0} = _Not(result{0})", blockSize, 4);
      DoFullLoop("{1} = result{0}", blockSize, 4, "target");
    }
#>
    }

  }
}
}
<#
  if(currentFileName != null)  
    File.WriteAllText(currentFileName, GenerationEnvironment.ToString());  
}
GenerationEnvironment = fileManager;
#>
#region (c)2010-2042 Hawkynt
/*
  This file is part of Hawkynt's .NET Framework extensions.

    Hawkynt's .NET Framework extensions are free software:
    you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Hawkynt's .NET Framework extensions is distributed in the hope that
    it will be useful, but WITHOUT ANY WARRANTY; without even the implied
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
    the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Hawkynt's .NET Framework extensions.
    If not, see <http://www.gnu.org/licenses/>.
*/
#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */

namespace Corlib {

using System.Runtime.CompilerServices;
using MethodImplOptions = Utilities.MethodImplOptions;

// ReSharper disable UnusedMember.Local
internal static partial class MemoryManipulation {

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  private static ulong _Not(ulong operand) => ~operand;


  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  private static uint _Not(uint operand) => ~operand;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  private static ushort _Not(ushort operand) => (ushort)~operand;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  private static byte _Not(byte operand) => (byte)~operand;

<#
  foreach(var size in new[]{1, 2, 4, 8}){
    GenerateTwoOperandArbitraryCountEqual("AreEqual", size);
    GenerateTwoOperandArbitraryCountFill("Fill", size);
    GenerateOneOperandArbitraryCountOperation("Clear", size);
    GenerateThreeOperandArbitraryCountOperation("And", size);
    GenerateThreeOperandArbitraryCountOperation("Nand", size);
    GenerateThreeOperandArbitraryCountOperation("Or", size);
    GenerateThreeOperandArbitraryCountOperation("Nor", size);
    GenerateThreeOperandArbitraryCountOperation("Xor", size);
    GenerateThreeOperandArbitraryCountOperation("Xnor", size);
    GenerateTwoOperandArbitraryCountOperation("Not", size);
  }
#>

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void CopyTo(byte* source, byte* target, int count) =>
#if PLATFORM_X86
      _CopyTox86(source, target, count)
#else
      _CopyTox64(source, target, count)
#endif
      ;

<#
  GenerateCopyToOperation("x64", MAX_SIZE);
  GenerateCopyToOperation("x86", MAX_COPY_SIZE_X86);
#>

}
}
<#+
 const int MAX_SIZE = 64;
 const int MAX_COPY_SIZE_X86 = 16;

int DoFullLoop(string operation, int blockSize, int size, params string[] variableNames) {
  var bytesLeft = blockSize;
  var resultCount = 0;
  var byteOffset = 0;
  
  do {
    DoOperationLoop(operation, ref bytesLeft, ref byteOffset, ref resultCount, size, variableNames);
    size /= 2;
  } while (size > 0);

  return resultCount;
}

void DoOperationLoop(string operation, ref int bytesLeft, ref int byteOffset, ref int resultCount, int size, params string[] variableNames) {
  while (bytesLeft >= size) {
    var args = new List<object>();
    args.Add(resultCount++);
    
    var index = byteOffset / size;
    foreach (var variableName in variableNames)
      args.Add(EmitCastedIndexLookup(variableName, index, GetDataTypeForByteCount(size)));
#>
      <#=string.Format(operation, args.ToArray())#>;
<#+  
    bytesLeft -= size;
    byteOffset += size;
  }
}

void GenerateCopyToOperation(string name, int maxBlockSize) {
#>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  private static unsafe void _CopyTo<#=name#>(byte* source, byte* target, int count) {
    switch (count) {
      case <= 0: break;
<#+for(var blockSize = 1; blockSize <= maxBlockSize; ++blockSize) {#>
      case <#=blockSize#>: *(Block<#=blockSize#>*)target = *(Block<#=blockSize#>*)source; break;
<#+}#>
      default: _CopyTo<#=name#>Many(source, target, count); break;
    }
  }

  private static unsafe void _CopyTo<#=name#>Many(byte* source, byte* target, int count) {
    
    count -= <#=maxBlockSize#>;
    *(Block<#=maxBlockSize#>*)target = *(Block<#=maxBlockSize#>*)source;
    source += <#=maxBlockSize#>;
    target += <#=maxBlockSize#>;
    
    while (count >= <#=maxBlockSize * 8#>) {
      count -= <#=maxBlockSize * 8#>;
      *(Block<#=maxBlockSize#>*)target = *(Block<#=maxBlockSize#>*)source;
      ((Block<#=maxBlockSize#>*)target)[1] = ((Block<#=maxBlockSize#>*)source)[1];
      ((Block<#=maxBlockSize#>*)target)[2] = ((Block<#=maxBlockSize#>*)source)[2];
      ((Block<#=maxBlockSize#>*)target)[3] = ((Block<#=maxBlockSize#>*)source)[3];
      ((Block<#=maxBlockSize#>*)target)[4] = ((Block<#=maxBlockSize#>*)source)[4];
      ((Block<#=maxBlockSize#>*)target)[5] = ((Block<#=maxBlockSize#>*)source)[5];
      ((Block<#=maxBlockSize#>*)target)[6] = ((Block<#=maxBlockSize#>*)source)[6];
      ((Block<#=maxBlockSize#>*)target)[7] = ((Block<#=maxBlockSize#>*)source)[7];
      source += <#=maxBlockSize * 8#>;
      target += <#=maxBlockSize * 8#>;
    }

    while (count > <#=maxBlockSize#>) {
      count -= <#=maxBlockSize#>;
      *(Block<#=maxBlockSize#>*)target = *(Block<#=maxBlockSize#>*)source;
      source += <#=maxBlockSize#>;
      target += <#=maxBlockSize#>;
    }
    
    _CopyTo<#=name#>(source, target, count);

  }

<#+
}

void GenerateThreeOperandBitwiseOperation(string name, string @operator, bool negate, int blockSize) {
#>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void <#=name#>(Block<#=blockSize#>* @this, Block<#=blockSize#>* operand, Block<#=blockSize#>* target) =>
#if PLATFORM_X86
      _<#=name#>x86(@this, operand, target)
#else
      _<#=name#>x64(@this, operand, target)
#endif
      ;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void <#=name#>(Block<#=blockSize#>* @this, Block<#=blockSize#>* operand) =>
      <#=name#>(@this, operand, @this)
      ;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static unsafe void _<#=name#>x64(Block<#=blockSize#>* @this, Block<#=blockSize#>* operand, Block<#=blockSize#>* target) {
<#+
    {
      DoFullLoop("var result{0} = {1}", blockSize, 8, "@this");
      DoFullLoop("result{0} " + @operator + "= {1}", blockSize, 8, "operand");
      if(negate)
        DoFullLoop("result{0} = _Not(result{0})", blockSize, 8);

      DoFullLoop("{1} = result{0}", blockSize, 8, "target");
    }
#>
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static unsafe void _<#=name#>x86(Block<#=blockSize#>* @this, Block<#=blockSize#>* operand, Block<#=blockSize#>* target) {
<#+
    {
      DoFullLoop("var result{0} = {1}", blockSize, 4, "@this");
      DoFullLoop("result{0} " + @operator + "= {1}", blockSize, 4, "operand");
      if(negate)
        DoFullLoop("result{0} = _Not(result{0})", blockSize, 4);

      DoFullLoop("{1} = result{0}", blockSize, 4, "target");
    }
#>
    }
<#+
}

void GenerateOneOperandArbitraryCountOperation(string name, int size) {
  var dataType = GetDataTypeForByteCount(size);
#>

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static unsafe void <#=name#>(<#=dataType#>* @this, int count) {
    switch (count) {
      case <= 0: break;
<#+for(var blockSize = size; blockSize <= MAX_SIZE; blockSize+=size) {#>
      case <#=blockSize / size#>: Block<#=blockSize#>.<#=name#>((Block<#=blockSize#>*)@this); break;
<#+}#>
      default: _<#=name#>Many(@this, count); break;
    }
  }

  private static unsafe void _<#=name#>Many(<#=dataType#>* @this, int count) {
    do {
      Block<#=MAX_SIZE#>.<#=name#>((Block<#=MAX_SIZE#>*)@this);
      count -= <#=MAX_SIZE / size#>;
      @this += <#=MAX_SIZE / size#>;
    } while (count > <#=MAX_SIZE / size#>);
    <#=name#>(@this, count);
  }

<#+
}

void GenerateTwoOperandArbitraryCountEqual(string name, int size) {
  var dataType = GetDataTypeForByteCount(size);
#>

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static unsafe bool <#=name#>(<#=dataType#>* @this, <#=dataType#>* other, int count)
    => count switch {
      <= 0 => true,
<#+for(var blockSize = size; blockSize <= MAX_SIZE; blockSize+=size) {#>
      <#=blockSize / size#> => Block<#=blockSize#>.<#=name#>((Block<#=blockSize#>*)@this, (Block<#=blockSize#>*)other),
<#+}#>
      _ => _<#=name#>Many(@this, other, count)
    };

  private static unsafe bool _<#=name#>Many(<#=dataType#>* @this, <#=dataType#>* other, int count) {
    do {
      if (!Block<#=MAX_SIZE#>.<#=name#>((Block<#=MAX_SIZE#>*)@this, (Block<#=MAX_SIZE#>*)other))
        return false;

      count -= <#=MAX_SIZE / size#>;
      @this += <#=MAX_SIZE / size#>;
      other += <#=MAX_SIZE / size#>;
    } while (count > <#=MAX_SIZE / size#>);
    return <#=name#>(@this, other, count);
  }

<#+
}

void GenerateTwoOperandArbitraryCountFill(string name, int size) {
  var dataType = GetDataTypeForByteCount(size);
#>

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static unsafe void <#=name#>(<#=dataType#>* @this, <#=dataType#> value, int count) {
    switch (count) {
      case <= 0: break;
<#+for(var blockSize = size; blockSize <= MAX_SIZE; blockSize+=size) {#>
      case <#=blockSize / size#>: Block<#=blockSize#>.<#=name#>((Block<#=blockSize#>*)@this, value); break;
<#+}#>
      default: _<#=name#>Many(@this, value, count); break;
    }
  }

  private static unsafe void _<#=name#>Many(<#=dataType#>* @this, <#=dataType#> value, int count) {
    do {
      Block<#=MAX_SIZE#>.<#=name#>((Block<#=MAX_SIZE#>*)@this, value);
      count -= <#=MAX_SIZE / size#>;
      @this += <#=MAX_SIZE / size#>;
    } while (count > <#=MAX_SIZE / size#>);
    <#=name#>(@this, value, count);
  }

<#+
}

void GenerateTwoOperandArbitraryCountOperation(string name, int size) {
  var dataType = GetDataTypeForByteCount(size);
#>

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static unsafe void <#=name#>(<#=dataType#>* @this, int count)
    => <#=name#>(@this, @this, count)
    ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static unsafe void <#=name#>(<#=dataType#>* @this, <#=dataType#>* target, int count) {
    switch (count) {
      case <= 0: break;
<#+for(var blockSize = size; blockSize <= MAX_SIZE; blockSize+=size) {#>
      case <#=blockSize / size#>: Block<#=blockSize#>.<#=name#>((Block<#=blockSize#>*)@this, (Block<#=blockSize#>*)target); break;
<#+}#>
      default: _<#=name#>Many(@this, target, count); break;
    }
  }

  private static unsafe void _<#=name#>Many(<#=dataType#>* @this, <#=dataType#>* target, int count) {
    do {
      Block<#=MAX_SIZE#>.<#=name#>((Block<#=MAX_SIZE#>*)@this, (Block<#=MAX_SIZE#>*)target);
      count -= <#=MAX_SIZE / size#>;
      @this += <#=MAX_SIZE / size#>;
      target += <#=MAX_SIZE / size#>;
    } while (count > <#=MAX_SIZE / size#>);
    <#=name#>(@this, target, count);
  }

<#+
}

void GenerateThreeOperandArbitraryCountOperation(string name, int size) {
  var dataType = GetDataTypeForByteCount(size);
#>

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static unsafe void <#=name#>(<#=dataType#>* @this, <#=dataType#>* operand, int count)
    => <#=name#>(@this, operand, @this, count)
    ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static unsafe void <#=name#>(<#=dataType#>* @this, <#=dataType#>* operand, <#=dataType#>* target, int count) {
    switch (count) {
      case <= 0: break;
<#+for(var blockSize = size; blockSize <= MAX_SIZE; blockSize+=size) {#>
      case <#=blockSize / size#>: Block<#=blockSize#>.<#=name#>((Block<#=blockSize#>*)@this, (Block<#=blockSize#>*)operand, (Block<#=blockSize#>*)target); break;
<#+}#>
      default: _<#=name#>Many(@this, operand, target, count); break;
    }
  }

  private static unsafe void _<#=name#>Many(<#=dataType#>* @this, <#=dataType#>* operand, <#=dataType#>* target, int count) {
    do {
      Block<#=MAX_SIZE#>.<#=name#>((Block<#=MAX_SIZE#>*)@this, (Block<#=MAX_SIZE#>*)operand, (Block<#=MAX_SIZE#>*)target);
      count -= <#=MAX_SIZE / size#>;
      @this += <#=MAX_SIZE / size#>;
      operand += <#=MAX_SIZE / size#>;
      target += <#=MAX_SIZE / size#>;
    } while (count > <#=MAX_SIZE / size#>);
    <#=name#>(@this, operand, target, count);
  }
<#+
}

string GetDataTypeForByteCount(int sizeInBytes) 
  => sizeInBytes switch {
    8 => "ulong",
    4 => "uint",
    2 => "ushort",
    1 => "byte",
    _ => throw new ArgumentException()
  }
  ;

string EmitCastedIndexLookup(string variableName, int index, string typeName)
  => index == 0 ? $"*({typeName}*){variableName}" : $"(({typeName}*){variableName})[{index}]"
  ;
 
#>