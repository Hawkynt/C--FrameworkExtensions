<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
#region (c)2010-2042 Hawkynt
/*
  This file is part of Hawkynt's .NET Framework extensions.

    Hawkynt's .NET Framework extensions are free software:
    you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Hawkynt's .NET Framework extensions is distributed in the hope that
    it will be useful, but WITHOUT ANY WARRANTY; without even the implied
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
    the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Hawkynt's .NET Framework extensions.
    If not, see <http://www.gnu.org/licenses/>.
*/
#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */

using System.Runtime.InteropServices;

#if SUPPORTS_INLINING
using System.Runtime.CompilerServices;
#endif

// ReSharper disable UnusedMember.Local
internal static partial class MemoryManipulation {

<#for(var blockSize = 1; blockSize <= MAX_SIZE; ++blockSize) {#>
  [StructLayout(LayoutKind.Sequential, Size = <#=blockSize#>)] 
  public struct Block<#=blockSize#> {

#if UNSAFE

#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static unsafe bool AreEqual(Block<#=blockSize#>* @this, Block<#=blockSize#>* other) =>
#if PLATFORM_X86
      _AreEqualx32(@this, other)
#else
      _AreEqualx64(@this, other)
#endif
      ;

#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static unsafe bool _AreEqualx64(Block<#=blockSize#>* @this, Block<#=blockSize#>* other) {
<#
    {
      if(blockSize == 1 || blockSize == 2 || blockSize == 4 || blockSize == 8) {
#>
      return *(<#=GetTypeForSize(blockSize)#>*)@this == *(<#=GetTypeForSize(blockSize)#>*) other;
<#
      } else {
      
        DoFullLoop("var result{0} = {1}", blockSize, 8, "@this");
        var resultCount = DoFullLoop("result{0} ^= {1}", blockSize, 8, "other");

        var shift = 1;
        while (shift < resultCount) {
          for (var index = 0; index < resultCount; index += 2 * shift) {
            if (index + shift < resultCount) {
#>
      result<#=index#> |= result<#=(index + shift)#>;
<#
            }
          }
          shift *= 2;
        }
#>
      return result0 == 0;
<#
      }
    }
#>
    }
        
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static unsafe bool _AreEqualx32(Block<#=blockSize#>* @this, Block<#=blockSize#>* other) {
<#
    {
      if(blockSize == 1 || blockSize == 2 || blockSize == 4) {
#>
      return *(<#=GetTypeForSize(blockSize)#>*)@this == *(<#=GetTypeForSize(blockSize)#>*) other;
<#
      } else {

        DoFullLoop("var result{0} = {1}", blockSize, 4, "@this");
        var resultCount = DoFullLoop("result{0} ^= {1}", blockSize, 4, "other");

        var shift = 1;
        while (shift < resultCount) {
          for (var index = 0; index < resultCount; index += 2 * shift) {
            if (index + shift < resultCount) {
#>
      result<#=index#> |= result<#=(index + shift)#>;
<#
            }
          }
          shift *= 2;
        }
#>
      return result0 == 0;
<#
      }
    }
#>
    }

#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static unsafe void Fill(Block<#=blockSize#>* @this, byte value) =>
#if PLATFORM_X86
      _Fillx32(@this, value)
#else
      _Fillx64(@this, value)
#endif
      ;

#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static unsafe void _Fillx64(Block<#=blockSize#>* @this, byte value) {
<#
    {
      var bytesLeft = blockSize;
      var resultCount = 0;
      var byteOffset = 0;
      
      if (bytesLeft >= 8) {
#>
      var qword = 0x0101010101010101UL * value;
<#
        DoOperationLoop("{1} = qword", ref bytesLeft, ref byteOffset, ref resultCount, 8, "@this");
      }

      if (bytesLeft >= 4) {
#>
      var dword = 0x01010101U * value;
<#
        DoOperationLoop("{1} = dword", ref bytesLeft, ref byteOffset, ref resultCount, 4, "@this");
      }

      if (bytesLeft >= 2) {
#>
      var word = (ushort)(0x0101 * value);
<#
        DoOperationLoop("{1} = word", ref bytesLeft, ref byteOffset, ref resultCount, 2, "@this");
      }

      if (bytesLeft > 0)
        DoOperationLoop("{1} = value", ref bytesLeft, ref byteOffset, ref resultCount, 1, "@this");

    }
#>
    }

#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static unsafe void _Fillx32(Block<#=blockSize#>* @this, byte value) {
<#
    {
      var bytesLeft = blockSize;
      var resultCount = 0;
      var byteOffset = 0;
      
      if (bytesLeft >= 4) {
#>
      var dword = 0x01010101U * value;
<#
        DoOperationLoop("{1} = dword", ref bytesLeft, ref byteOffset, ref resultCount, 4, "@this");
      }

      if (bytesLeft >= 2) {
#>
      var word = (ushort)(0x0101 * value);
<#
        DoOperationLoop("{1} = word", ref bytesLeft, ref byteOffset, ref resultCount, 2, "@this");
      }

      if (bytesLeft > 0)
        DoOperationLoop("{1} = value", ref bytesLeft, ref byteOffset, ref resultCount, 1, "@this");

    }
#>
    }
    
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static unsafe void Clear(Block<#=blockSize#>* @this) =>
#if PLATFORM_X86
      _Clearx32(@this)
#else
      _Clearx64(@this)
#endif
      ;

#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static unsafe void _Clearx64(Block<#=blockSize#>* @this) {
<#
    {
      var bytesLeft = blockSize;
      var resultCount = 0;
      var byteOffset = 0;
      
      if (bytesLeft >= 8)
        DoOperationLoop("{1} = 0", ref bytesLeft, ref byteOffset, ref resultCount, 8, "@this");
      
      if (bytesLeft >= 4)
        DoOperationLoop("{1} = 0", ref bytesLeft, ref byteOffset, ref resultCount, 4, "@this");

      if (bytesLeft >= 2)
        DoOperationLoop("{1} = 0", ref bytesLeft, ref byteOffset, ref resultCount, 2, "@this");

      if (bytesLeft > 0)
        DoOperationLoop("{1} = 0", ref bytesLeft, ref byteOffset, ref resultCount, 1, "@this");

    }
#>
    }

#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static unsafe void _Clearx32(Block<#=blockSize#>* @this) {
<#
    {
      var bytesLeft = blockSize;
      var resultCount = 0;
      var byteOffset = 0;
      
      if (bytesLeft >= 4)
        DoOperationLoop("{1} = 0", ref bytesLeft, ref byteOffset, ref resultCount, 4, "@this");
      
      if (bytesLeft >= 2)
        DoOperationLoop("{1} = 0", ref bytesLeft, ref byteOffset, ref resultCount, 2, "@this");
      
      if (bytesLeft > 0)
        DoOperationLoop("{1} = 0", ref bytesLeft, ref byteOffset, ref resultCount, 1, "@this");

    }
#>
    }

<#
    GenerateThreeOperandBitwiseOperation("And", "&", false, blockSize);
    GenerateThreeOperandBitwiseOperation("Nand", "&", true, blockSize);
    GenerateThreeOperandBitwiseOperation("Or", "|", false, blockSize);
    GenerateThreeOperandBitwiseOperation("Nor", "|", true, blockSize);
    GenerateThreeOperandBitwiseOperation("Xor", "^", false, blockSize);
    GenerateThreeOperandBitwiseOperation("Xnor", "^", true, blockSize);
#>

#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static unsafe void Not(Block<#=blockSize#>* @this, Block<#=blockSize#>* target) =>
#if PLATFORM_X86
      _Notx32(@this, target)
#else
      _Notx64(@this, target)
#endif
      ;

#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static unsafe void Not(Block<#=blockSize#>* @this) =>
      Not(@this, @this)
      ;

#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static unsafe void _Notx64(Block<#=blockSize#>* @this, Block<#=blockSize#>* target) {
<#
    {
      DoFullLoop("var result{0} = {1}", blockSize, 8, "@this");
      DoFullLoop("result{0} = _Not(result{0})", blockSize, 8);
      DoFullLoop("{1} = result{0}", blockSize, 8, "target");
    }
#>
    }

#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static unsafe void _Notx86(Block<#=blockSize#>* @this, Block<#=blockSize#>* target) {
<#
    {
      DoFullLoop("var result{0} = {1}", blockSize, 4, "@this");
      DoFullLoop("result{0} = _Not(result{0})", blockSize, 4);
      DoFullLoop("{1} = result{0}", blockSize, 4, "target");
    }
#>
    }
    
#endif

  }

<#}#>

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  private static ulong _Not(ulong operand) => ~operand;


#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  private static uint _Not(uint operand) => ~operand;

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  private static ushort _Not(ushort operand) => (ushort)~operand;

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  private static byte _Not(byte operand) => (byte)~operand;

#if UNSAFE

<#
  GenerateTwoOperandArbitraryCountEqual("AreEqual");
  GenerateTwoOperandArbitraryCountFill("Fill");
  GenerateOneOperandArbitraryCountOperation("Clear");
  GenerateThreeOperandArbitraryCountOperation("And");
  GenerateThreeOperandArbitraryCountOperation("Nand");
  GenerateThreeOperandArbitraryCountOperation("Or");
  GenerateThreeOperandArbitraryCountOperation("Nor");
  GenerateThreeOperandArbitraryCountOperation("Xor");
  GenerateThreeOperandArbitraryCountOperation("Xnor");
  GenerateTwoOperandArbitraryCountOperation("Not");
#>

#endif

}

<#+
 const int MAX_SIZE = 64;

int DoFullLoop(string operation, int blockSize, int size, params string[] variableNames) {
  var bytesLeft = blockSize;
  var resultCount = 0;
  var byteOffset = 0;
  
  do {
    DoOperationLoop(operation, ref bytesLeft, ref byteOffset, ref resultCount, size, variableNames);
    size /= 2;
  } while (size > 0);

  return resultCount;
}

void DoOperationLoop(string operation, ref int bytesLeft, ref int byteOffset, ref int resultCount, int size, params string[] variableNames) {
  while (bytesLeft >= size) {
    var args = new List<object>();
    args.Add(resultCount++);
    
    var index = byteOffset / size;
    foreach (var variableName in variableNames)
      args.Add(DoCastedIndexLookup(variableName, index, GetTypeForSize(size)));
#>
      <#=string.Format(operation, args.ToArray())#>;
<#+  
    bytesLeft -= size;
    byteOffset += size;
  }
}

void GenerateThreeOperandBitwiseOperation(string name, string @operator, bool negate, int blockSize) {
#>
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static unsafe void <#=name#>(Block<#=blockSize#>* @this, Block<#=blockSize#>* operand, Block<#=blockSize#>* target) =>
#if PLATFORM_X86
      _<#=name#>x32(@this, operand, target)
#else
      _<#=name#>x64(@this, operand, target)
#endif
      ;

#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static unsafe void <#=name#>(Block<#=blockSize#>* @this, Block<#=blockSize#>* operand) =>
      <#=name#>(@this, operand, @this)
      ;

#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static unsafe void _<#=name#>x64(Block<#=blockSize#>* @this, Block<#=blockSize#>* operand, Block<#=blockSize#>* target) {
<#+
    {
      DoFullLoop("var result{0} = {1}", blockSize, 8, "@this");
      DoFullLoop("result{0} " + @operator + "= {1}", blockSize, 8, "operand");
      if(negate)
        DoFullLoop("result{0} = _Not(result{0})", blockSize, 8);

      DoFullLoop("{1} = result{0}", blockSize, 8, "target");
    }
#>
    }

#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static unsafe void _<#=name#>x86(Block<#=blockSize#>* @this, Block<#=blockSize#>* operand, Block<#=blockSize#>* target) {
<#+
    {
      DoFullLoop("var result{0} = {1}", blockSize, 4, "@this");
      DoFullLoop("result{0} " + @operator + "= {1}", blockSize, 4, "operand");
      if(negate)
        DoFullLoop("result{0} = _Not(result{0})", blockSize, 4);

      DoFullLoop("{1} = result{0}", blockSize, 4, "target");
    }
#>
    }
<#+
}

void GenerateOneOperandArbitraryCountOperation(string name) {
#>

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static unsafe void <#=name#>(byte* @this, int count) {
    switch (count) {
      case <= 0: break;
<#+for(var blockSize = 1; blockSize <= MAX_SIZE; ++blockSize) {#>
      case <#=blockSize#>: Block<#=blockSize#>.<#=name#>((Block<#=blockSize#>*)@this); break;
<#+}#>
      default: _<#=name#>(@this, count); break;
    }
  }

  private static unsafe void _<#=name#>(byte* @this, int count) {
    do {
      count -= <#=MAX_SIZE#>;
      Block<#=MAX_SIZE#>.<#=name#>((Block<#=MAX_SIZE#>*)@this);
      @this += <#=MAX_SIZE#>;
    } while (count > <#=MAX_SIZE#>);
    <#=name#>(@this, count);
  }

<#+
}

void GenerateTwoOperandArbitraryCountEqual(string name) {
#>

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static unsafe bool <#=name#>(byte* @this, byte* other, int count) {
    switch (count) {
      case <= 0: return true;
<#+for(var blockSize = 1; blockSize <= MAX_SIZE; ++blockSize) {#>
      case <#=blockSize#>: return Block<#=blockSize#>.<#=name#>((Block<#=blockSize#>*)@this, (Block<#=blockSize#>*)other);
<#+}#>
      default: return _<#=name#>(@this, other, count);
    }
  }

  private static unsafe bool _<#=name#>(byte* @this, byte* other, int count) {
    do {
      count -= <#=MAX_SIZE#>;
      if (!Block<#=MAX_SIZE#>.<#=name#>((Block<#=MAX_SIZE#>*)@this, (Block<#=MAX_SIZE#>*)other))
        return false;

      @this += <#=MAX_SIZE#>;
      other += <#=MAX_SIZE#>;
    } while (count > <#=MAX_SIZE#>);
    return <#=name#>(@this, other, count);
  }

<#+
}

void GenerateTwoOperandArbitraryCountFill(string name) {
#>

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static unsafe void <#=name#>(byte* @this, byte value, int count) {
    switch (count) {
      case <= 0: break;
<#+for(var blockSize = 1; blockSize <= MAX_SIZE; ++blockSize) {#>
      case <#=blockSize#>: Block<#=blockSize#>.<#=name#>((Block<#=blockSize#>*)@this, value); break;
<#+}#>
      default: _<#=name#>(@this, value, count); break;
    }
  }

  private static unsafe void _<#=name#>(byte* @this, byte value, int count) {
    do {
      count -= <#=MAX_SIZE#>;
      Block<#=MAX_SIZE#>.<#=name#>((Block<#=MAX_SIZE#>*)@this, value);
      @this += <#=MAX_SIZE#>;
    } while (count > <#=MAX_SIZE#>);
    <#=name#>(@this, value, count);
  }

<#+
}

void GenerateTwoOperandArbitraryCountOperation(string name) {
#>

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static unsafe void <#=name#>(byte* @this, int count)
    => <#=name#>(@this, @this, count)
    ;

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static unsafe void <#=name#>(byte* @this, byte* target, int count) {
    switch (count) {
      case <= 0: break;
<#+for(var blockSize = 1; blockSize <= MAX_SIZE; ++blockSize) {#>
      case <#=blockSize#>: Block<#=blockSize#>.<#=name#>((Block<#=blockSize#>*)@this, (Block<#=blockSize#>*)target); break;
<#+}#>
      default: _<#=name#>(@this, target, count); break;
    }
  }

  private static unsafe void _<#=name#>(byte* @this, byte* target, int count) {
    do {
      count -= <#=MAX_SIZE#>;
      Block<#=MAX_SIZE#>.<#=name#>((Block<#=MAX_SIZE#>*)@this, (Block<#=MAX_SIZE#>*)target);
      @this += <#=MAX_SIZE#>;
      target += <#=MAX_SIZE#>;
    } while (count > <#=MAX_SIZE#>);
    <#=name#>(@this, target, count);
  }

<#+
}

void GenerateThreeOperandArbitraryCountOperation(string name) {
#>

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static unsafe void <#=name#>(byte* @this, byte* operand, int count)
    => <#=name#>(@this, operand, @this, count)
    ;

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static unsafe void <#=name#>(byte* @this, byte* operand, byte* target, int count) {
    switch (count) {
      case <= 0: break;
<#+for(var blockSize = 1; blockSize <= MAX_SIZE; ++blockSize) {#>
      case <#=blockSize#>: Block<#=blockSize#>.<#=name#>((Block<#=blockSize#>*)@this, (Block<#=blockSize#>*)operand, (Block<#=blockSize#>*)target); break;
<#+}#>
      default: _<#=name#>(@this, operand, target, count); break;
    }
  }

  private static unsafe void _<#=name#>(byte* @this, byte* operand, byte* target, int count) {
    do {
      count -= <#=MAX_SIZE#>;
      Block<#=MAX_SIZE#>.<#=name#>((Block<#=MAX_SIZE#>*)@this, (Block<#=MAX_SIZE#>*)operand, (Block<#=MAX_SIZE#>*)target);
      @this += <#=MAX_SIZE#>;
      operand += <#=MAX_SIZE#>;
      target += <#=MAX_SIZE#>;
    } while (count > <#=MAX_SIZE#>);
    <#=name#>(@this, operand, target, count);
  }
<#+
}

string GetTypeForSize(int size) 
  => size switch {
    8 => "ulong",
    4 => "uint",
    2 => "ushort",
    1 => "byte",
    _ => throw new ArgumentException()
  }
  ;

string DoCastedIndexLookup(string variableName, int index, string typeName)
  => index == 0 ? $"*({typeName}*){variableName}" : $"(({typeName}*){variableName})[{index}]"
  ;
 
#>