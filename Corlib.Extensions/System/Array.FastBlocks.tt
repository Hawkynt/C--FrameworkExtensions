<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
#region (c)2010-2042 Hawkynt
/*
  This file is part of Hawkynt's .NET Framework extensions.

    Hawkynt's .NET Framework extensions are free software:
    you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Hawkynt's .NET Framework extensions is distributed in the hope that
    it will be useful, but WITHOUT ANY WARRANTY; without even the implied
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
    the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Hawkynt's .NET Framework extensions.
    If not, see <http://www.gnu.org/licenses/>.
*/
#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */
<#
  const int LINEAR_BLOCK_COUNTX86   = 16;              // x86 can only copy 16-byte blocks without emitting loop constructs (rep movsb)
  const int LINEAR_BLOCK_COUNTX64   = 64;              // x64 uses vmovdqu for blocks up to 64-bytes
  const int MARSHALL_SWITCH_COUNT   = 8;               // how many bytes we'll quickly process using a switch statement (must >= 7)
  const int MARSHALL_LOOP_UNROLL    = 0;               // doesn't give speedup when using Marshal.* because the calls are damn slow anyway
  const int UNSAFE_SWITCH_COUNT     = 8;               // what number of bytes to unroll unsafe
  const int INDEX_LOOP_UNROLL       = 8;               // ldc.i4 8 is the highest opcode available for index operations
  const int BYTE_COUNT_POINTER      = 1 * 1024 * 1024; // we'll use pointer pinning and block-copies when this many bytes need to be copied
  const int ELEMENT_COUNT_BLOCK     = 256;             // we'll use Array.Copy or Buffer.BlockCopy when more than this many elements are present
  const int UNSAFE_NOT_SWITCH_COUNT = 16;              // what number of bytes to unroll in unsafe not
  const int UNSAFE_AND_SWITCH_COUNT = 16;              // what number of bytes to unroll in unsafe and/xor/or
    
  var typeDatas = new List<TypeData>();
  typeDatas.Add(new TypeData{ name = "sbyte"  , size = 1, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "byte"   , size = 1, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "short"  , size = 2, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "ushort" , size = 2, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "int"    , size = 4, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "uint"   , size = 4, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "long"   , size = 8, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "ulong"  , size = 8, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "float"  , size = 4, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "double" , size = 8, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "char"   , size = 2, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "string"});
  typeDatas.Add(new TypeData{ name = "decimal", size = 16});
  typeDatas.Add(new TypeData{ name = "bool"   , size = 1});
  typeDatas.Add(new TypeData{ name = "IntPtr" , hasHandcraftedCopyToMethod = true, noArraySupport = true});
  typeDatas.Add(new TypeData{ name = "byte*"  , hasHandcraftedCopyToMethod = true, noArraySupport = true, isUnsafeOnly = true});
#>

using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

using Block1 = System.Byte;
using Block2 = System.UInt16;
using Block4 = System.UInt32;
using Block8 = System.UInt64;
using SBlock2 = System.Int16;
using SBlock4 = System.Int32;
using SBlock8 = System.Int64;

// ReSharper disable UnusedMemberInSuper.Global
// ReSharper disable UnusedAutoPropertyAccessor.Global
// ReSharper disable PartialTypeWithSinglePart
// ReSharper disable UnusedMember.Global
// ReSharper disable MemberCanBePrivate.Global
namespace System {

#if COMPILE_TO_EXTENSION_DLL
  public
#else
  internal
#endif
  static partial class ArrayExtensions {
    
    #region nested types

#if PLATFORM_X86
<#  for(var i = 3;i <= LINEAR_BLOCK_COUNTX86; ++i) {#>
<#    if(i == 1 || i == 2 || i == 4 || i == 8 || i == 32 || i == 64) continue;#>
    [StructLayout(LayoutKind.Sequential, Size=<#=i#>)] private struct Block<#=i#>{ }
<#  }#>
#else
<#  for(var i = 3;i <= LINEAR_BLOCK_COUNTX64; ++i) {#>
<#    if(i == 1 || i == 2 || i == 4 || i == 8 || i == 32 || i == 64) continue;#>
    [StructLayout(LayoutKind.Sequential, Size=<#=i#>)] private struct Block<#=i#>{ }
<#  }#>
#endif

    #endregion

    // TODO: Clear for byte[], ushort[], short[], uint[], int[], ulong[], long[], float[], double[]
    // TODO: Fill for byte[], ushort[], short[], uint[], int[], ulong[], long[], float[], double[]
    // TODO: SequenceEquals for byte[], IntPtr, byte*, ushort[], short[], uint[], int[], ulong[], long[], float[], double[]
    // TODO: unchecked versions

    #region Copy
<#  foreach(var typeData in typeDatas) {#>
<#    var typeName = typeData.name;#>
    #region Type: <#=typeName#>
<#    if(typeData.isUnsafeOnly) {#>
#if UNSAFE
<#    }#>
<#    if(!typeData.noArraySupport) {#>

    <#=string.Join("\n    ", EmitMethodHeader2("Copy", typeData))#>) {
      if (@this == null)
        return null;

      var length = @this.Length;
      var result = new <#=typeName#>[length];
      _CopyTo(@this, 0, result, 0, length);
      return result;
    }

    <#=string.Join("\n    ", EmitMethodHeader2("Copy", typeData))#>, int index) {
      if (@this == null)
        return null;

      <#=EmitOffsetTooSmallCheck()#>
      var length = @this.Length;
      <#=EmitOffsetTooLargeCheck()#>
      var count = length - index;
      var result = new <#=typeName#>[count];
      _CopyTo(@this, index, result, 0, count);
      return result;
    }

    <#=string.Join("\n    ", EmitMethodHeader2("Copy", typeData))#>, int index, int count) {
      if (@this == null)
        return null;

      <#=EmitOffsetTooSmallCheck()#>
      var length = @this.Length;
      <#=EmitOffsetTooLargeCheck()#>
      <#=EmitCountTooSmallCheck()#>
      <#=EmitCountTooLargeCheck("length - index")#>

      var result = new <#=typeName#>[count];
      _CopyTo(@this, index, result, 0, count);
      return result;
    }
<#    }#>

<#    if(!typeData.NeedsCount) {#>
    <#=string.Join("\n    ", EmitMethodHeader2("void", "CopyTo", typeData))#>, <#=EmitTypeDef(typeData)#> target) {
<#      if(typeData.CanBeNull)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#      }#>
      var count = @this.Length;
      <#=EmitCountTooLargeCheck("count", "target.Length", "target")#>
      _CopyTo(@this, 0 , target, 0, count);
    }

    <#=string.Join("\n    ", EmitMethodHeader2("void", "CopyTo", typeData))#>, int srcIndex, <#=EmitTypeDef(typeData)#> target) {
<#      if(typeData.CanBeNull)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#      }#>
      <#=EmitOffsetTooSmallCheck("srcIndex")#>
      var length = @this.Length;
      <#=EmitOffsetTooLargeCheck("srcIndex", "length")#>
      var count = length - srcIndex;
      <#=EmitCountTooLargeCheck("count", "target.Length", "target")#>
      _CopyTo(@this, srcIndex , target, 0, count);
    }

    <#=string.Join("\n    ", EmitMethodHeader2("void", "CopyTo", typeData))#>, <#=EmitTypeDef(typeData)#> target, int tgtIndex) {
<#      if(typeData.CanBeNull)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#      }#>
      <#=EmitOffsetTooSmallCheck("tgtIndex")#>
      var length = target.Length;
      <#=EmitOffsetTooLargeCheck("tgtIndex", "length")#>
      var count = @this.Length;
      <#=EmitCountTooLargeCheck("count", "target.Length - tgtIndex", "@this")#>
      _CopyTo(@this, 0 , target, tgtIndex, count);
    }
<#    } else {#>
    <#=string.Join("\n    ", EmitMethodHeader2("void", "CopyTo", typeData))#>, int count, <#=EmitTypeDef(typeData)#> target) {
<#      if(typeData.CanBeNull)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#      }#>
      <#=EmitCountTooSmallCheck()#>
      _CopyTo(@this, 0 , target, 0, count);
    }

    <#=string.Join("\n    ", EmitMethodHeader2("void", "CopyTo", typeData))#>, int count, int srcIndex, <#=EmitTypeDef(typeData)#> target) {
<#      if(typeData.CanBeNull)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#      }#>
      <#=EmitOffsetTooSmallCheck("srcIndex")#>
      <#=EmitCountTooSmallCheck()#>
      _CopyTo(@this, srcIndex , target, 0, count);
    }

    <#=string.Join("\n    ", EmitMethodHeader2("void", "CopyTo", typeData))#>, int count, <#=EmitTypeDef(typeData)#> target, int tgtIndex) {
<#      if(typeData.CanBeNull)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#      }#>
      <#=EmitOffsetTooSmallCheck("tgtIndex")#>
      <#=EmitCountTooSmallCheck()#>
      _CopyTo(@this, 0 , target, tgtIndex, count);
    }
<#    }#>

    <#=string.Join("\n    ", EmitMethodHeader2("void", "CopyTo", typeData))#>, int srcIndex, <#=EmitTypeDef(typeData)#> target, int tgtIndex, int count) {
<#    if(typeData.CanBeNull)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#    }#>
      <#=EmitOffsetTooSmallCheck("srcIndex")#>
      <#=EmitOffsetTooSmallCheck("tgtIndex")#>
      <#=EmitCountTooSmallCheck()#>
<#    if(typeData.SupportsLength) {#>
      <#=EmitOffsetTooLargeCheck("srcIndex", "@this.Length")#>
      <#=EmitOffsetTooLargeCheck("tgtIndex", "target.Length")#>
      <#=EmitCountTooLargeCheck("count", "@this.Length - srcIndex")#>
      <#=EmitCountTooLargeCheck("count", "target.Length - tgtIndex")#>
<#    }#>
      _CopyTo(@this, srcIndex , target, tgtIndex, count);
    }
<#    if(typeData.allowByteConversion){#>
<#      foreach(var tgtTypeData in typeDatas.Where(i=>i.name != typeName && i.allowByteConversion)){#>

    <#=string.Join("\n    ", EmitMethodHeader2("void", "CopyTo", typeData))#>, int srcIndex, <#=EmitTypeDef(tgtTypeData)#> target, int tgtIndex, int count) {
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
      <#=EmitOffsetTooSmallCheck("srcIndex")#>
      <#=EmitOffsetTooSmallCheck("tgtIndex")#>
      <#=EmitOffsetTooLargeCheck("srcIndex", "@this.Length")#>
      <#=EmitOffsetTooLargeCheck("tgtIndex", "target.Length")#>
      <#=EmitCountTooLargeCheck("count", "@this.Length - srcIndex")#>
<#        if(tgtTypeData.size != typeData.size) {#>
      var bytesNeeded = count<#=EmitFastIntegerMultiply(typeData.size)#>;
      var bytesAvailable = (target.Length - tgtIndex)<#=EmitFastIntegerMultiply(tgtTypeData.size)#>;
      <#=EmitCountTooLargeCheck("bytesNeeded", "bytesAvailable", "count")#>
      if ((bytesNeeded<#=EmitFastIntegerModulo(tgtTypeData.size)#>) != 0) Guard.AlwaysThrow.CountNotMultipleOfException(nameof(target), count<#=EmitFastIntegerMultiply(typeData.size / tgtTypeData.size)#>, target.Length - tgtIndex);
<#        } else {#>
      <#=EmitCountTooLargeCheck("count", "target.Length - tgtIndex", "count")#>
<#        }#>
      _CopyTo(@this, srcIndex, target, tgtIndex, count);
    }
<#      }#>
<#    }#>
<#    if(typeData.isUnsafeOnly) {#>

#endif
<#    }#>
    #endregion
<#  }#>
<#  foreach(var typeData in typeDatas.Where(i=>!i.hasHandcraftedCopyToMethod)) {#>
<#    var typeName = typeData.name;#>
    
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static void _CopyTo(<#=EmitTypeDef(typeData)#> source, int srcIndex,<#=EmitTypeDef(typeData)#> target, int tgtIndex, int count){
      for (;;) {
        switch(count){
          case 0: return;
<#      for(var i = 1; i < INDEX_LOOP_UNROLL; ++i) {#>
          case <#=i#>:
<#          for(var j = 0; j < i; ++j) {#>
            <#=EmitIndexCopy(j)#><#}#>
            return;
<#      }#>
        }

<#      if(BYTE_COUNT_POINTER > 0 && typeData.size > 0 && typeData.useBlockCopyInsteadOfArrayCopy) {#>
        if( count > <#=(BYTE_COUNT_POINTER / typeData.size)#>) {
#if UNSAFE
          unsafe {
            fixed(<#=typeData.name#>* sourceFixedPointer = &source[srcIndex])
            fixed(<#=typeData.name#>* targetFixedPointer = &target[tgtIndex])
              _CopyTo(<#=(typeData.name == "byte" ? string.Empty : "(byte*)")#>sourceFixedPointer, <#=(typeData.name == "byte" ? string.Empty : "(byte*)")#>targetFixedPointer, count<#=EmitFastIntegerMultiply(typeData.size)#>);
          }
#else
          using (var sourceFixedPointer = DisposableGCHandle.Pin(source))
          using (var targetFixedPointer = DisposableGCHandle.Pin(target))
            _CopyTo(sourceFixedPointer.AddrOfPinnedObject(), srcIndex<#=EmitFastIntegerMultiply(typeData.size)#>, targetFixedPointer.AddrOfPinnedObject(), tgtIndex<#=EmitFastIntegerMultiply(typeData.size)#>, count<#=EmitFastIntegerMultiply(typeData.size)#>);
#endif

          return;
        }

<#      }#>
<#      if(ELEMENT_COUNT_BLOCK > 0) {#>
        if(count > <#=ELEMENT_COUNT_BLOCK#>) {
          <#=(typeData.useBlockCopyInsteadOfArrayCopy ? "Buffer.BlockCopy" : "Array.Copy")#>(source, srcIndex<#=(typeData.useBlockCopyInsteadOfArrayCopy ? EmitFastIntegerMultiply(typeData.size) : string.Empty)#>, target, tgtIndex<#=(typeData.useBlockCopyInsteadOfArrayCopy ? EmitFastIntegerMultiply(typeData.size) : string.Empty)#>, count<#=(typeData.useBlockCopyInsteadOfArrayCopy ? EmitFastIntegerMultiply(typeData.size) : string.Empty)#>);
          return;
        }

<#      }#>
        while(count >= <#=INDEX_LOOP_UNROLL#>) {
<#      for(var i = 0; i < INDEX_LOOP_UNROLL; ++i) {#>
          <#=EmitIndexCopy(i)#><#}#>
          
          srcIndex += <#=INDEX_LOOP_UNROLL#>;
          tgtIndex += <#=INDEX_LOOP_UNROLL#>;
          count -= <#=INDEX_LOOP_UNROLL#>;
        }

      }
    }
<#    if(typeData.allowByteConversion){#>
<#      foreach(var tgtTypeData in typeDatas.Where(i=>i.name != typeName && i.allowByteConversion)){#>

#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static void _CopyTo(<#=EmitTypeDef(typeData)#> source, int srcIndex, <#=EmitTypeDef(tgtTypeData)#> target, int tgtIndex, int count)
      => Buffer.BlockCopy(source, srcIndex<#=EmitFastIntegerMultiply(typeData.size)#>, target, tgtIndex<#=EmitFastIntegerMultiply(tgtTypeData.size)#>, count<#=EmitFastIntegerMultiply(typeData.size)#>)
    ;
<#      }#>
<#    }#>
<#  }#>

#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static void _CopyTo(IntPtr source, int srcIndex, IntPtr target, int tgtIndex, int count) {
#if UNSAFE
      unsafe { _CopyTo(&((byte*)source)[srcIndex], &((byte*)target)[tgtIndex], count); }
#else
      for (;;) {
        switch(count) {
          case 0: return;
<#        for(var i = 1; i <= MARSHALL_SWITCH_COUNT; ++i) {#>
          case <#=i#>:
            <#=string.Join("\n            ",EmitMarshalCopyBytes(i))#>
            return;
<#        }#>
        }

<#  if(MARSHALL_LOOP_UNROLL>1){#>

        <#=string.Join("\n        ",EmitMarshalCopyBytes(MARSHALL_SWITCH_COUNT))#>
        count -= <#=MARSHALL_SWITCH_COUNT#>;
        srcIndex += <#=MARSHALL_SWITCH_COUNT#>;
        tgtIndex += <#=MARSHALL_SWITCH_COUNT#>;
    
        var qwordCount = count<#=EmitFastIntegerDivide(8)#>;
        count = count<#=EmitFastIntegerModulo(8)#>;

        while (qwordCount > 0) {
          switch (qwordCount) {
<#          for(var i = 1; i <= MARSHALL_LOOP_UNROLL; ++i) {#>
            case <#=i#>: goto qwordDuff<#=(MARSHALL_LOOP_UNROLL - i)#>;<#}#>
            default: goto qwordDuffOut;
          }

<#      for(var i = 0; i < MARSHALL_LOOP_UNROLL; ++i) {#>
qwordDuff<#=i#>: <#=EmitMarshalCopyQWord((MARSHALL_LOOP_UNROLL - i - 1) * 8)#><#}#>

          var processed = qwordCount<#=EmitFastIntegerMultiply(8)#>;
          srcIndex += processed;
          tgtIndex += processed;
          break;

qwordDuffOut:

          do {
            <#=string.Join("\n            ",EmitMarshalCopyBytes(MARSHALL_LOOP_UNROLL * 8))#>
            srcIndex += <#=(MARSHALL_LOOP_UNROLL * 8)#>;
            tgtIndex += <#=(MARSHALL_LOOP_UNROLL * 8)#>;
            qwordCount -= <#=MARSHALL_LOOP_UNROLL#>;
          } while (qwordCount >= <#=MARSHALL_LOOP_UNROLL#>);

        }
<#  } else {#>
        var qwordCount = count<#=EmitFastIntegerDivide(8)#>;
        count = count<#=EmitFastIntegerModulo(8)#>;
        do {
          <#=string.Join("\n          ",EmitMarshalCopyBytes(8))#>
          srcIndex += 8;
          tgtIndex += 8;
          --qwordCount;
        } while (qwordCount > 0);
<#  }#>
      }
#endif
    }

    #endregion

    #region Fill

#if UNSAFE

#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static unsafe void Fill(this IntPtr @this, int count, byte value)
      => Fill((byte*)@this, count, value)
    ;

    public static unsafe void Fill(byte* @this, int count, byte value) {
      <#=EmitCountTooSmallCheck()#>

      for(;;)
        switch (count) {
          case 0: return;
<#    for(var i = 1; i <= UNSAFE_SWITCH_COUNT; ++i) {#>
          case <#=i#>:
            <#=string.Join("\n            ",EmitSetBytes(i, "value"))#>
            return;
<#    }#>
          default: {
            var blocks = count >> 3;
            var block8 = 0x0101010101010101UL * value;

#if !PLATFORM_X86
            const int MAX_MANAGED_BLOCKS = 16;
#else
            const int MAX_MANAGED_BLOCKS = 50;
#endif
            if (blocks < MAX_MANAGED_BLOCKS) {
              count &= 0b111;
              for (;;)
                switch (blocks) {
<#    for(var i = 0; i <= INDEX_LOOP_UNROLL; ++i) {#>
                  case <#=i#>: goto blockCount<#=i#>;
<#    }#>
                  default: {
                    do {
                      *(ulong*) @this = block8;
<#    for(var i = 1; i < INDEX_LOOP_UNROLL; ++i) {#>
                      ((ulong*) @this)[<#=i#>] = block8;
<#    }#>
                      @this += <#=(INDEX_LOOP_UNROLL * 8)#>;
                      blocks -= <#=INDEX_LOOP_UNROLL#>;
                    } while (blocks >= <#=INDEX_LOOP_UNROLL#>);

                    continue; // next blocks
                  }
                }

<#    for(var i = INDEX_LOOP_UNROLL; i > 0; --i) {#>
              blockCount<#=i#>: *(ulong*) @this = block8;
<#    }#>
              @this += blocks << 3;
              blockCount0:
              continue; // copy single bytes left
            } // medium-sized blocks

            // large blocks
            var start = @this;

            *(ulong*)@this = block8;
<#    for(var i = 1; i < INDEX_LOOP_UNROLL; ++i) {#>
            ((ulong*)@this)[<#=i#>] = block8;
<#    }#>
            @this += <#=(INDEX_LOOP_UNROLL * 8)#>;
            count -=<#=(INDEX_LOOP_UNROLL * 8)#>;

#if !PLATFORM_X86

            var block64 = *(Block64*)start;
<#    var lastBlockCount = int.MaxValue;#>
<#    foreach(var blockCount in new[]{16, 8, 1}){#>
<#      var bytesPerLoop = 64 * blockCount;#>
<#      var canHaveMoreThanOneIteration = blockCount < (lastBlockCount / 2);#>
            <#=(canHaveMoreThanOneIteration ? "while" : "if")#> (count >= <#=bytesPerLoop#>) {
<#      lastBlockCount = blockCount;#>
              count -= <#=bytesPerLoop#>;
              *(Block64*)@this = block64;
<#      for(var i = 1; i < blockCount; ++i) {#>
              ((Block64*)@this)[<#=i#>] = block64;
<#      }#>
              @this += <#=bytesPerLoop#>;
            }
<#    }#>
            
            if (count != 0)
              continue;

#else

            block8 = *(Block8*)start;
<#    lastBlockCount = int.MaxValue;#>
<#    foreach(var blockCount in new[]{8, 1}){#>
<#      var bytesPerLoop = 8 * blockCount;#>
<#      var canHaveMoreThanOneIteration = blockCount < (lastBlockCount / 2);#>
            <#=(canHaveMoreThanOneIteration ? "while" : "if")#> (count >= <#=bytesPerLoop#>) {
<#      lastBlockCount = blockCount;#>
              count -= <#=bytesPerLoop#>;
              *(Block8*)@this = block8;
<#      for(var i = 1; i < blockCount; ++i) {#>
              ((Block8*)@this)[<#=i#>] = block8;
<#      }#>
              @this += <#=bytesPerLoop#>;
            }
<#    }#>
            
            if (count != 0)
              continue;
            
#endif

            return;

            } // single-byte default
        } // single-byte switch
    }

#else

    public static void Fill(this IntPtr @this, int count, byte value) {
      <#=EmitCountTooSmallCheck()#>
      
      for (;;)
        switch (count) {
          case 0: return;
<#    for(var i = 1; i <= MARSHALL_SWITCH_COUNT; ++i) {#>
          case <#=i#>: 
            <#=string.Join("\n            ", EmitMarshalSetBytes(i, "value"))#>
            return;
<#    }#>
          default: {
            var block8 = (long) (0x0101010101010101UL * value);
            var blocks = count >> 3;
            
            count &= 0b111;
            for (;;)
              switch (blocks) {
<#    for(var i = 0; i <= MARSHALL_SWITCH_COUNT; ++i) {#>
                case <#=i#>: goto blockCount<#=i#>;
<#    }#>
                default: {
                  var block64=(object)new Block64((ulong)block8);

                  do {
                    Marshal.StructureToPtr(block64, @this, false);
#if SUPPORTS_POINTER_ARITHMETIC
                    @this += 64;
#else
                    _Add(ref @this, 64);
#endif
                    blocks -= 8;
                  } while (blocks >= 8);

                  continue; // next blocks
                }
              }
              
<#    for(var i = MARSHALL_SWITCH_COUNT; i > 1; --i) {#>
            blockCount<#=i#>: Marshal.WriteInt64(@this, <#=((i - 1) * 8)#>, block8);
<#    }#>
            blockCount1: Marshal.WriteInt64(@this, block8);
#if SUPPORTS_POINTER_ARITHMETIC
            @this += blocks << 3;
#else
            _Add(ref @this, blocks << 3);
#endif
            blockCount0: continue; // copy single bytes left

          } // single-byte default
        } // single-byte switch
    }

#endif

    #endregion

    #region Clear

#if UNSAFE

#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static unsafe void Clear(this IntPtr @this, int count)
      => Clear((byte*)@this, count)
    ;

    public static unsafe void Clear(byte* @this, int count) {
      <#=EmitCountTooSmallCheck()#>

      for(;;)
        switch (count) {
          case 0: return;
<#    for(var i = 1; i <= UNSAFE_SWITCH_COUNT; ++i) {#>
          case <#=i#>:
            <#=string.Join("\n            ",EmitSetBytes(i))#>
            return;
<#    }#>
          default: {
            var blocks = count >> 3;

#if !PLATFORM_X86
            const int MAX_MANAGED_BLOCKS = 16;
#else
            const int MAX_MANAGED_BLOCKS = 50;
#endif
            if (blocks < MAX_MANAGED_BLOCKS) {
              count &= 0b111;
              for (;;)
                switch (blocks) {
<#    for(var i = 0; i <= INDEX_LOOP_UNROLL; ++i) {#>
                  case <#=i#>: goto blockCount<#=i#>;
<#    }#>
                  default: {
                    do {
                      *(ulong*) @this = 0;
<#    for(var i = 1; i < INDEX_LOOP_UNROLL; ++i) {#>
                      ((ulong*) @this)[<#=i#>] = 0;
<#    }#>
                      @this += <#=(INDEX_LOOP_UNROLL * 8)#>;
                      blocks -= <#=INDEX_LOOP_UNROLL#>;
                    } while (blocks >= <#=INDEX_LOOP_UNROLL#>);

                    continue; // next blocks
                  }
                }

<#    for(var i = INDEX_LOOP_UNROLL; i > 0; --i) {#>
              blockCount<#=i#>: *(ulong*) @this = 0;
<#    }#>
              @this += blocks << 3;
              blockCount0:
              continue; // copy single bytes left
            } // medium-sized blocks

            // large blocks
            var start = @this;

            *(ulong*)@this = 0;
<#    for(var i = 1; i < INDEX_LOOP_UNROLL; ++i) {#>
            ((ulong*)@this)[<#=i#>] = 0;
<#    }#>
            @this += <#=(INDEX_LOOP_UNROLL * 8)#>;
            count -=<#=(INDEX_LOOP_UNROLL * 8)#>;

#if !PLATFORM_X86

            var block64 = *(Block64*)start;
<#    lastBlockCount = int.MaxValue;#>
<#    foreach(var blockCount in new[]{16, 8, 1}){#>
<#      var bytesPerLoop = 64 * blockCount;#>
<#      var canHaveMoreThanOneIteration = blockCount < (lastBlockCount / 2);#>
            <#=(canHaveMoreThanOneIteration ? "while" : "if")#> (count >= <#=bytesPerLoop#>) {
<#      lastBlockCount = blockCount;#>
              count -= <#=bytesPerLoop#>;
              *(Block64*)@this = block64;
<#      for(var i = 1; i < blockCount; ++i) {#>
              ((Block64*)@this)[<#=i#>] = block64;
<#      }#>
              @this += <#=bytesPerLoop#>;
            }
<#    }#>
            
            if (count != 0)
              continue;

#else

           var block8 = *(Block8*)start;
<#    lastBlockCount = int.MaxValue;#>
<#    foreach(var blockCount in new[]{8, 1}){#>
<#      var bytesPerLoop = 8 * blockCount;#>
<#      var canHaveMoreThanOneIteration = blockCount < (lastBlockCount / 2);#>
            <#=(canHaveMoreThanOneIteration ? "while" : "if")#> (count >= <#=bytesPerLoop#>) {
<#      lastBlockCount = blockCount;#>
              count -= <#=bytesPerLoop#>;
              *(Block8*)@this = block8;
<#      for(var i = 1; i < blockCount; ++i) {#>
              ((Block8*)@this)[<#=i#>] = block8;
<#      }#>
              @this += <#=bytesPerLoop#>;
            }
<#    }#>
            
            if (count != 0)
              continue;

            
#endif

            return;

            } // single-byte default
        } // single-byte switch
    }

#else

    public static void Clear(this IntPtr @this, int count) {
      <#=EmitCountTooSmallCheck()#>
      
      for (;;)
        switch (count) {
          case 0: return;
<#    for(var i = 1; i <= MARSHALL_SWITCH_COUNT; ++i) {#>
          case <#=i#>: 
            <#=string.Join("\n            ", EmitMarshalSetBytes(i))#>
            return;
<#    }#>
          default: {
            var blocks = count >> 3;
            
            count &= 0b111;
            for (;;)
              switch (blocks) {
<#    for(var i = 0; i <= MARSHALL_SWITCH_COUNT; ++i) {#>
                case <#=i#>: goto blockCount<#=i#>;
<#    }#>
                default: {
                  var block64=(object)new Block64();

                  do {
                    Marshal.StructureToPtr(block64, @this, false);
#if SUPPORTS_POINTER_ARITHMETIC
                    @this += 64;
#else
                    _Add(ref @this, 64);
#endif
                    blocks -= 8;
                  } while (blocks >= 8);

                  continue; // next blocks
                }
              }
              
<#    for(var i = MARSHALL_SWITCH_COUNT; i > 1; --i) {#>
            blockCount<#=i#>: Marshal.WriteInt64(@this, <#=((i - 1) * 8)#>, 0);
<#    }#>
            blockCount1: Marshal.WriteInt64(@this, 0);
#if SUPPORTS_POINTER_ARITHMETIC
            @this += blocks << 3;
#else
            _Add(ref @this, blocks << 3);
#endif
            blockCount0: continue; // copy single bytes left

          } // single-byte default
        } // single-byte switch
    }

#endif

    #endregion

    #region Copy-blocks

    #if UNSAFE

    #if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    #endif
    private static unsafe void _CopyTo(byte* source, int srcIndex, byte* target, int tgtIndex, int count)
      => _CopyTo(source + srcIndex, target + tgtIndex, count)
    ;

    #if PLATFORM_X86
    
    <#=string.Join("\n    ", EmitUnsafeProcessor("_CopyTo(byte* source, byte* target, int count)", LINEAR_BLOCK_COUNTX86, INDEX_LOOP_UNROLL, new[]{ "source", "target" }, LINEAR_BLOCK_COUNTX86, c => EmitCopyBlock(c, LINEAR_BLOCK_COUNTX86)))#>
    
    #else
    
    <#=string.Join("\n    ", EmitUnsafeProcessor("_CopyTo(byte* source, byte* target, int count)", LINEAR_BLOCK_COUNTX64, INDEX_LOOP_UNROLL, new[]{ "source", "target" }, LINEAR_BLOCK_COUNTX64, c => EmitCopyBlock(c, LINEAR_BLOCK_COUNTX64)))#>
    
    #endif
        
    #endif

    #endregion

    <#=string.Join("\n    ", EmitProcessor("Xor", new[]{ "data", "operand" }, UNSAFE_AND_SWITCH_COUNT, INDEX_LOOP_UNROLL, EmitXorBytes, EmitXorBytes86))#>

    <#=string.Join("\n    ", EmitProcessor("Or", new[]{ "data", "operand" }, UNSAFE_AND_SWITCH_COUNT, INDEX_LOOP_UNROLL, EmitOrBytes, EmitOrBytes86))#>

    <#=string.Join("\n    ", EmitProcessor("And", new[]{ "data", "operand" }, UNSAFE_AND_SWITCH_COUNT, INDEX_LOOP_UNROLL, EmitAndBytes, EmitAndBytes86))#>

    <#=string.Join("\n    ", EmitProcessor("Not", new[]{ "data" }, UNSAFE_NOT_SWITCH_COUNT, INDEX_LOOP_UNROLL, EmitNegateBytes, EmitNegateBytes86))#>

  }
}

<#+

struct TypeData {
  
  public string name;
  public int size;
  public bool useBlockCopyInsteadOfArrayCopy;
  public bool allowByteConversion;
  public bool noArraySupport;
  public bool hasHandcraftedCopyToMethod;
  public bool isUnsafeOnly;

  public bool NeedsCount => this.noArraySupport;
  public bool SupportsLength => !this.noArraySupport;
  public bool IsValueType => this.noArraySupport;
  public bool CanBeNull => !this.IsValueType;

}

double Log2(int i) => Math.Log(i) / Math.Log(2);

string EmitFastIntegerOperation(int i, string operationBase2, string operation) => EmitFastIntegerOperation(i, i => string.Format(operationBase2, i), i => string.Format(operation, i));

string EmitFastIntegerOperation(int i, Func<int, string> operationBase2, Func<int, string> operation) {
  var exponent = Log2(i);
  if(exponent == (int)exponent)
    return exponent == 0 ? string.Empty : operationBase2((int)exponent);
  else
    return operation(i);
}

string EmitFastIntegerMultiply(int i) => EmitFastIntegerOperation(i, " << {0}", " * {0}");
string EmitFastIntegerMultiply(string variable, int i) => EmitFastIntegerOperation(i, variable + " <<= {0}", variable + " *= {0}") + ";";
string EmitFastIntegerDivide(int i) => EmitFastIntegerOperation(i, " >> {0}", " / {0}");
string EmitFastIntegerDivide(string variable, int i) => EmitFastIntegerOperation(i, variable + " >>= {0}", variable + " /= {0}") + ";";
string EmitFastIntegerModulo(int i) => EmitFastIntegerOperation(i, i => " & " + (i == 1 ? "1" : "0b" + new string('1', i)), i => " % " + i);
string EmitFastIntegerModulo(string variable, int i) => EmitFastIntegerOperation(i, i => variable + " &= " + (i == 1 ? "1" : "0b" + new string('1', i)), i => variable + " %= " + i) + ";";

string EmitTypeDef(TypeData type) => type.noArraySupport ? type.name : type.name + "[]"; 

string GetDataTypeForByteCount(int sizeInBytes) {
  switch(sizeInBytes) {
    case 1:
      return "byte";
    case 2:
      return "ushort";
    case 4:
      return "uint";
    case 8:
      return "ulong";
    default:
      return $"Block{sizeInBytes}";
  }
}

string EmitIndexCopy(int i) => string.Format(@"target[tgtIndex{0}] = source[srcIndex{0}];", i == 0 ? string.Empty : " + " + i);

string EmitMarshalCopyByte(int i = 0)  => string.Format("Marshal.WriteByte(target, tgtIndex{0}, Marshal.ReadByte(source, srcIndex{0}));", i == 0 ? string.Empty : " + " + i);
string EmitMarshalCopyWord(int i = 0)  => string.Format("Marshal.WriteInt16(target, tgtIndex{0}, Marshal.ReadInt16(source, srcIndex{0}));", i == 0 ? string.Empty : " + " + i);
string EmitMarshalCopyDWord(int i = 0) => string.Format("Marshal.WriteInt32(target, tgtIndex{0}, Marshal.ReadInt32(source, srcIndex{0}));", i == 0 ? string.Empty : " + " + i);
string EmitMarshalCopyQWord(int i = 0) => string.Format("Marshal.WriteInt64(target, tgtIndex{0}, Marshal.ReadInt64(source, srcIndex{0}));", i == 0 ? string.Empty : " + " + i);
IEnumerable<string> EmitMarshalCopyBytes(int count) => EmitInlineBytes(count, EmitMarshalCopyByte, EmitMarshalCopyWord, EmitMarshalCopyDWord, EmitMarshalCopyQWord);

string EmitNegateByte(int i = 0) => i == 0 ? "*data = (byte)~*data;" : string.Format("data[{0}] = (byte)~data[{0}];", i);
string EmitNegateWord(int i = 0) => i == 0 ? "*(ushort*)data = (ushort)~*(ushort*)data;" : string.Format("((ushort*)data)[{0}] = (ushort)~((ushort*)data)[{0}];", i);
string EmitNegateDWord(int i = 0) => i == 0 ? "*(uint*)data = ~*(uint*)data;" : string.Format("((uint*)data)[{0}] = ~((uint*)data)[{0}];", i);
string EmitNegateQWord(int i = 0) => i == 0 ? "*(ulong*)data = ~*(ulong*)data;" : string.Format("((ulong*)data)[{0}] = ~((ulong*)data)[{0}];", i);
IEnumerable<string> EmitNegateBytes(int count) => EmitInlineBytes(count, EmitNegateByte, EmitNegateWord, EmitNegateDWord, EmitNegateQWord);
IEnumerable<string> EmitNegateBytes86(int count) => EmitInlineBytes(count, EmitNegateByte, EmitNegateWord, EmitNegateDWord);

string EmitAndByte(int i = 0) => i == 0 ? "*data &= *operand;" : string.Format("data[{0}] &= operand[{0}];", i);
string EmitAndWord(int i = 0) => i == 0 ? "*(ushort*)data &= *(ushort*)operand;" : string.Format("((ushort*)data)[{0}] &= ((ushort*)operand)[{0}];", i);
string EmitAndDWord(int i = 0) => i == 0 ? "*(uint*)data &= *(uint*)operand;" : string.Format("((uint*)data)[{0}] &= ((uint*)operand)[{0}];", i);
string EmitAndQWord(int i = 0) => i == 0 ? "*(ulong*)data &= *(ulong*)operand;" : string.Format("((ulong*)data)[{0}] &= ((ulong*)operand)[{0}];", i);
IEnumerable<string> EmitAndBytes(int count) => EmitInlineBytes(count, EmitAndByte, EmitAndWord, EmitAndDWord, EmitAndQWord);
IEnumerable<string> EmitAndBytes86(int count) => EmitInlineBytes(count, EmitAndByte, EmitAndWord, EmitAndDWord);

string EmitOrByte(int i = 0) => i == 0 ? "*data |= *operand;" : string.Format("data[{0}] |= operand[{0}];", i);
string EmitOrWord(int i = 0) => i == 0 ? "*(ushort*)data |= *(ushort*)operand;" : string.Format("((ushort*)data)[{0}] |= ((ushort*)operand)[{0}];", i);
string EmitOrDWord(int i = 0) => i == 0 ? "*(uint*)data |= *(uint*)operand;" : string.Format("((uint*)data)[{0}] |= ((uint*)operand)[{0}];", i);
string EmitOrQWord(int i = 0) => i == 0 ? "*(ulong*)data |= *(ulong*)operand;" : string.Format("((ulong*)data)[{0}] |= ((ulong*)operand)[{0}];", i);
IEnumerable<string> EmitOrBytes(int count) => EmitInlineBytes(count, EmitOrByte, EmitOrWord, EmitOrDWord, EmitOrQWord);
IEnumerable<string> EmitOrBytes86(int count) => EmitInlineBytes(count, EmitOrByte, EmitOrWord, EmitOrDWord);

string EmitXorByte(int i = 0) => i == 0 ? "*data ^= *operand;" : string.Format("data[{0}] ^= operand[{0}];", i);
string EmitXorWord(int i = 0) => i == 0 ? "*(ushort*)data ^= *(ushort*)operand;" : string.Format("((ushort*)data)[{0}] ^= ((ushort*)operand)[{0}];", i);
string EmitXorDWord(int i = 0) => i == 0 ? "*(uint*)data ^= *(uint*)operand;" : string.Format("((uint*)data)[{0}] ^= ((uint*)operand)[{0}];", i);
string EmitXorQWord(int i = 0) => i == 0 ? "*(ulong*)data ^= *(ulong*)operand;" : string.Format("((ulong*)data)[{0}] ^= ((ulong*)operand)[{0}];", i);
IEnumerable<string> EmitXorBytes(int count) => EmitInlineBytes(count, EmitXorByte, EmitXorWord, EmitXorDWord, EmitXorQWord);
IEnumerable<string> EmitXorBytes86(int count) => EmitInlineBytes(count, EmitXorByte, EmitXorWord, EmitXorDWord);

IEnumerable<string> EmitInlineBytes(int count, Func<int,string> emitByte,Func<int,string> emitWord = null,Func<int,string> emitDWord = null,Func<int,string> emitQWord = null) {
  var offset = 0;
  if (emitQWord != null)
    while(count >= 8) {
      yield return emitQWord(offset >> 3);
      count -= 8;
      offset += 8;
    }

  if(emitDWord != null)
    while(count >= 4) {
      yield return emitDWord(offset >> 2);
      count -= 4;
      offset += 4;
    }

  if(emitWord != null)
    while(count >= 2) {
      yield return emitWord(offset >> 1);
      count -= 2;
      offset += 2;
    }

  while (count >= 1) {
    yield return emitByte(offset);
    --count;
    ++offset;
  }
}

IEnumerable<string> EmitCopyBlock(int count,int maximumBlockSize) {
  var offset = 0;
  while (maximumBlockSize > 0 && count > 0) {
    if ( count < maximumBlockSize ) {
      --maximumBlockSize;  
      continue;
    }

    var needsByteOffset = offset % maximumBlockSize != 0;
    yield return EmitCopyBlockLine(maximumBlockSize, needsByteOffset ? offset : offset / maximumBlockSize, needsByteOffset);

    offset += maximumBlockSize;
    count -= maximumBlockSize;
  }
}

string EmitCopyBlockLine(int sizeInBytes, int index, bool isIndexInBytes) {
  if (sizeInBytes == 1)
    return index == 0 ? "*target = *source;" : string.Format("target[{1}] = source[{1}];", sizeInBytes, index);
  else {
    var dataType = GetDataTypeForByteCount(sizeInBytes);
    return index == 0 
      ? string.Format("*({0}*)target = *({0}*)source;", dataType) 
      : 
        isIndexInBytes
        ? string.Format("*(({0}*)(target + {1})) = *(({0}*)(source + {1}));", dataType, index)
        : string.Format("(({0}*)target)[{1}] = (({0}*)source)[{1}];", dataType, index)
    ;
  }
}


string EmitMarshalSetByte(int offset) => EmitMarshalSetByte(offset, null);
string EmitMarshalSetByte(string value) => EmitMarshalSetByte(0, value);
string EmitMarshalSetByte(int offset, string value) => string.Format("Marshal.WriteByte(@this, {0}{1});", offset == 0 ? string.Empty : offset + ", ", value ?? "0");

string EmitMarshalSetWord(int offset) => EmitMarshalSetWord(offset, null);
string EmitMarshalSetWord(string value) => EmitMarshalSetWord(0, value);
string EmitMarshalSetWord(int offset, string value) => string.Format("Marshal.WriteInt16(@this, {0}{1});", offset == 0 ? string.Empty : offset + ", ", value ?? "0");

string EmitMarshalSetDWord(int offset) => EmitMarshalSetDWord(offset, null);
string EmitMarshalSetDWord(string value) => EmitMarshalSetDWord(0, value);
string EmitMarshalSetDWord(int offset, string value) => string.Format("Marshal.WriteInt32(@this, {0}{1});", offset == 0 ? string.Empty : offset + ", ", value ?? "0");

string EmitMarshalSetQWord(int offset) => EmitMarshalSetQWord(offset, null);
string EmitMarshalSetQWord(string value) => EmitMarshalSetQWord(0, value);
string EmitMarshalSetQWord(int offset, string value) => string.Format("Marshal.WriteInt64(@this, {0}{1});", offset == 0 ? string.Empty : offset + ", ", value ?? "0");

IEnumerable<string> EmitMarshalSetBytes(int count) => EmitMarshalSetBytes(count, null);
IEnumerable<string> EmitMarshalSetBytes(int count, string value) {
  var offset = 0;

  if (count >= 8 ) {
    var reuseValue = value != null && count >= 16;
  
    if(reuseValue) {
      yield return "{";
      yield return "  var temp = (SBlock8)(0x0101010101010101UL * " + value + ");";
    }

    while (count >= 8) {
      yield return (reuseValue ? "  " : string.Empty) + EmitMarshalSetQWord(offset, reuseValue ? "temp" : value != null ? "(SBlock8)(0x0101010101010101UL * " + value + ")" : null);
      offset += 8;
      count-= 8;
    }

    if(reuseValue)
      yield return "}";
  }

  if (count >= 4) {
    yield return EmitMarshalSetDWord(offset, value != null ? "(SBlock4)(0x01010101U * " + value + ")" : null);
    offset += 4;
    count-= 4;
  }

  if (count >= 2) {
    yield return EmitMarshalSetWord(offset, value != null ? "(SBlock2)(0x0101 * " + value + ")" : null);
    offset += 2;
    count-= 2;
  }
  
  if(count > 0)
    yield return EmitMarshalSetByte(offset, value);
}

string EmitSetByte(int offset) => EmitSetByte(offset, null);
string EmitSetByte(string value) => EmitSetByte(0, value);
string EmitSetByte(int offset, string value) => string.Format("{0} = {1};", offset == 0 ? "*@this" : "@this[" + offset + "]", value ?? "0");

string EmitSetWord(int offset) => EmitSetWord(offset, null);
string EmitSetWord(string value) => EmitSetWord(0, value);
string EmitSetWord(int offset, string value) => string.Format("{0} = {1};", offset == 0 ? "*(ushort*)@this" : "*(ushort*)(@this + " + offset + ")", value ?? "0");

string EmitSetDWord(int offset) => EmitSetDWord(offset, null);
string EmitSetDWord(string value) => EmitSetDWord(0, value);
string EmitSetDWord(int offset, string value) => string.Format("{0} = {1};", offset == 0 ? "*(uint*)@this" : "*(uint*)(@this + " + offset + ")", value ?? "0");

string EmitSetQWord(int offset) => EmitSetQWord(offset, null);
string EmitSetQWord(string value) => EmitSetQWord(0, value);
string EmitSetQWord(int offset, string value) => string.Format("{0} = {1};", offset == 0 ? "*(ulong*)@this" : "*(ulong*)(@this + " + offset + ")", value ?? "0");

IEnumerable<string> EmitSetBytes(int count) => EmitSetBytes(count, null);
IEnumerable<string> EmitSetBytes(int count, string value) {
  var offset = 0;

  if (count >= 8 ) {
    var reuseValue = value != null && count >= 16;
  
    if(reuseValue) {
      yield return "{";
      yield return "  var temp = 0x0101010101010101UL * " + value + ";";
    }

    while (count >= 8) {
      yield return (reuseValue ? "  " : string.Empty) + EmitSetQWord(offset, reuseValue ? "temp" : value != null ? "0x0101010101010101UL * " + value : null);
      offset += 8;
      count-= 8;
    }

    if(reuseValue)
      yield return "}";
  }

  if (count >= 4) {
    yield return EmitSetDWord(offset, value != null ? "0x01010101U * " + value : null);
    offset += 4;
    count-= 4;
  }

  if (count >= 2) {
    yield return EmitSetWord(offset, value != null ? "(ushort)(0x0101 * " + value + ")": null);
    offset += 2;
    count-= 2;
  }
  
  if(count > 0)
    yield return EmitSetByte(offset, value);
}

IEnumerable<string> EmitProcessor(string name, string[] operands, int caseCount, int unrollCount, Func<int, IEnumerable<string>> byteEmitter, Func<int, IEnumerable<string>> byteEmitter86 = null) {
  yield return "#region In-Place " + name;
  yield return string.Empty;
  
  yield return "public static void " + name 
    + "(this " 
    + string.Join(", ",operands.Select((n, i) => "byte[] " + (i==0 ? "@this" : n))) 
    + ") => " + name + "(" 
    + string.Join(", ",operands.Select((n, i) => (i==0 ? "@this" : n) + ", 0") ) 
    + ", @this.Length);"
    ;

  yield return "public static void " + name 
    + "(this "
    + string.Join(", ",operands.Select((n, i) => "byte[] " + (i==0 ? "@this" : n) + ", int " + (i==0 ? "o" : n + "O") + "ffset")) 
    + ", int count) {";

  yield return "  " + EmitThisNullCheck();
  foreach(var operand in operands.Skip(1))
    yield return "  " + EmitArgNullCheck(operand);

  yield return "  " + EmitCountTooSmallCheck();

  for (var i = 0; i < operands.Length; ++i)
    yield return "  " + EmitCountTooLargeCheck(( i ==0 ? "@this" : operands[i] ) + ".Length - " + ( i ==0 ? "o" : operands[i] + "O" ) + "ffset");

  var paramList = string.Join(", ", operands.Select((n, i) => ( i ==0 ? "@this" : operands[i] ) + ", " + ( i ==0 ? "o" : operands[i] + "O" ) + "ffset"));
  yield return "  #if UNSAFE";
  yield return "  _" + name + "Unmanaged(" + paramList + ", count);";
  yield return "  #else";
  yield return "  _" + name + "Managed(" + paramList + ", count);";
  yield return "  #endif";
  yield return "}";
  yield return string.Empty;
  
  yield return "#if UNSAFE";
  yield return string.Empty;
  
  yield return "#if SUPPORTS_INLINING";
  yield return "[MethodImpl(MethodImplOptions.AggressiveInlining)]";
  yield return "#endif";
  yield return "private static unsafe void _" + name + "Unmanaged("
    + string.Join(", ", operands.Select((n, i) => "byte[] " + operands[i] + ", int "+ ( i ==0 ? "o" : operands[i] + "O" ) + "ffset"))
    +", int count) {"
    ;

  foreach(var operand in operands)
    yield return "  fixed(byte* " + operand + "Pointer = " + operand + ")";
  
  yield return "    _" + name + "Unmanaged(" + string.Join(", ", operands.Select((n, i) => n + "Pointer + " + ( i ==0 ? "o" : operands[i] + "O" ) + "ffset")) + ", count);";
  yield return "}";
  yield return string.Empty;
  
  foreach(var line in EmitUnsafeProcessor("_" + name + "Unmanaged(" + string.Join(", ", operands.Select(n => "byte* " + n)) + ", int count)", caseCount, unrollCount, operands, 8, byteEmitter, 4, byteEmitter86))
    yield return line;

  yield return string.Empty;
  
  yield return "#endif";
  yield return string.Empty;
  
  yield return "#endregion";
}

IEnumerable<string> EmitUnsafeProcessor(string signature, int caseCount, int unrollCount, string[] variablesToIncrement, int byteBlockCount, Func<int, IEnumerable<string>> byteEmitter, int byteBlockCount86 = 0, Func<int, IEnumerable<string>> byteEmitter86 = null) {
  yield return "#if SUPPORTS_INLINING";
  yield return "[MethodImpl(MethodImplOptions.AggressiveInlining)]";
  yield return "#endif";
  yield return "private static unsafe void " + signature + " {";
  yield return "  for(;;) {";
  yield return "    endOfBlocks: ;";
  yield return "    switch (count) {";
  yield return "      case 0: return;";
  for(var i = 1; i < caseCount; ++i) {
    yield return "      case " + i + ":";
    foreach(var line in byteEmitter(i))
      yield return "        " + line;

    yield return "        return;";
  }
  yield return "    }";
  
  foreach(var line in byteEmitter(caseCount))
    yield return "    " + line;
  
  yield return "    count -= " + caseCount + ";";
  yield return "    if (count <= 0) return;";
  foreach(var j in variablesToIncrement)
    yield return "    " + j + " += " + caseCount + ";";
  
  if (byteEmitter86 != null && byteBlockCount86 > 0) {
    yield return "    #if PLATFORM_X86";
    foreach(var line in EmitBlockProcess(byteBlockCount86, unrollCount, byteEmitter86, variablesToIncrement))
      yield return "      " + line;

    yield return "    #else";
  }

  foreach(var line in EmitBlockProcess(byteBlockCount, unrollCount, byteEmitter, variablesToIncrement))
    yield return "      " + line;

  if (byteEmitter86 != null)
    yield return "    #endif";

  yield return "  }";
  yield return "}";
}

IEnumerable<string> EmitBlockProcess(int size, int unrollCount, Func<int, IEnumerable<string>> byteEmitter, string[] variablesToIncrement) {
  yield return "var blockCount = count" + EmitFastIntegerDivide(size)+ ";";
  yield return EmitFastIntegerModulo("count", size);
  yield return "for (;;) {";
  yield return "  switch(blockCount) {";
  yield return "    case 0: goto endOfBlocks;";
  for(var i = 1; i <= unrollCount; ++i) {
    yield return "    case " + i + ":";
    foreach(var line in byteEmitter(i * size))
      yield return "      " + line;

    foreach(var j in variablesToIncrement)
      yield return "      " + j + " += " + (i * size) + ";";

    yield return "      goto endOfBlocks;";
  }
  yield return "  }";
  yield return "  do {";
  foreach(var line in byteEmitter(unrollCount * size))
    yield return "    " + line;

  foreach(var j in variablesToIncrement)
    yield return "    " + j + " += " + (unrollCount * size) + ";";

  yield return "    blockCount -= " + unrollCount + ";";
  yield return "  } while(blockCount >= " + unrollCount + ");";
  yield return "}";
}

string EmitThisNullCheck() => @"Guard.Against.ThisIsNull(@this);";
string EmitArgNullCheck(string paramName) => string.Format(@"Guard.Against.ArgumentIsNull({0});", paramName);

string EmitOffsetTooSmallCheck(string paramName) => string.Format(@"if ({0} < 0) Guard.AlwaysThrow.IndexTooLowException(nameof({0}), {0});", paramName);
string EmitOffsetTooSmallCheck() => EmitOffsetTooSmallCheck("index");

string EmitOffsetTooLargeCheck(string paramName, string limit) => string.Format(@"if ({0} >= {1}) Guard.AlwaysThrow.IndexTooHighException(nameof({0}), {0}, {1});", paramName, limit);
string EmitOffsetTooLargeCheck(string limit) => EmitOffsetTooLargeCheck("index", limit);
string EmitOffsetTooLargeCheck() => EmitOffsetTooLargeCheck("length");

string EmitCountTooSmallCheck(string paramName) => string.Format(@"if ({0} < 0) Guard.AlwaysThrow.CountTooLowException(nameof({0}), {0});", paramName);
string EmitCountTooSmallCheck() => EmitCountTooSmallCheck("count");

string EmitCountTooLargeCheck(string source, string length, string paramName) => string.Format(@"if ({0} > {1}) Guard.AlwaysThrow.CountTooHighException(nameof({2}), {0}, {1});", source, length, paramName);
string EmitCountTooLargeCheck(string source, string length) => EmitCountTooLargeCheck(source, length, source);
string EmitCountTooLargeCheck(string length) => EmitCountTooLargeCheck("count", length);
string EmitCountTooLargeCheck() => EmitCountTooLargeCheck("length");

string EmitMethodHeader(string returnType, string name, TypeData type) => string.Format("public static {0}{1} {2}({3}{4} @this", type.isUnsafeOnly ? "unsafe " : string.Empty, returnType, name, type.isUnsafeOnly ? string.Empty : "this ", EmitTypeDef(type));
string EmitMethodHeader(string name, TypeData type) => EmitMethodHeader(EmitTypeDef(type), name, type);

IEnumerable<string> EmitMethodHeader2(string returnType, string name, TypeData type) {
  yield return "#if SUPPORTS_INLINING";
  yield return "[MethodImpl(MethodImplOptions.AggressiveInlining)]";
  yield return "#endif";
  yield return EmitMethodHeader(returnType, name, type);
}

IEnumerable<string> EmitMethodHeader2(string name, TypeData type) => EmitMethodHeader2(EmitTypeDef(type), name, type);

    

#>