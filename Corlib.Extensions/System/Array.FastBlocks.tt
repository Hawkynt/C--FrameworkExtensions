<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
#region (c)2010-2042 Hawkynt

// This file is part of Hawkynt's .NET Framework extensions.
// 
// Hawkynt's .NET Framework extensions are free software:
// you can redistribute and/or modify it under the terms
// given in the LICENSE file.
// 
// Hawkynt's .NET Framework extensions is distributed in the hope that
// it will be useful, but WITHOUT ANY WARRANTY without even the implied
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the LICENSE file for more details.
// 
// You should have received a copy of the License along with Hawkynt's
// .NET Framework extensions. If not, see
// <https://github.com/Hawkynt/C--FrameworkExtensions/blob/master/LICENSE>.

#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */
<#
  const int LINEAR_BLOCK_COUNTX86   = 16;              // x86 can only copy 16-byte blocks without emitting loop constructs (rep movsb)
  const int LINEAR_BLOCK_COUNTX64   = 64;              // x64 uses vmovdqu for blocks up to 64-bytes
  const int UNSAFE_SWITCH_COUNT     = 8;               // what number of bytes to unroll unsafe
  const int INDEX_LOOP_UNROLL       = 8;               // ldc.i4 8 is the highest opcode available for index operations
  const int BYTE_COUNT_POINTER      = 1 * 1024 * 1024; // we'll use pointer pinning and block-copies when this many bytes need to be copied
  const int ELEMENT_COUNT_BLOCK     = 256;             // we'll use Array.Copy or Buffer.BlockCopy when more than this many elements are present
    
  List<TypeData> typeDatas = new();
  typeDatas.Add(new TypeData{ name = "sbyte"  , size = 1, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "byte"   , size = 1, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "short"  , size = 2, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "ushort" , size = 2, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "int"    , size = 4, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "uint"   , size = 4, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "long"   , size = 8, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "ulong"  , size = 8, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "float"  , size = 4, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "double" , size = 8, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "char"   , size = 2, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "string"});
  typeDatas.Add(new TypeData{ name = "decimal", size = 16});
  typeDatas.Add(new TypeData{ name = "bool"   , size = 1});
  typeDatas.Add(new TypeData{ name = "IntPtr" , hasHandcraftedCopyToMethod = true, noArraySupport = true});
  typeDatas.Add(new TypeData{ name = "byte*"  , hasHandcraftedCopyToMethod = true, noArraySupport = true, isUnsafeOnly = true});
#>

using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using MethodImplOptions = Utilities.MethodImplOptions;
using Guard;

using Block1 = System.Byte;
using Block2 = System.UInt16;
using Block4 = System.UInt32;
using Block8 = System.UInt64;
using SBlock2 = System.Int16;
using SBlock4 = System.Int32;
using SBlock8 = System.Int64;

namespace System;

public static partial class ArrayExtensions {
    
  #region nested types

#if PLATFORM_X86
<#  for(var i = 3;i <= LINEAR_BLOCK_COUNTX86; ++i) {#>
<#    if(i == 1 || i == 2 || i == 4 || i == 8 || i == 32 || i == 64) continue;#>
  [StructLayout(LayoutKind.Sequential, Size=<#=i#>)] private struct Block<#=i#>{ }
<#  }#>
#else
<#  for(var i = 3;i <= LINEAR_BLOCK_COUNTX64; ++i) {#>
<#    if(i == 1 || i == 2 || i == 4 || i == 8 || i == 32 || i == 64) continue;#>
  [StructLayout(LayoutKind.Sequential, Size=<#=i#>)] private struct Block<#=i#>{ }
<#  }#>
#endif

  #endregion

  // TODO: SequenceEquals for byte[], IntPtr, byte*, ushort[], short[], uint[], int[], ulong[], long[], float[], double[]
  // TODO: unchecked versions

  #region Copy
<#  foreach(var typeData in typeDatas) {#>
<#    var typeName = typeData.name;#>
  #region Type: <#=typeName#>
<#    if(!typeData.noArraySupport) {#>

  <#=string.Join("\n  ", EmitMethodHeader2("Copy", typeData))#>) {
    <#=EmitThisNullCheck()#>

    var length = @this.Length;
    var result = new <#=typeName#>[length];
    _CopyTo(@this, 0, result, 0, length);
    return result;
  }

  <#=string.Join("\n  ", EmitMethodHeader2("Copy", typeData))#>, int index) {
    <#=EmitThisNullCheck()#>
    <#=EmitOffsetTooSmallCheck()#>
    var length = @this.Length;
    <#=EmitOffsetTooLargeCheck()#>
    var count = length - index;
    var result = new <#=typeName#>[count];
    _CopyTo(@this, index, result, 0, count);
    return result;
  }

  <#=string.Join("\n  ", EmitMethodHeader2("Copy", typeData))#>, int index, int count) {
    <#=EmitThisNullCheck()#>
    <#=EmitOffsetTooSmallCheck()#>
    var length = @this.Length;
    <#=EmitOffsetTooLargeCheck()#>
    <#=EmitCountTooSmallCheck()#>
    <#=EmitCountTooLargeCheck("length - index")#>

    var result = new <#=typeName#>[count];
    _CopyTo(@this, index, result, 0, count);
    return result;
  }
<#    }#>

<#    if(!typeData.NeedsCount) {#>
  <#=string.Join("\n  ", EmitMethodHeader2("void", "CopyTo", typeData))#>, <#=EmitTypeDef(typeData)#> target) {
<#      if(typeData.CanBeNull)  {#>
    <#=EmitThisNullCheck()#>
    <#=EmitArgNullCheck("target")#>
<#      }#>
    var count = @this.Length;
    <#=EmitCountTooLargeCheck("count", "target.Length", "target")#>
    _CopyTo(@this, 0 , target, 0, count);
  }

  <#=string.Join("\n  ", EmitMethodHeader2("void", "CopyTo", typeData))#>, int srcIndex, <#=EmitTypeDef(typeData)#> target) {
<#      if(typeData.CanBeNull)  {#>
    <#=EmitThisNullCheck()#>
    <#=EmitArgNullCheck("target")#>
<#      }#>
    <#=EmitOffsetTooSmallCheck("srcIndex")#>
    var length = @this.Length;
    <#=EmitOffsetTooLargeCheck("srcIndex", "length")#>
    var count = length - srcIndex;
    <#=EmitCountTooLargeCheck("count", "target.Length", "target")#>
    _CopyTo(@this, srcIndex , target, 0, count);
  }

  <#=string.Join("\n  ", EmitMethodHeader2("void", "CopyTo", typeData))#>, <#=EmitTypeDef(typeData)#> target, int tgtIndex) {
<#      if(typeData.CanBeNull)  {#>
    <#=EmitThisNullCheck()#>
    <#=EmitArgNullCheck("target")#>
<#      }#>
    <#=EmitOffsetTooSmallCheck("tgtIndex")#>
    var length = target.Length;
    <#=EmitOffsetTooLargeCheck("tgtIndex", "length")#>
    var count = @this.Length;
    <#=EmitCountTooLargeCheck("count", "target.Length - tgtIndex", "@this")#>
    _CopyTo(@this, 0 , target, tgtIndex, count);
  }
<#    } else {#>
  <#=string.Join("\n  ", EmitMethodHeader2("void", "CopyTo", typeData))#>, int count, <#=EmitTypeDef(typeData)#> target) {
<#      if(typeData.CanBeNull)  {#>
    <#=EmitThisNullCheck()#>
    <#=EmitArgNullCheck("target")#>
<#      }#>
    <#=EmitCountTooSmallCheck()#>
    _CopyTo(@this, 0 , target, 0, count);
  }

  <#=string.Join("\n  ", EmitMethodHeader2("void", "CopyTo", typeData))#>, int count, int srcIndex, <#=EmitTypeDef(typeData)#> target) {
<#      if(typeData.CanBeNull)  {#>
    <#=EmitThisNullCheck()#>
    <#=EmitArgNullCheck("target")#>
<#      }#>
    <#=EmitOffsetTooSmallCheck("srcIndex")#>
    <#=EmitCountTooSmallCheck()#>
    _CopyTo(@this, srcIndex , target, 0, count);
  }

  <#=string.Join("\n  ", EmitMethodHeader2("void", "CopyTo", typeData))#>, int count, <#=EmitTypeDef(typeData)#> target, int tgtIndex) {
<#      if(typeData.CanBeNull)  {#>
    <#=EmitThisNullCheck()#>
    <#=EmitArgNullCheck("target")#>
<#      }#>
    <#=EmitOffsetTooSmallCheck("tgtIndex")#>
    <#=EmitCountTooSmallCheck()#>
    _CopyTo(@this, 0 , target, tgtIndex, count);
  }
<#    }#>

  <#=string.Join("\n  ", EmitMethodHeader2("void", "CopyTo", typeData))#>, int srcIndex, <#=EmitTypeDef(typeData)#> target, int tgtIndex, int count) {
<#    if(typeData.CanBeNull)  {#>
    <#=EmitThisNullCheck()#>
    <#=EmitArgNullCheck("target")#>
<#    }#>
    <#=EmitOffsetTooSmallCheck("srcIndex")#>
    <#=EmitOffsetTooSmallCheck("tgtIndex")#>
    <#=EmitCountTooSmallCheck()#>
<#    if(typeData.SupportsLength) {#>
    <#=EmitOffsetTooLargeCheck("srcIndex", "@this.Length")#>
    <#=EmitOffsetTooLargeCheck("tgtIndex", "target.Length")#>
    <#=EmitCountTooLargeCheck("count", "@this.Length - srcIndex")#>
    <#=EmitCountTooLargeCheck("count", "target.Length - tgtIndex")#>
<#    }#>
    _CopyTo(@this, srcIndex , target, tgtIndex, count);
  }
<#    if(typeData.allowByteConversion){#>
<#      foreach(var tgtTypeData in typeDatas.Where(i=>i.name != typeName && i.allowByteConversion)){#>

  <#=string.Join("\n  ", EmitMethodHeader2("void", "CopyTo", typeData))#>, int srcIndex, <#=EmitTypeDef(tgtTypeData)#> target, int tgtIndex, int count) {
    <#=EmitThisNullCheck()#>
    <#=EmitArgNullCheck("target")#>
    <#=EmitOffsetTooSmallCheck("srcIndex")#>
    <#=EmitOffsetTooSmallCheck("tgtIndex")#>
    <#=EmitOffsetTooLargeCheck("srcIndex", "@this.Length")#>
    <#=EmitOffsetTooLargeCheck("tgtIndex", "target.Length")#>
    <#=EmitCountTooLargeCheck("count", "@this.Length - srcIndex")#>
<#        if(tgtTypeData.size != typeData.size) {#>
    var bytesNeeded = count<#=EmitFastIntegerMultiply(typeData.size)#>;
    var bytesAvailable = (target.Length - tgtIndex)<#=EmitFastIntegerMultiply(tgtTypeData.size)#>;
    <#=EmitCountTooLargeCheck("bytesNeeded", "bytesAvailable", "count")#>
    if ((bytesNeeded<#=EmitFastIntegerModulo(tgtTypeData.size)#>) != 0) AlwaysThrow.CountNotMultipleOfException(nameof(target), count<#=EmitFastIntegerMultiply(typeData.size / tgtTypeData.size)#>, target.Length - tgtIndex);
<#        } else {#>
    <#=EmitCountTooLargeCheck("count", "target.Length - tgtIndex", "count")#>
<#        }#>
    _CopyTo(@this, srcIndex, target, tgtIndex, count);
  }
<#      }#>
<#    }#>
  #endregion
<#  }#>
<#  foreach(var typeData in typeDatas.Where(i=>!i.hasHandcraftedCopyToMethod)) {#>
<#    var typeName = typeData.name;#>
    
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  private static void _CopyTo(<#=EmitTypeDef(typeData)#> source, int srcIndex,<#=EmitTypeDef(typeData)#> target, int tgtIndex, int count){
    for (;;) {
      switch(count){
        case 0: return;
<#      for(var i = 1; i < INDEX_LOOP_UNROLL; ++i) {#>
        case <#=i#>:
<#      for(var j = 0; j < i; ++j) {#>
          <#=EmitIndexCopy(j)#><#}#>
          return;
<#      }#>
      }

<#      if(BYTE_COUNT_POINTER > 0 && typeData.size > 0 && typeData.useBlockCopyInsteadOfArrayCopy) {#>
      if( count > <#=(BYTE_COUNT_POINTER / typeData.size)#>) {
        unsafe {
          fixed(<#=typeData.name#>* sourceFixedPointer = &source[srcIndex])
          fixed(<#=typeData.name#>* targetFixedPointer = &target[tgtIndex])
            _CopyTo(<#=(typeData.name == "byte" ? string.Empty : "(byte*)")#>sourceFixedPointer, <#=(typeData.name == "byte" ? string.Empty : "(byte*)")#>targetFixedPointer, count<#=EmitFastIntegerMultiply(typeData.size)#>);
        }

        return;
      }

<#      }#>
<#      if(ELEMENT_COUNT_BLOCK > 0) {#>
      if(count > <#=ELEMENT_COUNT_BLOCK#>) {
        <#=(typeData.useBlockCopyInsteadOfArrayCopy ? "Buffer.BlockCopy" : "Array.Copy")#>(source, srcIndex<#=(typeData.useBlockCopyInsteadOfArrayCopy ? EmitFastIntegerMultiply(typeData.size) : string.Empty)#>, target, tgtIndex<#=(typeData.useBlockCopyInsteadOfArrayCopy ? EmitFastIntegerMultiply(typeData.size) : string.Empty)#>, count<#=(typeData.useBlockCopyInsteadOfArrayCopy ? EmitFastIntegerMultiply(typeData.size) : string.Empty)#>);
        return;
      }

<#      }#>
      while(count >= <#=INDEX_LOOP_UNROLL#>) {
<#      for(var i = 0; i < INDEX_LOOP_UNROLL; ++i) {#>
        <#=EmitIndexCopy(i)#><#}#>
          
        srcIndex += <#=INDEX_LOOP_UNROLL#>;
        tgtIndex += <#=INDEX_LOOP_UNROLL#>;
        count -= <#=INDEX_LOOP_UNROLL#>;
      }

    }
  }
<#    if(typeData.allowByteConversion){#>
<#      foreach(var tgtTypeData in typeDatas.Where(i=>i.name != typeName && i.allowByteConversion)){#>

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  private static void _CopyTo(<#=EmitTypeDef(typeData)#> source, int srcIndex, <#=EmitTypeDef(tgtTypeData)#> target, int tgtIndex, int count)
    => Buffer.BlockCopy(source, srcIndex<#=EmitFastIntegerMultiply(typeData.size)#>, target, tgtIndex<#=EmitFastIntegerMultiply(tgtTypeData.size)#>, count<#=EmitFastIntegerMultiply(typeData.size)#>)
  ;
<#      }#>
<#    }#>
<#  }#>

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  private static unsafe void _CopyTo(IntPtr source, int srcIndex, IntPtr target, int tgtIndex, int count)
    => _CopyTo(&((byte*)source)[srcIndex], &((byte*)target)[tgtIndex], count)
    ;

  #endregion

  #region Fill

  #region byte[] Fill

  /// <summary>
  /// Fills the entire byte array with the specified value.
  /// </summary>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Fill(this byte[] @this, byte value) {
    Against.ThisIsNull(@this);
    ((Span<byte>)@this).Fill(value);
  }

  /// <summary>
  /// Fills the byte array starting at offset with the specified value.
  /// </summary>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Fill(this byte[] @this, byte value, int offset) {
    Against.ThisIsNull(@this);
    Against.IndexOutOfRange(offset, @this.Length);
    @this.AsSpan(offset).Fill(value);
  }

  /// <summary>
  /// Fills a portion of the byte array with the specified value.
  /// </summary>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Fill(this byte[] @this, byte value, int offset, int count) {
    Against.ThisIsNull(@this);
    Against.IndexOutOfRange(offset, @this.Length);
    Against.CountOutOfRange(count, offset + count, @this.Length);
    @this.AsSpan(offset, count).Fill(value);
  }

  /// <summary>
  /// Fills the byte array with tiled ushort values.
  /// </summary>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Fill(this byte[] @this, ushort value, int count) {
    Against.ThisIsNull(@this);
    Against.CountOutOfRange(count, count << 1, @this.Length);
    MemoryMarshal.Cast<byte, ushort>(@this.AsSpan(0, count << 1)).Fill(value);
  }

  /// <summary>
  /// Fills a portion of the byte array with tiled ushort values.
  /// </summary>
  /// <param name="this">The byte array to fill.</param>
  /// <param name="value">The ushort value to tile.</param>
  /// <param name="offset">The element offset (in ushorts).</param>
  /// <param name="count">The number of ushorts to fill.</param>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Fill(this byte[] @this, ushort value, int offset, int count) {
    Against.ThisIsNull(@this);
    Against.IndexOutOfRange(offset, @this.Length);
    Against.CountOutOfRange(count, (offset + count) << 1, @this.Length);
    MemoryMarshal.Cast<byte, ushort>(@this.AsSpan(offset << 1, count << 1)).Fill(value);
  }

  /// <summary>
  /// Fills the byte array with tiled uint values.
  /// </summary>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Fill(this byte[] @this, uint value, int count) {
    Against.ThisIsNull(@this);
    Against.CountOutOfRange(count, count << 2, @this.Length);
    MemoryMarshal.Cast<byte, uint>(@this.AsSpan(0, count << 2)).Fill(value);
  }

  /// <summary>
  /// Fills a portion of the byte array with tiled uint values.
  /// </summary>
  /// <param name="this">The byte array to fill.</param>
  /// <param name="value">The uint value to tile.</param>
  /// <param name="offset">The element offset (in uints).</param>
  /// <param name="count">The number of uints to fill.</param>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Fill(this byte[] @this, uint value, int offset, int count) {
    Against.ThisIsNull(@this);
    Against.IndexOutOfRange(offset, @this.Length);
    Against.CountOutOfRange(count, (offset + count) << 2, @this.Length);
    MemoryMarshal.Cast<byte, uint>(@this.AsSpan(offset << 2, count << 2)).Fill(value);
  }

  /// <summary>
  /// Fills the byte array with tiled ulong values.
  /// </summary>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Fill(this byte[] @this, ulong value, int count) {
    Against.ThisIsNull(@this);
    Against.CountOutOfRange(count, count << 3, @this.Length);
    MemoryMarshal.Cast<byte, ulong>(@this.AsSpan(0, count << 3)).Fill(value);
  }

  /// <summary>
  /// Fills a portion of the byte array with tiled ulong values.
  /// </summary>
  /// <param name="this">The byte array to fill.</param>
  /// <param name="value">The ulong value to tile.</param>
  /// <param name="offset">The element offset (in ulongs).</param>
  /// <param name="count">The number of ulongs to fill.</param>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Fill(this byte[] @this, ulong value, int offset, int count) {
    Against.ThisIsNull(@this);
    Against.IndexOutOfRange(offset, @this.Length);
    Against.CountOutOfRange(count, (offset + count) << 3, @this.Length);
    MemoryMarshal.Cast<byte, ulong>(@this.AsSpan(offset << 3, count << 3)).Fill(value);
  }

  #endregion

  #region IntPtr Fill

  /// <summary>
  /// Fills memory at IntPtr with the specified byte value.
  /// </summary>
  public static unsafe void Fill(this IntPtr @this, byte value, int count) {
    Against.ThisIsNull(@this);
    Against.CountBelowOrEqualZero(count);
    new Span<byte>((byte*)@this, count).Fill(value);
  }

  /// <summary>
  /// Fills memory at IntPtr with the specified byte value starting at offset.
  /// </summary>
  public static unsafe void Fill(this IntPtr @this, byte value, int offset, int count) {
    Against.ThisIsNull(@this);
    Against.CountBelowOrEqualZero(count);
    new Span<byte>((byte*)@this + offset, count).Fill(value);
  }

  /// <summary>
  /// Fills memory at IntPtr with the specified ushort value.
  /// </summary>
  public static unsafe void Fill(this IntPtr @this, ushort value, int count) {
    Against.ThisIsNull(@this);
    Against.CountBelowOrEqualZero(count);
    new Span<ushort>((ushort*)@this, count).Fill(value);
  }

  /// <summary>
  /// Fills memory at IntPtr with the specified ushort value starting at offset.
  /// </summary>
  public static unsafe void Fill(this IntPtr @this, ushort value, int offset, int count) {
    Against.ThisIsNull(@this);
    Against.CountBelowOrEqualZero(count);
    new Span<ushort>((ushort*)@this + offset, count).Fill(value);
  }

  /// <summary>
  /// Fills memory at IntPtr with the specified uint value.
  /// </summary>
  public static unsafe void Fill(this IntPtr @this, uint value, int count) {
    Against.ThisIsNull(@this);
    Against.CountBelowOrEqualZero(count);
    new Span<uint>((uint*)@this, count).Fill(value);
  }

  /// <summary>
  /// Fills memory at IntPtr with the specified uint value starting at offset.
  /// </summary>
  public static unsafe void Fill(this IntPtr @this, uint value, int offset, int count) {
    Against.ThisIsNull(@this);
    Against.CountBelowOrEqualZero(count);
    new Span<uint>((uint*)@this + offset, count).Fill(value);
  }

  /// <summary>
  /// Fills memory at IntPtr with the specified ulong value.
  /// </summary>
  public static unsafe void Fill(this IntPtr @this, ulong value, int count) {
    Against.ThisIsNull(@this);
    Against.CountBelowOrEqualZero(count);
    new Span<ulong>((ulong*)@this, count).Fill(value);
  }

  /// <summary>
  /// Fills memory at IntPtr with the specified ulong value starting at offset.
  /// </summary>
  public static unsafe void Fill(this IntPtr @this, ulong value, int offset, int count) {
    Against.ThisIsNull(@this);
    Against.CountBelowOrEqualZero(count);
    new Span<ulong>((ulong*)@this + offset, count).Fill(value);
  }

  #endregion

  #endregion

  #region Clear

  /// <summary>
  /// Clears the byte array by setting all elements to zero.
  /// </summary>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Clear(this byte[] @this) {
    Against.ThisIsNull(@this);
    ((Span<byte>)@this).Clear();
  }

  /// <summary>
  /// Clears the ushort array by setting all elements to zero.
  /// </summary>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Clear(this ushort[] @this) {
    Against.ThisIsNull(@this);
    MemoryMarshal.AsBytes(@this.AsSpan()).Clear();
  }

  /// <summary>
  /// Clears the short array by setting all elements to zero.
  /// </summary>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Clear(this short[] @this) {
    Against.ThisIsNull(@this);
    MemoryMarshal.AsBytes(@this.AsSpan()).Clear();
  }

  /// <summary>
  /// Clears the uint array by setting all elements to zero.
  /// </summary>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Clear(this uint[] @this) {
    Against.ThisIsNull(@this);
    MemoryMarshal.AsBytes(@this.AsSpan()).Clear();
  }

  /// <summary>
  /// Clears the int array by setting all elements to zero.
  /// </summary>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Clear(this int[] @this) {
    Against.ThisIsNull(@this);
    MemoryMarshal.AsBytes(@this.AsSpan()).Clear();
  }

  /// <summary>
  /// Clears the float array by setting all elements to zero.
  /// </summary>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Clear(this float[] @this) {
    Against.ThisIsNull(@this);
    MemoryMarshal.AsBytes(@this.AsSpan()).Clear();
  }

  /// <summary>
  /// Clears the ulong array by setting all elements to zero.
  /// </summary>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Clear(this ulong[] @this) {
    Against.ThisIsNull(@this);
    MemoryMarshal.AsBytes(@this.AsSpan()).Clear();
  }

  /// <summary>
  /// Clears the long array by setting all elements to zero.
  /// </summary>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Clear(this long[] @this) {
    Against.ThisIsNull(@this);
    MemoryMarshal.AsBytes(@this.AsSpan()).Clear();
  }

  /// <summary>
  /// Clears the double array by setting all elements to zero.
  /// </summary>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Clear(this double[] @this) {
    Against.ThisIsNull(@this);
    MemoryMarshal.AsBytes(@this.AsSpan()).Clear();
  }

  /// <summary>
  /// Clears memory at IntPtr by setting all bytes to zero.
  /// </summary>
  public static unsafe void Clear(this IntPtr @this, int count) {
    Against.ThisIsNull(@this);
    Against.CountBelowOrEqualZero(count);
    new Span<byte>((byte*)@this, count).Clear();
  }

  #endregion

  #region Tiled Bitwise Operations (narrow operand tiled across wider array)

  #region ushort[] with byte operand

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void And(this ushort[] @this, byte operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).And(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void And(this ushort[] @this, byte operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).And(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Or(this ushort[] @this, byte operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Or(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Or(this ushort[] @this, byte operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Or(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Xor(this ushort[] @this, byte operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Xor(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Xor(this ushort[] @this, byte operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Xor(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Nand(this ushort[] @this, byte operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Nand(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Nand(this ushort[] @this, byte operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Nand(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Nor(this ushort[] @this, byte operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Nor(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Nor(this ushort[] @this, byte operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Nor(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Equ(this ushort[] @this, byte operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Equ(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Equ(this ushort[] @this, byte operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Equ(operand);
  }

  #endregion

  #region uint[] with byte operand

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void And(this uint[] @this, byte operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).And(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void And(this uint[] @this, byte operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).And(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Or(this uint[] @this, byte operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Or(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Or(this uint[] @this, byte operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Or(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Xor(this uint[] @this, byte operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Xor(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Xor(this uint[] @this, byte operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Xor(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Nand(this uint[] @this, byte operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Nand(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Nand(this uint[] @this, byte operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Nand(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Nor(this uint[] @this, byte operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Nor(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Nor(this uint[] @this, byte operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Nor(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Equ(this uint[] @this, byte operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Equ(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Equ(this uint[] @this, byte operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Equ(operand);
  }

  #endregion

  #region uint[] with ushort operand

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void And(this uint[] @this, ushort operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).And(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void And(this uint[] @this, ushort operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).And(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Or(this uint[] @this, ushort operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Or(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Or(this uint[] @this, ushort operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Or(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Xor(this uint[] @this, ushort operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Xor(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Xor(this uint[] @this, ushort operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Xor(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Nand(this uint[] @this, ushort operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Nand(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Nand(this uint[] @this, ushort operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Nand(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Nor(this uint[] @this, ushort operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Nor(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Nor(this uint[] @this, ushort operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Nor(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Equ(this uint[] @this, ushort operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Equ(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Equ(this uint[] @this, ushort operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Equ(operand);
  }

  #endregion

  #region ulong[] with byte operand

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void And(this ulong[] @this, byte operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).And(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void And(this ulong[] @this, byte operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).And(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Or(this ulong[] @this, byte operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Or(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Or(this ulong[] @this, byte operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Or(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Xor(this ulong[] @this, byte operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Xor(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Xor(this ulong[] @this, byte operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Xor(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Nand(this ulong[] @this, byte operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Nand(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Nand(this ulong[] @this, byte operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Nand(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Nor(this ulong[] @this, byte operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Nor(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Nor(this ulong[] @this, byte operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Nor(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Equ(this ulong[] @this, byte operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Equ(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Equ(this ulong[] @this, byte operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Equ(operand);
  }

  #endregion

  #region ulong[] with ushort operand

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void And(this ulong[] @this, ushort operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).And(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void And(this ulong[] @this, ushort operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).And(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Or(this ulong[] @this, ushort operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Or(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Or(this ulong[] @this, ushort operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Or(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Xor(this ulong[] @this, ushort operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Xor(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Xor(this ulong[] @this, ushort operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Xor(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Nand(this ulong[] @this, ushort operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Nand(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Nand(this ulong[] @this, ushort operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Nand(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Nor(this ulong[] @this, ushort operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Nor(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Nor(this ulong[] @this, ushort operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Nor(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Equ(this ulong[] @this, ushort operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Equ(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Equ(this ulong[] @this, ushort operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Equ(operand);
  }

  #endregion

  #region ulong[] with uint operand

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void And(this ulong[] @this, uint operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).And(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void And(this ulong[] @this, uint operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).And(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Or(this ulong[] @this, uint operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Or(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Or(this ulong[] @this, uint operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Or(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Xor(this ulong[] @this, uint operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Xor(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Xor(this ulong[] @this, uint operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Xor(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Nand(this ulong[] @this, uint operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Nand(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Nand(this ulong[] @this, uint operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Nand(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Nor(this ulong[] @this, uint operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Nor(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Nor(this ulong[] @this, uint operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Nor(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Equ(this ulong[] @this, uint operand, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(0, count).Equ(operand);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Equ(this ulong[] @this, uint operand, int offset, int count) {
    Against.ThisIsNull(@this);
    @this.AsSpan(offset, count).Equ(operand);
  }

  #endregion

  #endregion

  #region Copy-blocks

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  private static unsafe void _CopyTo(byte* source, int srcIndex, byte* target, int tgtIndex, int count)
    => _CopyTo(source + srcIndex, target + tgtIndex, count)
  ;

  #if PLATFORM_X86
    
  <#=string.Join("\n  ", EmitUnsafeProcessor("_CopyTo(byte* source, byte* target, int count)", LINEAR_BLOCK_COUNTX86, INDEX_LOOP_UNROLL, new[]{ "source", "target" }, LINEAR_BLOCK_COUNTX86, c => EmitCopyBlock(c, LINEAR_BLOCK_COUNTX86)))#>
    
  #else
    
  <#=string.Join("\n  ", EmitUnsafeProcessor("_CopyTo(byte* source, byte* target, int count)", LINEAR_BLOCK_COUNTX64, INDEX_LOOP_UNROLL, new[]{ "source", "target" }, LINEAR_BLOCK_COUNTX64, c => EmitCopyBlock(c, LINEAR_BLOCK_COUNTX64)))#>
    
  #endif
        
  #endregion

}

<#+

struct TypeData {
  
  public string name;
  public int size;
  public bool useBlockCopyInsteadOfArrayCopy;
  public bool allowByteConversion;
  public bool noArraySupport;
  public bool hasHandcraftedCopyToMethod;
  public bool isUnsafeOnly;

  public bool NeedsCount => this.noArraySupport;
  public bool SupportsLength => !this.noArraySupport;
  public bool IsValueType => this.noArraySupport;
  public bool CanBeNull => !this.IsValueType;

}

double Log2(int i) => Math.Log(i) / Math.Log(2);

string EmitFastIntegerOperation(int i, string operationBase2, string operation) => EmitFastIntegerOperation(i, i => string.Format(operationBase2, i), i => string.Format(operation, i));

string EmitFastIntegerOperation(int i, Func<int, string> operationBase2, Func<int, string> operation) {
  var exponent = Log2(i);
  if(exponent == (int)exponent)
    return exponent == 0 ? string.Empty : operationBase2((int)exponent);
  else
    return operation(i);
}

string EmitFastIntegerMultiply(int i) => EmitFastIntegerOperation(i, " << {0}", " * {0}");
string EmitFastIntegerMultiply(string variable, int i) => EmitFastIntegerOperation(i, variable + " <<= {0}", variable + " *= {0}") + ";";
string EmitFastIntegerDivide(int i) => EmitFastIntegerOperation(i, " >> {0}", " / {0}");
string EmitFastIntegerDivide(string variable, int i) => EmitFastIntegerOperation(i, variable + " >>= {0}", variable + " /= {0}") + ";";
string EmitFastIntegerModulo(int i) => EmitFastIntegerOperation(i, i => " & " + (i == 1 ? "1" : "0b" + new string('1', i)), i => " % " + i);
string EmitFastIntegerModulo(string variable, int i) => EmitFastIntegerOperation(i, i => variable + " &= " + (i == 1 ? "1" : "0b" + new string('1', i)), i => variable + " %= " + i) + ";";

string EmitTypeDef(TypeData type) => type.noArraySupport ? type.name : type.name + "[]"; 

string GetDataTypeForByteCount(int sizeInBytes) {
  switch(sizeInBytes) {
    case 1:
      return "byte";
    case 2:
      return "ushort";
    case 4:
      return "uint";
    case 8:
      return "ulong";
    default:
      return $"Block{sizeInBytes}";
  }
}

string EmitIndexCopy(int i) => string.Format(@"target[tgtIndex{0}] = source[srcIndex{0}];", i == 0 ? string.Empty : " + " + i);

string EmitMarshalCopyByte(int i = 0)  => string.Format("Marshal.WriteByte(target, tgtIndex{0}, Marshal.ReadByte(source, srcIndex{0}));", i == 0 ? string.Empty : " + " + i);
string EmitMarshalCopyWord(int i = 0)  => string.Format("Marshal.WriteInt16(target, tgtIndex{0}, Marshal.ReadInt16(source, srcIndex{0}));", i == 0 ? string.Empty : " + " + i);
string EmitMarshalCopyDWord(int i = 0) => string.Format("Marshal.WriteInt32(target, tgtIndex{0}, Marshal.ReadInt32(source, srcIndex{0}));", i == 0 ? string.Empty : " + " + i);
string EmitMarshalCopyQWord(int i = 0) => string.Format("Marshal.WriteInt64(target, tgtIndex{0}, Marshal.ReadInt64(source, srcIndex{0}));", i == 0 ? string.Empty : " + " + i);
IEnumerable<string> EmitMarshalCopyBytes(int count) => EmitInlineBytes(count, EmitMarshalCopyByte, EmitMarshalCopyWord, EmitMarshalCopyDWord, EmitMarshalCopyQWord);

string EmitNegateByte(int i = 0) => i == 0 ? "*data = (byte)~*data;" : string.Format("data[{0}] = (byte)~data[{0}];", i);
string EmitNegateWord(int i = 0) => i == 0 ? "*(ushort*)data = (ushort)~*(ushort*)data;" : string.Format("((ushort*)data)[{0}] = (ushort)~((ushort*)data)[{0}];", i);
string EmitNegateDWord(int i = 0) => i == 0 ? "*(uint*)data = ~*(uint*)data;" : string.Format("((uint*)data)[{0}] = ~((uint*)data)[{0}];", i);
string EmitNegateQWord(int i = 0) => i == 0 ? "*(ulong*)data = ~*(ulong*)data;" : string.Format("((ulong*)data)[{0}] = ~((ulong*)data)[{0}];", i);
IEnumerable<string> EmitNegateBytes(int count) => EmitInlineBytes(count, EmitNegateByte, EmitNegateWord, EmitNegateDWord, EmitNegateQWord);
IEnumerable<string> EmitNegateBytes86(int count) => EmitInlineBytes(count, EmitNegateByte, EmitNegateWord, EmitNegateDWord);

string EmitAndByte(int i = 0) => i == 0 ? "*data &= *operand;" : string.Format("data[{0}] &= operand[{0}];", i);
string EmitAndWord(int i = 0) => i == 0 ? "*(ushort*)data &= *(ushort*)operand;" : string.Format("((ushort*)data)[{0}] &= ((ushort*)operand)[{0}];", i);
string EmitAndDWord(int i = 0) => i == 0 ? "*(uint*)data &= *(uint*)operand;" : string.Format("((uint*)data)[{0}] &= ((uint*)operand)[{0}];", i);
string EmitAndQWord(int i = 0) => i == 0 ? "*(ulong*)data &= *(ulong*)operand;" : string.Format("((ulong*)data)[{0}] &= ((ulong*)operand)[{0}];", i);
IEnumerable<string> EmitAndBytes(int count) => EmitInlineBytes(count, EmitAndByte, EmitAndWord, EmitAndDWord, EmitAndQWord);
IEnumerable<string> EmitAndBytes86(int count) => EmitInlineBytes(count, EmitAndByte, EmitAndWord, EmitAndDWord);

string EmitOrByte(int i = 0) => i == 0 ? "*data |= *operand;" : string.Format("data[{0}] |= operand[{0}];", i);
string EmitOrWord(int i = 0) => i == 0 ? "*(ushort*)data |= *(ushort*)operand;" : string.Format("((ushort*)data)[{0}] |= ((ushort*)operand)[{0}];", i);
string EmitOrDWord(int i = 0) => i == 0 ? "*(uint*)data |= *(uint*)operand;" : string.Format("((uint*)data)[{0}] |= ((uint*)operand)[{0}];", i);
string EmitOrQWord(int i = 0) => i == 0 ? "*(ulong*)data |= *(ulong*)operand;" : string.Format("((ulong*)data)[{0}] |= ((ulong*)operand)[{0}];", i);
IEnumerable<string> EmitOrBytes(int count) => EmitInlineBytes(count, EmitOrByte, EmitOrWord, EmitOrDWord, EmitOrQWord);
IEnumerable<string> EmitOrBytes86(int count) => EmitInlineBytes(count, EmitOrByte, EmitOrWord, EmitOrDWord);

string EmitXorByte(int i = 0) => i == 0 ? "*data ^= *operand;" : string.Format("data[{0}] ^= operand[{0}];", i);
string EmitXorWord(int i = 0) => i == 0 ? "*(ushort*)data ^= *(ushort*)operand;" : string.Format("((ushort*)data)[{0}] ^= ((ushort*)operand)[{0}];", i);
string EmitXorDWord(int i = 0) => i == 0 ? "*(uint*)data ^= *(uint*)operand;" : string.Format("((uint*)data)[{0}] ^= ((uint*)operand)[{0}];", i);
string EmitXorQWord(int i = 0) => i == 0 ? "*(ulong*)data ^= *(ulong*)operand;" : string.Format("((ulong*)data)[{0}] ^= ((ulong*)operand)[{0}];", i);
IEnumerable<string> EmitXorBytes(int count) => EmitInlineBytes(count, EmitXorByte, EmitXorWord, EmitXorDWord, EmitXorQWord);
IEnumerable<string> EmitXorBytes86(int count) => EmitInlineBytes(count, EmitXorByte, EmitXorWord, EmitXorDWord);

IEnumerable<string> EmitInlineBytes(int count, Func<int,string> emitByte,Func<int,string> emitWord = null,Func<int,string> emitDWord = null,Func<int,string> emitQWord = null) {
  var offset = 0;
  if (emitQWord != null)
    while(count >= 8) {
      yield return emitQWord(offset >> 3);
      count -= 8;
      offset += 8;
    }

  if(emitDWord != null)
    while(count >= 4) {
      yield return emitDWord(offset >> 2);
      count -= 4;
      offset += 4;
    }

  if(emitWord != null)
    while(count >= 2) {
      yield return emitWord(offset >> 1);
      count -= 2;
      offset += 2;
    }

  while (count >= 1) {
    yield return emitByte(offset);
    --count;
    ++offset;
  }
}

IEnumerable<string> EmitCopyBlock(int count,int maximumBlockSize) {
  var offset = 0;
  while (maximumBlockSize > 0 && count > 0) {
    if ( count < maximumBlockSize ) {
      --maximumBlockSize;  
      continue;
    }

    var needsByteOffset = offset % maximumBlockSize != 0;
    yield return EmitCopyBlockLine(maximumBlockSize, needsByteOffset ? offset : offset / maximumBlockSize, needsByteOffset);

    offset += maximumBlockSize;
    count -= maximumBlockSize;
  }
}

string EmitCopyBlockLine(int sizeInBytes, int index, bool isIndexInBytes) {
  if (sizeInBytes == 1)
    return index == 0 ? "*target = *source;" : string.Format("target[{1}] = source[{1}];", sizeInBytes, index);
  else {
    var dataType = GetDataTypeForByteCount(sizeInBytes);
    return index == 0 
      ? string.Format("*({0}*)target = *({0}*)source;", dataType) 
      : 
        isIndexInBytes
        ? string.Format("*(({0}*)(target + {1})) = *(({0}*)(source + {1}));", dataType, index)
        : string.Format("(({0}*)target)[{1}] = (({0}*)source)[{1}];", dataType, index)
    ;
  }
}


string EmitMarshalSetByte(int offset) => EmitMarshalSetByte(offset, null);
string EmitMarshalSetByte(string value) => EmitMarshalSetByte(0, value);
string EmitMarshalSetByte(int offset, string value) => string.Format("Marshal.WriteByte(@this, {0}{1});", offset == 0 ? string.Empty : offset + ", ", value ?? "0");

string EmitMarshalSetWord(int offset) => EmitMarshalSetWord(offset, null);
string EmitMarshalSetWord(string value) => EmitMarshalSetWord(0, value);
string EmitMarshalSetWord(int offset, string value) => string.Format("Marshal.WriteInt16(@this, {0}{1});", offset == 0 ? string.Empty : offset + ", ", value ?? "0");

string EmitMarshalSetDWord(int offset) => EmitMarshalSetDWord(offset, null);
string EmitMarshalSetDWord(string value) => EmitMarshalSetDWord(0, value);
string EmitMarshalSetDWord(int offset, string value) => string.Format("Marshal.WriteInt32(@this, {0}{1});", offset == 0 ? string.Empty : offset + ", ", value ?? "0");

string EmitMarshalSetQWord(int offset) => EmitMarshalSetQWord(offset, null);
string EmitMarshalSetQWord(string value) => EmitMarshalSetQWord(0, value);
string EmitMarshalSetQWord(int offset, string value) => string.Format("Marshal.WriteInt64(@this, {0}{1});", offset == 0 ? string.Empty : offset + ", ", value ?? "0");

IEnumerable<string> EmitMarshalSetBytes(int count) => EmitMarshalSetBytes(count, null);
IEnumerable<string> EmitMarshalSetBytes(int count, string value) {
  var offset = 0;

  if (count >= 8 ) {
    var reuseValue = value != null && count >= 16;
  
    if(reuseValue) {
      yield return "{";
      yield return "  var temp = (SBlock8)(0x0101010101010101UL * " + value + ");";
    }

    while (count >= 8) {
      yield return (reuseValue ? "  " : string.Empty) + EmitMarshalSetQWord(offset, reuseValue ? "temp" : value != null ? "(SBlock8)(0x0101010101010101UL * " + value + ")" : null);
      offset += 8;
      count-= 8;
    }

    if(reuseValue)
      yield return "}";
  }

  if (count >= 4) {
    yield return EmitMarshalSetDWord(offset, value != null ? "(SBlock4)(0x01010101U * " + value + ")" : null);
    offset += 4;
    count-= 4;
  }

  if (count >= 2) {
    yield return EmitMarshalSetWord(offset, value != null ? "(SBlock2)(0x0101 * " + value + ")" : null);
    offset += 2;
    count-= 2;
  }
  
  if(count > 0)
    yield return EmitMarshalSetByte(offset, value);
}

string EmitSetByte(int offset) => EmitSetByte(offset, null);
string EmitSetByte(string value) => EmitSetByte(0, value);
string EmitSetByte(int offset, string value) => string.Format("{0} = {1};", offset == 0 ? "*@this" : "@this[" + offset + "]", value ?? "0");

string EmitSetWord(int offset) => EmitSetWord(offset, null);
string EmitSetWord(string value) => EmitSetWord(0, value);
string EmitSetWord(int offset, string value) => string.Format("{0} = {1};", offset == 0 ? "*(ushort*)@this" : "*(ushort*)(@this + " + offset + ")", value ?? "0");

string EmitSetDWord(int offset) => EmitSetDWord(offset, null);
string EmitSetDWord(string value) => EmitSetDWord(0, value);
string EmitSetDWord(int offset, string value) => string.Format("{0} = {1};", offset == 0 ? "*(uint*)@this" : "*(uint*)(@this + " + offset + ")", value ?? "0");

string EmitSetQWord(int offset) => EmitSetQWord(offset, null);
string EmitSetQWord(string value) => EmitSetQWord(0, value);
string EmitSetQWord(int offset, string value) => string.Format("{0} = {1};", offset == 0 ? "*(ulong*)@this" : "*(ulong*)(@this + " + offset + ")", value ?? "0");

IEnumerable<string> EmitSetBytes(int count) => EmitSetBytes(count, null);
IEnumerable<string> EmitSetBytes(int count, string value) {
  var offset = 0;

  if (count >= 8 ) {
    var reuseValue = value != null && count >= 16;
  
    if(reuseValue) {
      yield return "{";
      yield return "  var temp = 0x0101010101010101UL * " + value + ";";
    }

    while (count >= 8) {
      yield return (reuseValue ? "  " : string.Empty) + EmitSetQWord(offset, reuseValue ? "temp" : value != null ? "0x0101010101010101UL * " + value : null);
      offset += 8;
      count-= 8;
    }

    if(reuseValue)
      yield return "}";
  }

  if (count >= 4) {
    yield return EmitSetDWord(offset, value != null ? "0x01010101U * " + value : null);
    offset += 4;
    count-= 4;
  }

  if (count >= 2) {
    yield return EmitSetWord(offset, value != null ? "(ushort)(0x0101 * " + value + ")": null);
    offset += 2;
    count-= 2;
  }
  
  if(count > 0)
    yield return EmitSetByte(offset, value);
}

IEnumerable<string> EmitUnsafeProcessor(string signature, int caseCount, int unrollCount, string[] variablesToIncrement, int byteBlockCount, Func<int, IEnumerable<string>> byteEmitter, int byteBlockCount86 = 0, Func<int, IEnumerable<string>> byteEmitter86 = null) {
  yield return "[MethodImpl(MethodImplOptions.AggressiveInlining)]";
  yield return "private static unsafe void " + signature + " {";
  yield return "  for(;;) {";
  yield return "    endOfBlocks: ;";
  yield return "    switch (count) {";
  yield return "      case 0: return;";
  for(var i = 1; i < caseCount; ++i) {
    yield return "      case " + i + ":";
    foreach(var line in byteEmitter(i))
      yield return "        " + line;

    yield return "        return;";
  }
  yield return "    }";
  
  foreach(var line in byteEmitter(caseCount))
    yield return "    " + line;
  
  yield return "    count -= " + caseCount + ";";
  yield return "    if (count <= 0) return;";
  foreach(var j in variablesToIncrement)
    yield return "    " + j + " += " + caseCount + ";";
  
  if (byteEmitter86 != null && byteBlockCount86 > 0) {
    yield return "    #if PLATFORM_X86";
    foreach(var line in EmitBlockProcess(byteBlockCount86, unrollCount, byteEmitter86, variablesToIncrement))
      yield return "      " + line;

    yield return "    #else";
  }

  foreach(var line in EmitBlockProcess(byteBlockCount, unrollCount, byteEmitter, variablesToIncrement))
    yield return "      " + line;

  if (byteEmitter86 != null)
    yield return "    #endif";

  yield return "  }";
  yield return "}";
}

IEnumerable<string> EmitBlockProcess(int size, int unrollCount, Func<int, IEnumerable<string>> byteEmitter, string[] variablesToIncrement) {
  yield return "var blockCount = count" + EmitFastIntegerDivide(size)+ ";";
  yield return EmitFastIntegerModulo("count", size);
  yield return "for (;;) {";
  yield return "  switch(blockCount) {";
  yield return "    case 0: goto endOfBlocks;";
  for(var i = 1; i <= unrollCount; ++i) {
    yield return "    case " + i + ":";
    foreach(var line in byteEmitter(i * size))
      yield return "      " + line;

    foreach(var j in variablesToIncrement)
      yield return "      " + j + " += " + (i * size) + ";";

    yield return "      goto endOfBlocks;";
  }
  yield return "  }";
  yield return "  do {";
  foreach(var line in byteEmitter(unrollCount * size))
    yield return "    " + line;

  foreach(var j in variablesToIncrement)
    yield return "    " + j + " += " + (unrollCount * size) + ";";

  yield return "    blockCount -= " + unrollCount + ";";
  yield return "  } while(blockCount >= " + unrollCount + ");";
  yield return "}";
}

string EmitThisNullCheck() => @"Against.ThisIsNull(@this);";
string EmitArgNullCheck(string paramName) => string.Format(@"Against.ArgumentIsNull({0});", paramName);

string EmitOffsetTooSmallCheck(string paramName) => string.Format(@"Against.IndexBelowZero({0});", paramName);
string EmitOffsetTooSmallCheck() => EmitOffsetTooSmallCheck("index");

string EmitOffsetTooLargeCheck(string paramName, string limit) => string.Format(@"Against.IndexOutOfRange({0}, {1});", paramName, limit);
string EmitOffsetTooLargeCheck(string limit) => EmitOffsetTooLargeCheck("index", limit);
string EmitOffsetTooLargeCheck() => EmitOffsetTooLargeCheck("length");

string EmitCountTooSmallCheck(string paramName) => string.Format(@"Against.CountBelowZero({0});", paramName);
string EmitCountTooSmallCheck() => EmitCountTooSmallCheck("count");

string EmitCountTooLargeCheck(string source, string length, string paramName) => string.Format(@"Against.CountOutOfRange({0}, {1}, expression: nameof({2}));", source, length, paramName);
string EmitCountTooLargeCheck(string source, string length) => EmitCountTooLargeCheck(source, length, source);
string EmitCountTooLargeCheck(string length) => EmitCountTooLargeCheck("count", length);
string EmitCountTooLargeCheck() => EmitCountTooLargeCheck("length");

string EmitMethodHeader(string returnType, string name, TypeData type) => string.Format("public static {0}{1} {2}({3}{4} @this", type.isUnsafeOnly ? "unsafe " : string.Empty, returnType, name, type.isUnsafeOnly ? string.Empty : "this ", EmitTypeDef(type));
string EmitMethodHeader(string name, TypeData type) => EmitMethodHeader(EmitTypeDef(type), name, type);

IEnumerable<string> EmitMethodHeader2(string returnType, string name, TypeData type) {
  yield return "[MethodImpl(MethodImplOptions.AggressiveInlining)]";
  yield return EmitMethodHeader(returnType, name, type);
}

IEnumerable<string> EmitMethodHeader2(string name, TypeData type) => EmitMethodHeader2(EmitTypeDef(type), name, type);

    

#>