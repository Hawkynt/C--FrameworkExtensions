<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
#region (c)2010-2042 Hawkynt

// This file is part of Hawkynt's .NET Framework extensions.
// 
// Hawkynt's .NET Framework extensions are free software:
// you can redistribute and/or modify it under the terms
// given in the LICENSE file.
// 
// Hawkynt's .NET Framework extensions is distributed in the hope that
// it will be useful, but WITHOUT ANY WARRANTY without even the implied
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the LICENSE file for more details.
// 
// You should have received a copy of the License along with Hawkynt's
// .NET Framework extensions. If not, see
// <https://github.com/Hawkynt/C--FrameworkExtensions/blob/master/LICENSE>.

#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */

using Guard;
using System.Drawing;
using System.Globalization;
using System.Text.RegularExpressions;
using System.Threading;
using System.Runtime.CompilerServices;
using MethodImplOptions = Utilities.MethodImplOptions;

// This file holds parsing routines to convert from normal strings to a certain primitive data type.
// ReSharper disable ExpressionIsAlwaysNull
namespace System;

public static partial class StringExtensions {
    
  #region Consts
  private const NumberStyles _STYLE_FLOAT = NumberStyles.Float | NumberStyles.AllowThousands;
  private const NumberStyles _STYLE_INT   = NumberStyles.Integer;
  #endregion

<#foreach(var i in new[]{
  Tuple.Create("Float","float","FLOAT"),
  Tuple.Create("Double","double","FLOAT"),
  Tuple.Create("Decimal","decimal","FLOAT"),
  Tuple.Create("Byte","byte","INT"),
  Tuple.Create("SByte","sbyte","INT"),
  Tuple.Create("Word","ushort","INT"),
  Tuple.Create("Short","short","INT"),
  Tuple.Create("DWord","uint","INT"),
  Tuple.Create("Int","int","INT"),
  Tuple.Create("QWord","ulong","INT"),
  Tuple.Create("Long","long","INT"),
}){#>

  #region Parsing <#=i.Item1#>
  #region Parse

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=i.Item2#> Parse<#=i.Item1#>(this string @this) {
    Against.ThisIsNull(@this);
    return <#=i.Item2#>.Parse(@this);
  }
   
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=i.Item2#> Parse<#=i.Item1#>(this ReadOnlySpan<char> @this) =>
#if SUPPORTS_SPAN
    <#=i.Item2#>.Parse(@this)
#else
    <#=i.Item2#>.Parse(@this.ToString())
#endif
  ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=i.Item2#> Parse<#=i.Item1#>(this string @this, IFormatProvider provider) {
    Against.ThisIsNull(@this);
    return <#=i.Item2#>.Parse(@this, provider);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=i.Item2#> Parse<#=i.Item1#>(this ReadOnlySpan<char> @this, IFormatProvider provider) => 
#if SUPPORTS_SPAN
    <#=i.Item2#>.Parse(@this, provider: provider)
#else
    <#=i.Item2#>.Parse(@this.ToString(), provider)
#endif
  ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=i.Item2#> Parse<#=i.Item1#>(this string @this, NumberStyles style) {
    Against.ThisIsNull(@this);
    return <#=i.Item2#>.Parse(@this, style);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=i.Item2#> Parse<#=i.Item1#>(this ReadOnlySpan<char> @this, NumberStyles style) => 
#if SUPPORTS_SPAN
    <#=i.Item2#>.Parse(@this, style)
#else
    <#=i.Item2#>.Parse(@this.ToString(), style)
#endif
  ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=i.Item2#> Parse<#=i.Item1#>(this string @this, NumberStyles style, IFormatProvider provider) {
    Against.ThisIsNull(@this);
    return <#=i.Item2#>.Parse(@this, style, provider);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=i.Item2#> Parse<#=i.Item1#>(this ReadOnlySpan<char> @this, NumberStyles style, IFormatProvider provider) => 
#if SUPPORTS_SPAN
    <#=i.Item2#>.Parse(@this, style, provider)
#else
    <#=i.Item2#>.Parse(@this.ToString(), style, provider)
#endif
  ;

  #endregion

  #region TryParse

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParse<#=i.Item1#>(this string @this, out <#=i.Item2#> result) {
    Against.ThisIsNull(@this);
    return <#=i.Item2#>.TryParse(@this, out result);
  }
  
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParse<#=i.Item1#>(this ReadOnlySpan<char> @this, out <#=i.Item2#> result) =>
#if SUPPORTS_SPAN
    <#=i.Item2#>.TryParse(@this, out result)
#else
    <#=i.Item2#>.TryParse(@this.ToString(), out result)
#endif
  ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParse<#=i.Item1#>(this string @this, IFormatProvider provider, out <#=i.Item2#> result) {
    Against.ThisIsNull(@this);
    return <#=i.Item2#>.TryParse(@this, _STYLE_<#=i.Item3#>, provider, out result);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParse<#=i.Item1#>(this ReadOnlySpan<char> @this, IFormatProvider provider, out <#=i.Item2#> result) => 
#if SUPPORTS_SPAN
    <#=i.Item2#>.TryParse(@this, _STYLE_<#=i.Item3#>, provider, out result)
#else
    <#=i.Item2#>.TryParse(@this.ToString(), _STYLE_<#=i.Item3#>, provider, out result)
#endif
  ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParse<#=i.Item1#>(this string @this, NumberStyles style, out <#=i.Item2#> result) {
    Against.ThisIsNull(@this);
    return <#=i.Item2#>.TryParse(@this, style, Thread.CurrentThread.CurrentCulture, out result);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParse<#=i.Item1#>(this ReadOnlySpan<char> @this, NumberStyles style, out <#=i.Item2#> result) => 
#if SUPPORTS_SPAN
    <#=i.Item2#>.TryParse(@this, style, Thread.CurrentThread.CurrentCulture, out result)
#else
    <#=i.Item2#>.TryParse(@this.ToString(), style, Thread.CurrentThread.CurrentCulture, out result)
#endif
  ;
    
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParse<#=i.Item1#>(this string @this, NumberStyles style, IFormatProvider provider, out <#=i.Item2#> result) {
    Against.ThisIsNull(@this);
    return <#=i.Item2#>.TryParse(@this, style, provider, out result);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParse<#=i.Item1#>(this ReadOnlySpan<char> @this, NumberStyles style, IFormatProvider provider, out <#=i.Item2#> result) => 
#if SUPPORTS_SPAN
    <#=i.Item2#>.TryParse(@this, style, provider, out result)
#else
    <#=i.Item2#>.TryParse(@this.ToString(), style, provider, out result)
#endif
  ;

  #endregion

  #region ParseOrDefault

<#=GenerateDefaultValueStubs(i.Item2,@"
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static "+i.Item2+@" Parse"+i.Item1+@"OrDefault(this string @this{0} {1})
    => @this == null ? {2} : TryParse"+i.Item1+@"(@this, out var result) ? result : {2}
    ;
")#>
<#=GenerateDefaultValueStubs(i.Item2,@"
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static "+i.Item2+@" Parse"+i.Item1+@"OrDefault(this ReadOnlySpan<char> @this{0} {1})
    => TryParse"+i.Item1+@"(@this, out var result) ? result : {2}
    ;
", true)#>
<#=GenerateDefaultValueStubs(i.Item2,@"
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static "+i.Item2+@" Parse"+i.Item1+@"OrDefault(this string @this, IFormatProvider provider{0} {1})
    => @this == null ? {2} : TryParse"+i.Item1+@"(@this, provider, out var result) ? result : {2}
    ;
")#>
<#=GenerateDefaultValueStubs(i.Item2,@"
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static "+i.Item2+@" Parse"+i.Item1+@"OrDefault(this ReadOnlySpan<char> @this, IFormatProvider provider{0} {1})
    => TryParse"+i.Item1+@"(@this, provider, out var result) ? result : {2}
    ;
", true)#>
<#=GenerateDefaultValueStubs(i.Item2,@"
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static "+i.Item2+@" Parse"+i.Item1+@"OrDefault(this string @this, NumberStyles style{0} {1})
    => @this == null ? {2} : TryParse"+i.Item1+@"(@this, style, out var result) ? result : {2}
    ;
")#>
<#=GenerateDefaultValueStubs(i.Item2,@"
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static "+i.Item2+@" Parse"+i.Item1+@"OrDefault(this ReadOnlySpan<char> @this, NumberStyles style{0} {1})
    => TryParse"+i.Item1+@"(@this, style, out var result) ? result : {2}
    ;
", true)#>
<#=GenerateDefaultValueStubs(i.Item2,@"
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static "+i.Item2+@" Parse"+i.Item1+@"OrDefault(this string @this, NumberStyles style, IFormatProvider provider{0} {1})
    => @this == null ? {2} : TryParse"+i.Item1+@"(@this, style, provider, out var result) ? result : {2}
    ;
")#>
<#=GenerateDefaultValueStubs(i.Item2,@"
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static "+i.Item2+@" Parse"+i.Item1+@"OrDefault(this ReadOnlySpan<char> @this, NumberStyles style, IFormatProvider provider{0} {1})
    => TryParse"+i.Item1+@"(@this, style, provider, out var result) ? result : {2}
    ;
", true)#>

  #endregion

  #region ParseOrNull

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=i.Item2#>? Parse<#=i.Item1#>OrNull(this string @this)
    => @this == null ? null : TryParse<#=i.Item1#>(@this, out var result) ? result : null
    ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=i.Item2#>? Parse<#=i.Item1#>OrNull(this ReadOnlySpan<char> @this)
    => TryParse<#=i.Item1#>(@this, out var result) ? result : null
    ;
    
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=i.Item2#>? Parse<#=i.Item1#>OrNull(this string @this, IFormatProvider provider)
    => @this == null ? null : TryParse<#=i.Item1#>(@this, provider, out var result) ? result : null
    ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=i.Item2#>? Parse<#=i.Item1#>OrNull(this ReadOnlySpan<char> @this, IFormatProvider provider)
    => TryParse<#=i.Item1#>(@this, provider, out var result) ? result : null
    ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=i.Item2#>? Parse<#=i.Item1#>OrNull(this string @this, NumberStyles style)
    => @this == null ? null : TryParse<#=i.Item1#>(@this, style, out var result) ? result : null
    ;
  
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=i.Item2#>? Parse<#=i.Item1#>OrNull(this ReadOnlySpan<char> @this, NumberStyles style)
    => TryParse<#=i.Item1#>(@this, style, out var result) ? result : null
    ;
    
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=i.Item2#>? Parse<#=i.Item1#>OrNull(this string @this, NumberStyles style, IFormatProvider provider)
    => @this == null ? null : TryParse<#=i.Item1#>(@this, style, provider, out var result) ? result : null
    ;
  
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=i.Item2#>? Parse<#=i.Item1#>OrNull(this ReadOnlySpan<char> @this, NumberStyles style, IFormatProvider provider)
    => TryParse<#=i.Item1#>(@this, style, provider, out var result) ? result : null
    ;

  #endregion
  #endregion

<#}#>

  #region Parsing TimeSpan
  #region Parse
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static TimeSpan ParseTimeSpan(this string @this) {
    Against.ThisIsNull(@this);
    return TimeSpan.Parse(@this);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static TimeSpan ParseTimeSpan(this ReadOnlySpan<char> @this) =>
#if SUPPORTS_SPAN
    TimeSpan.Parse(@this)
#else
    TimeSpan.Parse(@this.ToString())
#endif
  ;

#if SUPPORTS_TIMESPAN_PROVIDER

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static TimeSpan ParseTimeSpan(this string @this, IFormatProvider provider) {
    Against.ThisIsNull(@this);
    return TimeSpan.Parse(@this, provider);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static TimeSpan ParseTimeSpan(this ReadOnlySpan<char> @this, IFormatProvider provider) =>
#if SUPPORTS_SPAN
    TimeSpan.Parse(@this, provider)
#else
    TimeSpan.Parse(@this.ToString(), provider)
#endif
  ;

#endif
  #endregion

  #region TryParse
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParseTimeSpan(this string @this, out TimeSpan result) => TimeSpan.TryParse(@this, out result);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParseTimeSpan(this ReadOnlySpan<char> @this, out TimeSpan result) => 
#if SUPPORTS_SPAN
    TimeSpan.TryParse(@this, out result)
#else
    TimeSpan.TryParse(@this.ToString(), out result)
#endif  
  ;

#if SUPPORTS_TIMESPAN_PROVIDER

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParseTimeSpan(this string @this, IFormatProvider provider, out TimeSpan result) => TimeSpan.TryParse(@this, provider, out result);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#if SUPPORTS_SPAN
  public static bool TryParseTimeSpan(this ReadOnlySpan<char> @this, IFormatProvider provider, out TimeSpan result) => TimeSpan.TryParse(@this, provider, out result);
#else
  public static bool TryParseTimeSpan(this ReadOnlySpan<char> @this, IFormatProvider provider, out TimeSpan result) => TimeSpan.TryParse(@this.ToString(), provider, out result);
#endif

#endif

  #endregion

  #region ParseOrDefault
<#=GenerateDefaultValueStubs("TimeSpan",@"
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static TimeSpan ParseTimeSpanOrDefault(this string @this{0} {1})
    => @this == null ? {2} : TryParseTimeSpan(@this, out var result) ? result : {2}
    ;
")#>
<#=GenerateDefaultValueStubs("TimeSpan",@"
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static TimeSpan ParseTimeSpanOrDefault(this ReadOnlySpan<char> @this{0} {1})
    => TryParseTimeSpan(@this, out var result) ? result : {2}
    ;
", true)#>

#if SUPPORTS_TIMESPAN_PROVIDER

<#=GenerateDefaultValueStubs("TimeSpan",@"
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static TimeSpan ParseTimeSpanOrDefault(this string @this, IFormatProvider provider{0} {1})
    => @this == null ? {2} : TryParseTimeSpan(@this, provider, out var result) ? result : {2}
    ;
")#>
<#=GenerateDefaultValueStubs("TimeSpan",@"
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static TimeSpan ParseTimeSpanOrDefault(this ReadOnlySpan<char> @this, IFormatProvider provider{0} {1})
    => TryParseTimeSpan(@this, provider, out var result) ? result : {2}
    ;
", true)#>

#endif

  #endregion

  #region ParseOrNull
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static TimeSpan? ParseTimeSpanOrNull(this string @this)
    => @this == null ? null : TryParseTimeSpan(@this, out var result) ? result : null
    ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static TimeSpan? ParseTimeSpanOrNull(this ReadOnlySpan<char> @this)
    => TryParseTimeSpan(@this, out var result) ? result : null
    ;

#if SUPPORTS_TIMESPAN_PROVIDER

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static TimeSpan? ParseTimeSpanOrNull(this string @this, IFormatProvider provider)
    => @this == null ? null : TryParseTimeSpan(@this, provider, out var result) ? result : null
    ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static TimeSpan? ParseTimeSpanOrNull(this ReadOnlySpan<char> @this, IFormatProvider provider)
    => TryParseTimeSpan(@this, provider, out var result) ? result : null
    ;

#endif


  #endregion
  #endregion

  #region Parsing DateTime
  #region Parse
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime ParseDateTime(this string @this) {
    Against.ThisIsNull(@this);
    return DateTime.Parse(@this);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime ParseDateTime(this ReadOnlySpan<char> @this) =>
#if SUPPORTS_SPAN
    DateTime.Parse(@this)
#else
    DateTime.Parse(@this.ToString())
#endif
  ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime ParseDateTime(this string @this, IFormatProvider provider) {
    Against.ThisIsNull(@this);
    return DateTime.Parse(@this, provider);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime ParseDateTime(this ReadOnlySpan<char> @this, IFormatProvider provider) =>
#if SUPPORTS_SPAN
    DateTime.Parse(@this, provider)
#else
    DateTime.Parse(@this.ToString(), provider)
#endif
  ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime ParseDateTime(this string @this, string exactFormat) {
    Against.ThisIsNull(@this);
    return DateTime.ParseExact(@this, exactFormat, Thread.CurrentThread.CurrentCulture, DateTimeStyles.None);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime ParseDateTime(this ReadOnlySpan<char> @this, string exactFormat) =>
#if SUPPORTS_SPAN
    DateTime.ParseExact(@this, exactFormat, Thread.CurrentThread.CurrentCulture)
#else
    DateTime.ParseExact(@this.ToString(), exactFormat, Thread.CurrentThread.CurrentCulture, DateTimeStyles.None)
#endif
  ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime ParseDateTime(this string @this, string exactFormat, IFormatProvider provider) {
    Against.ThisIsNull(@this);
    return DateTime.ParseExact(@this, exactFormat, provider, DateTimeStyles.None);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime ParseDateTime(this ReadOnlySpan<char> @this, string exactFormat, IFormatProvider provider) =>
#if SUPPORTS_SPAN
    DateTime.ParseExact(@this, exactFormat, provider)
#else
    DateTime.ParseExact(@this.ToString(), exactFormat, provider, DateTimeStyles.None)
#endif
  ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime ParseDateTime(this string @this, string exactFormat, DateTimeStyles style) {
    Against.ThisIsNull(@this);
    return DateTime.ParseExact(@this, exactFormat, Thread.CurrentThread.CurrentCulture, style);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime ParseDateTime(this ReadOnlySpan<char> @this, string exactFormat, DateTimeStyles style) =>
#if SUPPORTS_SPAN
    DateTime.ParseExact(@this, exactFormat, Thread.CurrentThread.CurrentCulture, style)
#else
    DateTime.ParseExact(@this.ToString(), exactFormat, Thread.CurrentThread.CurrentCulture, style)
#endif
  ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime ParseDateTime(this string @this, string exactFormat, DateTimeStyles style, IFormatProvider provider) {
    Against.ThisIsNull(@this);
    return DateTime.ParseExact(@this, exactFormat, provider, style);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime ParseDateTime(this ReadOnlySpan<char> @this, string exactFormat, DateTimeStyles style, IFormatProvider provider) =>
#if SUPPORTS_SPAN
    DateTime.ParseExact(@this, exactFormat, provider, style)
#else
    DateTime.ParseExact(@this.ToString(), exactFormat, provider, style)
#endif
  ;

  #endregion

  #region TryParse
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParseDateTime(this string @this, out DateTime result) {
    Against.ThisIsNull(@this);
    return DateTime.TryParse(@this, out result);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParseDateTime(this ReadOnlySpan<char> @this, out DateTime result) =>
#if SUPPORTS_SPAN
    DateTime.TryParse(@this, out result)
#else
    DateTime.TryParse(@this.ToString(), out result)
#endif
  ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParseDateTime(this string @this, IFormatProvider provider, out DateTime result) {
    Against.ThisIsNull(@this);
    return DateTime.TryParse(@this, provider, DateTimeStyles.None, out result);
  }

[MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParseDateTime(this ReadOnlySpan<char> @this, IFormatProvider provider, out DateTime result) =>
#if SUPPORTS_SPAN
    DateTime.TryParse(@this, provider, DateTimeStyles.None, out result)
#else
    DateTime.TryParse(@this.ToString(), provider, DateTimeStyles.None, out result)
#endif
  ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParseDateTime(this string @this, DateTimeStyles style, out DateTime result) {
    Against.ThisIsNull(@this);
    return DateTime.TryParse(@this, Thread.CurrentThread.CurrentCulture,style, out result);
  }
        
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParseDateTime(this ReadOnlySpan<char> @this, DateTimeStyles style, out DateTime result) =>
#if SUPPORTS_SPAN
    DateTime.TryParse(@this, Thread.CurrentThread.CurrentCulture,style, out result)
#else
    DateTime.TryParse(@this.ToString(), Thread.CurrentThread.CurrentCulture,style, out result)
#endif
  ;
        
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParseDateTime(this string @this, string exactFormat, out DateTime result) {
    Against.ThisIsNull(@this);
    return DateTime.TryParseExact(@this, exactFormat, Thread.CurrentThread.CurrentCulture,DateTimeStyles.None, out result);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParseDateTime(this ReadOnlySpan<char> @this, string exactFormat, out DateTime result) =>
#if SUPPORTS_SPAN
    DateTime.TryParseExact(@this, exactFormat, Thread.CurrentThread.CurrentCulture,DateTimeStyles.None, out result)
#else
    DateTime.TryParseExact(@this.ToString(), exactFormat, Thread.CurrentThread.CurrentCulture,DateTimeStyles.None, out result)
#endif
  ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParseDateTime(this string @this, string exactFormat, DateTimeStyles style, out DateTime result) {
    Against.ThisIsNull(@this);
    return DateTime.TryParseExact(@this, exactFormat, Thread.CurrentThread.CurrentCulture, style, out result);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParseDateTime(this ReadOnlySpan<char> @this, string exactFormat, DateTimeStyles style, out DateTime result) =>
#if SUPPORTS_SPAN
    DateTime.TryParseExact(@this, exactFormat, Thread.CurrentThread.CurrentCulture, style, out result)
#else
    DateTime.TryParseExact(@this.ToString(), exactFormat, Thread.CurrentThread.CurrentCulture, style, out result)
#endif
  ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParseDateTime(this string @this, string exactFormat, IFormatProvider provider, out DateTime result) {
    Against.ThisIsNull(@this);
    return DateTime.TryParseExact(@this, exactFormat, provider, DateTimeStyles.None, out result);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParseDateTime(this ReadOnlySpan<char> @this, string exactFormat, IFormatProvider provider, out DateTime result) =>
#if SUPPORTS_SPAN
    DateTime.TryParseExact(@this, exactFormat, provider, DateTimeStyles.None, out result)
#else
    DateTime.TryParseExact(@this.ToString(), exactFormat, provider, DateTimeStyles.None, out result)
#endif
  ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParseDateTime(this string @this, string exactFormat, DateTimeStyles style, IFormatProvider provider, out DateTime result) {
    Against.ThisIsNull(@this);
    return DateTime.TryParseExact(@this, exactFormat, provider, style, out result);
  }
    
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParseDateTime(this ReadOnlySpan<char> @this, string exactFormat, DateTimeStyles style, IFormatProvider provider, out DateTime result) =>
#if SUPPORTS_SPAN
    DateTime.TryParseExact(@this, exactFormat, provider, style, out result)
#else
    DateTime.TryParseExact(@this.ToString(), exactFormat, provider, style, out result)
#endif
  ;
    
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParseDateTime(this string @this, DateTimeStyles style, IFormatProvider provider, out DateTime result) {
    Against.ThisIsNull(@this);
    return DateTime.TryParse(@this, provider, style, out result);
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParseDateTime(this ReadOnlySpan<char> @this, DateTimeStyles style, IFormatProvider provider, out DateTime result) =>
 # if SUPPORTS_SPAN
    DateTime.TryParse(@this, provider, style, out result)
#else
    DateTime.TryParse(@this.ToString(), provider, style, out result)
#endif
  ;

  #endregion

  #region ParseOrDefault

<#=GenerateDefaultValueStubs("DateTime",@"
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime ParseDateTimeOrDefault(this string @this{0} {1})
    => @this == null ? {2} : TryParseDateTime(@this, out var result) ? result : {2}
    ;
")#>
<#=GenerateDefaultValueStubs("DateTime",@"
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime ParseDateTimeOrDefault(this ReadOnlySpan<char> @this{0} {1})
    => TryParseDateTime(@this, out var result) ? result : {2}
    ;
", true)#>
<#=GenerateDefaultValueStubs("DateTime",@"    
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime ParseDateTimeOrDefault(this string @this, IFormatProvider provider{0} {1})
    => @this == null ? {2} : TryParseDateTime(@this, provider, out var result) ? result : {2}
    ;
")#>
<#=GenerateDefaultValueStubs("DateTime",@"    
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime ParseDateTimeOrDefault(this ReadOnlySpan<char> @this, IFormatProvider provider{0} {1})
    => TryParseDateTime(@this, provider, out var result) ? result : {2}
    ;
", true)#>
<#=GenerateDefaultValueStubs("DateTime",@"
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime ParseDateTimeOrDefault(this string @this, DateTimeStyles style{0} {1})
    => @this == null ? {2} : TryParseDateTime(@this, style, out var result) ? result : {2}
    ;
")#>
<#=GenerateDefaultValueStubs("DateTime",@"
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime ParseDateTimeOrDefault(this ReadOnlySpan<char> @this, DateTimeStyles style{0} {1})
    => TryParseDateTime(@this, style, out var result) ? result : {2}
    ;
", true)#>
<#=GenerateDefaultValueStubs("DateTime",@"
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime ParseDateTimeOrDefault(this string @this, string exactFormat{0} {1})
    => @this == null ? {2} : TryParseDateTime(@this,exactFormat, out var result) ? result : {2}
    ;
")#>
<#=GenerateDefaultValueStubs("DateTime",@"
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime ParseDateTimeOrDefault(this ReadOnlySpan<char> @this, string exactFormat{0} {1})
    => TryParseDateTime(@this,exactFormat, out var result) ? result : {2}
    ;
", true)#>
<#=GenerateDefaultValueStubs("DateTime",@"
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime ParseDateTimeOrDefault(this string @this, DateTimeStyles style, IFormatProvider provider{0} {1})
    => @this == null ? {2} : TryParseDateTime(@this, style, provider, out var result) ? result : {2}
    ;
")#>
<#=GenerateDefaultValueStubs("DateTime",@"
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime ParseDateTimeOrDefault(this ReadOnlySpan<char> @this, DateTimeStyles style, IFormatProvider provider{0} {1})
    => TryParseDateTime(@this, style, provider, out var result) ? result : {2}
    ;
", true)#>
  #endregion

  #region ParseOrNull
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime? ParseDateTimeOrNull(this string @this)
    => @this == null ? null : TryParseDateTime(@this, out var result) ? result : null
    ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime? ParseDateTimeOrNull(this ReadOnlySpan<char> @this)
    => TryParseDateTime(@this, out var result) ? result : null
    ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime? ParseDateTimeOrNull(this string @this, IFormatProvider provider)
    => @this == null ? null : TryParseDateTime(@this, provider, out var result) ? result : null
    ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime? ParseDateTimeOrNull(this ReadOnlySpan<char> @this, IFormatProvider provider)
    => TryParseDateTime(@this, provider, out var result) ? result : null
    ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime? ParseDateTimeOrNull(this string @this, DateTimeStyles style)
    => @this == null ? null : TryParseDateTime(@this, style, out var result) ? result : null
    ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime? ParseDateTimeOrNull(this ReadOnlySpan<char> @this, DateTimeStyles style)
    =>  TryParseDateTime(@this, style, out var result) ? result : null
    ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime? ParseDateTimeOrNull(this string @this, string exactFormat)
    => @this == null ? null : TryParseDateTime(@this, exactFormat, out var result) ? result : null
    ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime? ParseDateTimeOrNull(this ReadOnlySpan<char> @this, string exactFormat)
    => TryParseDateTime(@this, exactFormat, out var result) ? result : null
    ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime? ParseDateTimeOrNull(this string @this, DateTimeStyles style, IFormatProvider provider)
    => @this == null ? null : TryParseDateTime(@this, style, provider, out var result) ? result : null
    ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static DateTime? ParseDateTimeOrNull(this ReadOnlySpan<char> @this, DateTimeStyles style, IFormatProvider provider)
    => TryParseDateTime(@this, style, provider, out var result) ? result : null
    ;

  #endregion
  #endregion

  #region Parsing Boolean
  #region Parse

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool ParseBoolean(this string @this, string trueValue)
    => @this == trueValue
    ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool ParseBoolean(this string @this, string trueValue, StringComparison stringComparison)
    => string.Equals(@this, trueValue, stringComparison)
    ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool ParseBoolean(this string @this, string trueValue, string falseValue)
    => @this switch {
      _ when @this == trueValue => true,
      _ when @this == falseValue => false,
      _ => throw new ArgumentException($"{@this} is an unsupported value.")
    };

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool ParseBoolean(this string @this, string trueValue, string falseValue, StringComparison stringComparison)
    => @this switch {
      _ when string.Equals(@this, trueValue, stringComparison) => true,
      _ when string.Equals(@this, falseValue, stringComparison) => false,
      _ => throw new ArgumentException($"{@this} is an unsupported value.")
    };

  #endregion

  #region TryParse

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParseBoolean(this string @this, string trueValue, string falseValue, out bool result) {
    if (@this == trueValue) {
      result = true;
      return true;
    }

    if (@this == falseValue) {
      result = false;
      return true;
    }

    result = default;
    return false;
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParseBoolean(this string @this, string trueValue, string falseValue, StringComparison stringComparison, out bool result) {
    if (string.Equals(@this, trueValue, stringComparison)) {
      result = true;
      return true;
    }

    if (string.Equals(@this, falseValue, stringComparison)) {
      result = false;
      return true;
    }

    result = default;
    return false;
  }

  #endregion

  #region ParseOrDefault
    <#=GenerateDefaultValueStubs("bool",@"
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool ParseBooleanOrDefault(this string @this, string trueValue, string falseValue{0} {1})
    => @this switch {{
      _ when @this == trueValue => true,
      _ when @this == falseValue => false,
      _ => {2}
    }};    
")#>

    <#=GenerateDefaultValueStubs("bool",@"
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool ParseBooleanOrDefault(this string @this, string trueValue, string falseValue, StringComparison stringComparison{0} {1})
    => @this switch {{
      _ when string.Equals(@this, trueValue, stringComparison) => true,
      _ when string.Equals(@this, falseValue, stringComparison) => false,
      _ => {2}
    }};
")#>

  #endregion

  #region ParseOrNull

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool? ParseBooleanOrNull(this string @this, string trueValue, string falseValue)
     => @this switch {
      _ when @this == trueValue => true,
      _ when @this == falseValue => false,
      _ => null
    };

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool? ParseBooleanOrNull(this string @this, string trueValue, string falseValue, StringComparison stringComparison)
    => @this switch {
      _ when string.Equals(@this, trueValue, stringComparison) => true,
      _ when string.Equals(@this, falseValue, stringComparison) => false,
      _ => null
    };

  #endregion
  #endregion

  #region Parsing Color
  
  #region Parse

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static Color ParseColor(this string @this) {
    if(TryParseColor(@this, out var result))
      return result;

    AlwaysThrow.ArgumentException(nameof(@this), "Unknown color, expecting #AARRGGBB, #RRGGBB, #ARGB, #RGB, knowncolorname, r,g,b (0-255), a,r,g,b (0-255), rgb (0.0-1.0), argb (0.0-1.0) or 'systemcolorname'", nameof(@this));
    return default;
  }

  #endregion

  #region TryParse

  public static bool TryParseColor(this string @this, out Color result) => (__tryParseColor ??= new()).Invoke(@this, out result);
  private static __TryParseColor __tryParseColor;
  private sealed class __TryParseColor {

    private const string _hexNum = "[0-9a-f]";
    private const string _byteNum = "(?:0*?(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))";
    private const string _floatNum = @"(?:0|0\.[0-9]+|1\.0)";
    private const string _comma = @"\s*,\s*";
    private const string _hex3 = _hexNum + _hexNum + _hexNum;
    private const string _hex4 = _hexNum + _hex3;
    private const string _hex6 = _hex3 + _hex3;
    private const string _hex8 = _hex4 + _hex4;
    private const string _byte3 = _byteNum + _comma + _byteNum + _comma + _byteNum;
    private const string _byte4 = _byteNum + _comma + _byte3;
    private const string _float3 = _floatNum + _comma + _floatNum + _comma + _floatNum;
    private const string _float4 = _floatNum + _comma + _float3;
    private const string _freeText = "[a-z]+";

    private const string _pattern =
      @"^\s*(?:" +
      "|(?:#(?<eightdigit>" + _hex8 + "))" +
      "|(?:#(?<sixdigit>" + _hex6 + "))" +
      "|(?:#(?<fourdigit>" + _hex4 + "))" +
      "|(?:#(?<threedigit>" + _hex3 + "))" +
      "|(?:'(?<systemcolor>" + _freeText + "'))" +
      "|(?<argbbytes>" + _byte4 + ")" +
      "|(?<rgbbytes>" + _byte3 + ")" +
      "|(?<argbfloats>" + _float4 + ")" +
      "|(?<rgbfloats>" + _float3 + ")" +
      "|(?<knowncolor>" + _freeText + ")" +
      @")\s*$"
      ;

    private readonly struct ParserHandler(string groupName, Func<string, Color> parser) {
      public bool TryParse(Match match, out Color result) {
        var group = match.Groups[groupName];
        switch (group.Success) {
          case true:
            result = parser(group.Value);
            return true;
          default:
            result = default;
            return false;
        }
      }
    }

    private readonly Regex _colorMatch = new(_pattern, RegexOptions.Compiled | RegexOptions.IgnoreCase);

    private readonly ParserHandler[] _colorParsers = [
      new("eightdigit", v => Color.FromArgb(
        ConvertHexToByte(v[0], v[1]),
        ConvertHexToByte(v[2], v[3]),
        ConvertHexToByte(v[4], v[5]),
        ConvertHexToByte(v[6], v[7])
      )),
      new("sixdigit", v => Color.FromArgb(
        ConvertHexToByte(v[0], v[1]),
        ConvertHexToByte(v[2], v[3]),
        ConvertHexToByte(v[4], v[5])
      )),
      new("fourdigit", v => Color.FromArgb(
        ConvertHexToByte(v[0], v[0]),
        ConvertHexToByte(v[1], v[1]),
        ConvertHexToByte(v[2], v[2]),
        ConvertHexToByte(v[3], v[3])
      )),
      new("threedigit", v => Color.FromArgb(
        ConvertHexToByte(v[0], v[0]),
        ConvertHexToByte(v[1], v[1]),
        ConvertHexToByte(v[2], v[2])
      )),
      new("knowncolor", Color.FromName),
      new("systemcolor", Color.FromName),
      new("argbbytes", v => {
        var parts = v.Split(',');
        return Color.FromArgb(int.Parse(parts[0], CultureInfo.InvariantCulture), int.Parse(parts[1], CultureInfo.InvariantCulture), int.Parse(parts[2], CultureInfo.InvariantCulture), int.Parse(parts[3], CultureInfo.InvariantCulture));
      }),
      new("rgbbytes", v => {
        var parts = v.Split(',');
        return Color.FromArgb(int.Parse(parts[0], CultureInfo.InvariantCulture), int.Parse(parts[1], CultureInfo.InvariantCulture), int.Parse(parts[2], CultureInfo.InvariantCulture));
      }),
      new("argbfloats", v => {
        var parts = v.Split(',');
        return Color.FromArgb((int)(255 * double.Parse(parts[0], CultureInfo.InvariantCulture)), (int)(255 * double.Parse(parts[1], CultureInfo.InvariantCulture)), (int)(255 * double.Parse(parts[2], CultureInfo.InvariantCulture)), (int)(255 * double.Parse(parts[3], CultureInfo.InvariantCulture)));
      }),
      new("rgbfloats", v => {
        var parts = v.Split(',');
        return Color.FromArgb((int)(255 * double.Parse(parts[0], CultureInfo.InvariantCulture)), (int)(255 * double.Parse(parts[1], CultureInfo.InvariantCulture)), (int)(255 * double.Parse(parts[2], CultureInfo.InvariantCulture)));
      }),
    ];
  
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool Invoke(string @this, out Color result) {
      var match = this._colorMatch.Match(@this);
      
      // ReSharper disable once InvertIf
      if (match.Success)
        foreach (var parserHandler in this._colorParsers)
          if (parserHandler.TryParse(match, out result))
            return true;

      result = default;
      return false;
    }

  }

  #endregion

  #region ParseOrDefault

    <#=GenerateDefaultValueStubs("Color",@"
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static Color ParseColorOrDefault(this string @this{0} {1}) => TryParseColor(@this, out var result) ? result : {2};
")#>

  #endregion

  #region ParseOrNull

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static Color? ParseColorOrNull(this string @this) => TryParseColor(@this, out var result) ? result : null;

  #endregion

  #endregion

  #region Enum

  #region Parse

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static TEnum ParseEnum<TEnum>(this string @this) where TEnum: struct => (TEnum)Enum.Parse(typeof(TEnum), @this);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static TEnum ParseEnum<TEnum>(this string @this, bool ignoreCase) where TEnum: struct => (TEnum)Enum.Parse(typeof(TEnum), @this, ignoreCase);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static TEnum ParseEnum<TEnum>(this ReadOnlySpan<char> @this) where TEnum: struct =>
#if SUPPORTS_ENUM_PARSE_SPAN
    Enum.Parse<TEnum>(@this)
#else
    (TEnum)Enum.Parse(typeof(TEnum), @this.ToString())
#endif
  ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static TEnum ParseEnum<TEnum>(this ReadOnlySpan<char> @this, bool ignoreCase) where TEnum: struct =>
#if SUPPORTS_ENUM_PARSE_SPAN
    Enum.Parse<TEnum>(@this, ignoreCase)
#else
    (TEnum)Enum.Parse(typeof(TEnum), @this.ToString(), ignoreCase)
#endif
  ;

  #endregion

  #region TryParse
    
#if SUPPORTS_ENUM_TRYPARSE

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParseEnum<TEnum>(this string @this, out TEnum result) where TEnum: struct => Enum.TryParse(@this, out result);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParseEnum<TEnum>(this string @this, bool ignoreCase, out TEnum result) where TEnum: struct => Enum.TryParse(@this, ignoreCase, out result);

#else

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParseEnum<TEnum>(this string @this, out TEnum result) where TEnum: struct => TryParseEnum(@this, false, out result);

  public static bool TryParseEnum<TEnum>(this string @this, bool ignoreCase, out TEnum result) where TEnum: struct {
    try {  
      result = (TEnum)Enum.Parse(typeof(TEnum), @this, ignoreCase);
      return true;
    } catch (Exception) {
      result = default;
      return false;
    }
  }

#endif
  
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParseEnum<TEnum>(this ReadOnlySpan<char> @this, out TEnum result) where TEnum: struct =>
#if SUPPORTS_ENUM_PARSE_SPAN
    Enum.TryParse(@this, out result)
#else
    TryParseEnum(@this.ToString(), out result)
#endif
  ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool TryParseEnum<TEnum>(this ReadOnlySpan<char> @this, bool ignoreCase, out TEnum result) where TEnum: struct =>
#if SUPPORTS_ENUM_PARSE_SPAN
    Enum.TryParse(@this, ignoreCase, out result)
#else
    TryParseEnum(@this.ToString(), ignoreCase, out result)
#endif
  ;

  #endregion

  #region ParseOrDefault

  <#=GenerateDefaultValueStubs("TEnum",@"
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static TEnum ParseEnumOrDefault<TEnum>(this string @this{0} {1}) where TEnum: struct => TryParseEnum(@this, out TEnum result) ? result : {2};
")#>

  <#=GenerateDefaultValueStubs("TEnum",@"
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static TEnum ParseEnumOrDefault<TEnum>(this string @this, bool ignoreCase{0} {1}) where TEnum: struct => TryParseEnum(@this, ignoreCase, out TEnum result) ? result : {2};
")#>

  <#=GenerateDefaultValueStubs("TEnum",@"
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static TEnum ParseEnumOrDefault<TEnum>(this ReadOnlySpan<char> @this{0} {1}) where TEnum: struct =>
#if SUPPORTS_ENUM_PARSE_SPAN
    Enum.TryParse(@this, out TEnum result)
#else
    TryParseEnum(@this.ToString(), out TEnum result)
#endif
    ? result 
    : {2}
    ;
", true)#>

  <#=GenerateDefaultValueStubs("TEnum",@"
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static TEnum ParseEnumOrDefault<TEnum>(this ReadOnlySpan<char> @this, bool ignoreCase{0} {1}) where TEnum: struct => 
#if SUPPORTS_ENUM_PARSE_SPAN
    Enum.TryParse(@this, ignoreCase, out TEnum result)
#else
    TryParseEnum(@this.ToString(), ignoreCase, out TEnum result)
#endif
    ? result 
    : {2}
    ;
", true)#>

  #endregion

  #region ParseOrNull

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static TEnum? ParseEnumOrNull<TEnum>(this string @this) where TEnum: struct => TryParseEnum(@this, out TEnum result) ? result : null;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static TEnum? ParseEnumOrNull<TEnum>(this string @this, bool ignoreCase) where TEnum: struct => TryParseEnum(@this, ignoreCase, out TEnum result) ? result : null;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static TEnum? ParseEnumOrNull<TEnum>(this ReadOnlySpan<char> @this) where TEnum: struct =>
#if SUPPORTS_ENUM_PARSE_SPAN
    Enum.TryParse(@this, out TEnum result)
#else
    TryParseEnum(@this.ToString(), out TEnum result)
#endif
    ? result 
    : null
    ;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static TEnum? ParseEnumOrNull<TEnum>(this ReadOnlySpan<char> @this, bool ignoreCase) where TEnum: struct => 
#if SUPPORTS_ENUM_PARSE_SPAN
    Enum.TryParse(@this, ignoreCase, out TEnum result)
#else
    TryParseEnum(@this.ToString(), ignoreCase, out TEnum result)
#endif
    ? result 
    : null
    ;

  #endregion

  #endregion

}
<#+
  
  string GenerateDefaultValueStubs(string typeName, string code, bool useReadOnlySpanChar = false) {
    var result=new System.Text.StringBuilder();
    result.Append(string.Format(code, "","","default"));
    result.Append(string.Format(code, ", " + typeName, "defaultValue","defaultValue"));
    result.Append(string.Format(code, ", Func<" + typeName + ">", "defaultValueFactory", "defaultValueFactory()"));
    if (!useReadOnlySpanChar)
      result.Append(string.Format(code, ", Func<string, " + typeName + ">", "defaultValueFactory", "defaultValueFactory(@this)"));
    
    return result.ToString();
  }

#>