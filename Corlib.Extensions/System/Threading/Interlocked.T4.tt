<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#region (c)2010-2042 Hawkynt
/*
  This file is part of Hawkynt's .NET Framework extensions.

    Hawkynt's .NET Framework extensions are free software: 
    you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Hawkynt's .NET Framework extensions is distributed in the hope that 
    it will be useful, but WITHOUT ANY WARRANTY; without even the implied 
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
    the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Hawkynt's .NET Framework extensions.  
    If not, see <http://www.gnu.org/licenses/>.
*/
#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */

using System.Diagnostics;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using MethodImplOptions = Utilities.MethodImplOptions;

// ReSharper disable CompareOfFloatsByEqualityOperator
namespace System.Threading;

public static partial class InterlockedEx {
      
  <#foreach(var type in new[]{"int","long","float","double","uint","ulong"}){
      var isIntegerType=type=="int"||type=="long"||type=="uint"||type=="ulong";
      var isUnsupported=type=="uint"||type=="ulong";
      var isUnsigned=type=="uint"||type=="ulong";
      var unsignedType=isUnsigned?type:"u"+type;
      var signedType=isUnsigned?type.Substring(1):type;
      var supportsNativeIncrementDecrement=type=="int"||type=="long";
      var supportsNativeAdd=type=="int"||type=="long";
      var supportsNativeExchange=type=="int"||type=="long"||type=="float"||type=="double";
      var helperClassName="HelperFor"+type[0].ToString().ToUpperInvariant()+type.Substring(1);
      var bitsUsed=type=="uint"||type=="int"||type=="float"?32:64;
  #>

<#if(isUnsupported){#>
  private static class <#=helperClassName#> {
    public delegate <#=type#> CompareExchangeDelegateType(ref <#=type#> source, <#=type#> value, <#=type#> comparand);
    public delegate <#=type#> ExchangeDelegateType(ref <#=type#> source, <#=type#> value);
    public static readonly CompareExchangeDelegateType CompareExchangeImplementation = _CreateCompareExchangeImplementation();
    public static readonly ExchangeDelegateType ExchangeImplementation = _CreateExchangeImplementation();
      
    private static CompareExchangeDelegateType _CreateCompareExchangeImplementation() {
      var originalType = typeof(<#=type#>);
      var signedType = typeof(<#=signedType#>);
      DynamicMethod dynamicMethod = new(string.Empty, originalType, [originalType.MakeByRefType(), originalType, originalType]);
      var ilGenerator = dynamicMethod.GetILGenerator();
      ilGenerator.Emit(OpCodes.Ldarg_0);
      ilGenerator.Emit(OpCodes.Ldarg_1);
      ilGenerator.Emit(OpCodes.Ldarg_2);
      ilGenerator.Emit(
        OpCodes.Call,
        typeof(Interlocked).GetMethod(
          nameof(Interlocked.CompareExchange),
          BindingFlags.Static | BindingFlags.Public,
          null,
          [signedType.MakeByRefType(), signedType, signedType],
          null
        )
      );
      ilGenerator.Emit(OpCodes.Ret);
      return (CompareExchangeDelegateType)dynamicMethod.CreateDelegate(typeof(CompareExchangeDelegateType));
    }

    private static ExchangeDelegateType _CreateExchangeImplementation() {
      var originalType = typeof(<#=type#>);
      var signedType = typeof(<#=signedType#>);
      DynamicMethod dynamicMethod = new(string.Empty, originalType, [originalType.MakeByRefType(), originalType]);
      var ilGenerator = dynamicMethod.GetILGenerator();
      ilGenerator.Emit(OpCodes.Ldarg_0);
      ilGenerator.Emit(OpCodes.Ldarg_1);
      ilGenerator.Emit(
        OpCodes.Call,
        typeof(Interlocked).GetMethod(
          nameof(Interlocked.Exchange),
          BindingFlags.Static | BindingFlags.Public,
          null,
          [signedType.MakeByRefType(), signedType],
          null
        )
      );
      ilGenerator.Emit(OpCodes.Ret);
      return (ExchangeDelegateType)dynamicMethod.CreateDelegate(typeof(ExchangeDelegateType));
    }
  }
<#}#>

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  [DebuggerStepThrough]
<#if(isUnsupported){#>
  public static <#=type#> CompareExchange(ref <#=type#> source, <#=type#> value, <#=type#> comparand) => <#=helperClassName#>.CompareExchangeImplementation(ref source, value, comparand);
<#}else{#>
  public static <#=type#> CompareExchange(ref <#=type#> source, <#=type#> value, <#=type#> comparand) => Interlocked.CompareExchange(ref source, value, comparand);
<#}#>

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  [DebuggerStepThrough]
<#if(isUnsupported){#>
  public static <#=type#> Read(ref <#=type#> source) => <#=helperClassName#>.CompareExchangeImplementation(ref source, 0, 0);
<#}else{#>
  public static <#=type#> Read(ref <#=type#> source) => Interlocked.CompareExchange(ref source, 0, 0);
<#}#>

<#if(supportsNativeExchange){#>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  [DebuggerStepThrough]
  public static <#=type#> Exchange(ref <#=type#> source, <#=type#> value) => Interlocked.Exchange(ref source, value);
<#}else{#>
  public static <#=type#> Exchange(ref <#=type#> source, <#=type#> value) => <#=helperClassName#>.ExchangeImplementation(ref source, value);
<#}#>

<#if(supportsNativeIncrementDecrement){#>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  [DebuggerStepThrough]
  public static <#=type#> Increment(ref <#=type#> source) => Interlocked.Increment(ref source);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  [DebuggerStepThrough]
  public static <#=type#> Decrement(ref <#=type#> source) => Interlocked.Decrement(ref source);
<#}else{#>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  [DebuggerStepThrough]
  public static <#=type#> Increment(ref <#=type#> source) => Add(ref source, 1);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  [DebuggerStepThrough]
  public static <#=type#> Decrement(ref <#=type#> source) => Substract(ref source, 1);
<#}#>

<#if(supportsNativeAdd){#>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  [DebuggerStepThrough]
  public static <#=type#> Add(ref <#=type#> source, <#=type#> value) => Interlocked.Add(ref source, value);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  [DebuggerStepThrough]
  public static <#=type#> Substract(ref <#=type#> source, <#=type#> value) => Interlocked.Add(ref source, -value);
<#}else{#>
  public static <#=type#> Add(ref <#=type#> source, <#=type#> value) {
    while (true) {
      var current = Read(ref source);
      var next = current + value;
      if (CompareExchange(ref source, next, current) == current)
        return next;
    }
  }

  public static <#=type#> Substract(ref <#=type#> source, <#=type#> value) {
    while (true) {
      var current = Read(ref source);
      var next = current - value;
      if (CompareExchange(ref source, next, current) == current)
        return next;
    }
  }
<#}#>

  public static <#=type#> Multiply(ref <#=type#> source, <#=type#> value) {
    while (true) {
      var current = Read(ref source);
      var next = current * value;
      if (CompareExchange(ref source, next, current) == current)
        return next;
    }
  }

  public static <#=type#> Divide(ref <#=type#> source, <#=type#> value) {
    while (true) {
      var current = Read(ref source);
      var next = current / value;
      if (CompareExchange(ref source, next, current) == current)
        return next;
    }
  }

  public static <#=type#> Modulo(ref <#=type#> source, <#=type#> value) {
    while (true) {
      var current = Read(ref source);
      var next = current % value;
      if (CompareExchange(ref source, next, current) == current)
        return next;
    }
  }
<#if(isIntegerType){#>

  public static <#=type#> And(ref <#=type#> source, <#=type#> value) {
    while (true) {
      var current = Read(ref source);
      var next = current & value;
      if (CompareExchange(ref source, next, current) == current)
        return next;
    }
  }

  public static <#=type#> NAnd(ref <#=type#> source, <#=type#> value) {
    while (true) {
      var current = Read(ref source);
      var next = ~(current & value);
      if (CompareExchange(ref source, next, current) == current)
        return next;
    }
  }

  public static <#=type#> Or(ref <#=type#> source, <#=type#> value) {
    while (true) {
      var current = Read(ref source);
      var next = current | value;
      if (CompareExchange(ref source, next, current) == current)
        return next;
    }
  }

  public static <#=type#> NOr(ref <#=type#> source, <#=type#> value) {
    while (true) {
      var current = Read(ref source);
      var next = ~(current | value);
      if (CompareExchange(ref source, next, current) == current)
        return next;
    }
  }

  public static <#=type#> Xor(ref <#=type#> source, <#=type#> value) {
    while (true) {
      var current = Read(ref source);
      var next = current ^ value;
      if (CompareExchange(ref source, next, current) == current)
        return next;
    }
  }

  public static <#=type#> NXor(ref <#=type#> source, <#=type#> value) {
    while (true) {
      var current = Read(ref source);
      var next = ~(current ^ value);
      if (CompareExchange(ref source, next, current) == current)
        return next;
    }
  }

  public static <#=type#> Not(ref <#=type#> source) {
    while (true) {
      var current = Read(ref source);
      var next = ~current;
      if (CompareExchange(ref source, next, current) == current)
        return next;
    }
  }

<#if(isUnsigned){#>
  public static <#=type#> ShiftLeft(ref <#=type#> source, int value) {
    while (true) {
      var current = Read(ref source);
      var next = current << value;
      if (CompareExchange(ref source, next, current) == current)
        return next;
    }
  }

  public static <#=type#> ShiftRight(ref <#=type#> source, int value) {
    while (true) {
      var current = Read(ref source);
      var next = current >> value;
      if (CompareExchange(ref source, next, current) == current)
        return next;
    }
  }

  public static <#=type#> RotateLeft(ref <#=type#> source, int value) {
    while (true) {
      var current = Read(ref source);
      var next = current << value | current >> (<#=bitsUsed#> - value);
      if (CompareExchange(ref source, next, current) == current)
        return next;
    }
  }

  public static <#=type#> RotateRight(ref <#=type#> source, int value) {
    while (true) {
      var current = Read(ref source);
      var next = current >> value | current << (<#=bitsUsed#> - value);
      if (CompareExchange(ref source, next, current) == current)
        return next;
    }
  }
<#}else{#>
  public static <#=type#> ArithmeticShiftLeft(ref <#=type#> source, int value) {
    while (true) {
      var current = Read(ref source);
      var next = current << value;
      if(next < current)
        throw new OverflowException("Shifted value bits into the sign bit");

      if (CompareExchange(ref source, next, current) == current)
        return next;
    }
  }

  public static <#=type#> ArithmeticShiftRight(ref <#=type#> source, int value) {
    while (true) {
      var current = Read(ref source);
      var next = current >> value;
      if (CompareExchange(ref source, next, current) == current)
        return next;
    }
  }

  public static <#=type#> LogicalShiftLeft(ref <#=type#> source, int value) {
    while (true) {
      var current = Read(ref source);
      var next = (<#=type#>)((<#=unsignedType#>)current << value);
      if (CompareExchange(ref source, next, current) == current)
        return next;
    }
  }

  public static <#=type#> LogicalShiftRight(ref <#=type#> source, int value) {
    while (true) {
      var current = Read(ref source);
      //var next = (<#=type#>)((<#=unsignedType#>)current >> value);
      var next = current >>> value;
      if(next > current)
        throw new OverflowException("Shifted sign bit into value bits");

      if (CompareExchange(ref source, next, current) == current)
        return next;
    }
  }
<#}#>

    <#}#>
  <#}#>

}
