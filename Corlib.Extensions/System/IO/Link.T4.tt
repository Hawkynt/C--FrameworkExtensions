<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#region (c)2010-2042 Hawkynt
/*
  This file is part of Hawkynt's .NET Framework extensions.

    Hawkynt's .NET Framework extensions are free software: 
    you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Hawkynt's .NET Framework extensions is distributed in the hope that 
    it will be useful, but WITHOUT ANY WARRANTY; without even the implied 
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
    the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Hawkynt's .NET Framework extensions.  
    If not, see <http://www.gnu.org/licenses/>.
*/
#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */

using Guard;

namespace System.IO;

public static partial class LinkExtensions {
  
<#
  var codeEmitter=new[]{
    Tuple.Create("Junction","DirectoryInfo"),
    Tuple.Create("SymbolicLink","DirectoryInfo"),
    Tuple.Create("SymbolicLink","FileInfo"),
    Tuple.Create("HardLink","FileInfo"),
  };

  foreach(var tuple in codeEmitter){
    var name=tuple.Item1;
    var type=tuple.Item2;
#>
  #region <#=name#> for <#=type#>
  public static string Get<#=name#>Target(this <#=type#> @this) {
    Against.ThisIsNull(@this);
  
    return _InternalGet<#=name#>Target(@this);
  }
    
  public static bool Is<#=name#>(this <#=type#> @this) {
    Against.ThisIsNull(@this);
  
    return @this.Exists && _InternalGet<#=name#>TargetCount(@this) > 0;
  }
        
  public static bool TryCreate<#=name#>From(this <#=type#> @this, string source) {
    Against.ThisIsNull(@this);
  
    return _InternalCreate<#=name#>From(@this, source) == null;
  }
    
  public static bool TryCreate<#=name#>From(this <#=type#> @this, <#=type#> source) {
    Against.ThisIsNull(@this);
  
    return @this.TryCreate<#=name#>From(source.FullName);
  }
    
  public static bool TryCreate<#=name#>At(this <#=type#> @this, <#=type#> target) {
    Against.ThisIsNull(@this);
  
    return target.TryCreate<#=name#>From(@this);
  }
    
  public static bool TryCreate<#=name#>At(this <#=type#> @this, string target) {
    Against.ThisIsNull(@this);
  
    return new <#=type#>(target).TryCreate<#=name#>From(@this);
  }
    
  public static void Create<#=name#>From(this <#=type#> @this, string source) {
    Against.ThisIsNull(@this);
  
    var result = _InternalCreate<#=name#>From(@this, source);
    if(result != null)
      throw result;
  }

  public static void Create<#=name#>From(this <#=type#> @this, <#=type#> source) {
    Against.ThisIsNull(@this);
  
    @this.Create<#=name#>From(source.FullName);
  }

  public static void Create<#=name#>At(this <#=type#> @this, <#=type#> target) {
    Against.ThisIsNull(@this);
  
    target.Create<#=name#>From(@this);
  }
    
  public static void Create<#=name#>At(this <#=type#> @this, string target) {
    Against.ThisIsNull(@this);
  
    new <#=type#>(target).Create<#=name#>From(@this);
  }
  #endregion
<#
  }
#>

}
