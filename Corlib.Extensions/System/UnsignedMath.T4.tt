<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#region (c)2010-2042 Hawkynt

// This file is part of Hawkynt's .NET Framework extensions.
// 
// Hawkynt's .NET Framework extensions are free software:
// you can redistribute and/or modify it under the terms
// given in the LICENSE file.
// 
// Hawkynt's .NET Framework extensions is distributed in the hope that
// it will be useful, but WITHOUT ANY WARRANTY without even the implied
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the LICENSE file for more details.
// 
// You should have received a copy of the License along with Hawkynt's
// .NET Framework extensions. If not, see
// <https://github.com/Hawkynt/C--FrameworkExtensions/blob/master/LICENSE>.

#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */

using Guard;

namespace System;

<#
// Configuration for different numeric types
var types = new[] {
    new {
        Type = "float",
        TypeName = "Float",
        Epsilon = "float.Epsilon"
    },
    new {
        Type = "double", 
        TypeName = "Double",
        Epsilon = "double.Epsilon"
    },
    new {
        Type = "decimal",
        TypeName = "Decimal", 
        Epsilon = "0.0000000000000000000000000001m"
    }
};

foreach(var type in types) {
#>
/// <summary>
/// Represents a <#= type.Type #> value that is guaranteed to be non-negative.
/// </summary>
public readonly record struct Unsigned<#= type.TypeName #>(<#= type.Type #> value) : 
  IComparable<Unsigned<#= type.TypeName #>>,
  IComparable<<#= type.Type #>>,
  IComparable,
  IConvertible,
#if NET7_0_OR_GREATER
  ISpanParsable<Unsigned<#= type.TypeName #>>,
  ISpanFormattable
#else
  IFormattable
#endif
{
  private const string ErrorMessage = "Value must be non-negative";

  /// <summary>
  /// Gets the wrapped <#= type.Type #> value.
  /// </summary>
  private readonly <#= type.Type #> _value = value >= 0 ? value : AlwaysThrow.ArgumentOutOfRangeException<<#= type.Type #>>(nameof(value), ErrorMessage);

  // Implicit conversions from unsigned types (always safe)
  public static implicit operator Unsigned<#= type.TypeName #>(char value) => new(value);
  public static implicit operator Unsigned<#= type.TypeName #>(byte value) => new(value);
  public static implicit operator Unsigned<#= type.TypeName #>(ushort value) => new(value);
  public static implicit operator Unsigned<#= type.TypeName #>(uint value) => new(value);
  public static implicit operator Unsigned<#= type.TypeName #>(ulong value) => new(value);

  // Safe conversion to <#= type.Type #>
  public static implicit operator <#= type.Type #>(Unsigned<#= type.TypeName #> value) => value._value;

  // Potentially unsafe conversion from <#= type.Type #>
  public static explicit operator Unsigned<#= type.TypeName #>(<#= type.Type #> value) => new(value);

  #region Arithmetic Operations

  // Addition
  public static Unsigned<#= type.TypeName #> operator +(Unsigned<#= type.TypeName #> left, Unsigned<#= type.TypeName #> right) => new(left._value + right._value);
  // Can go negative
  public static <#= type.Type #> operator +(Unsigned<#= type.TypeName #> left, <#= type.Type #> right) => left._value + right;
  public static <#= type.Type #> operator +(<#= type.Type #> left, Unsigned<#= type.TypeName #> right) => left + right._value;

  // Subtraction (may be negative thus returning <#= type.Type #> everywhere)
  public static <#= type.Type #> operator -(Unsigned<#= type.TypeName #> left, Unsigned<#= type.TypeName #> right) => left._value - right._value;
  public static <#= type.Type #> operator -(Unsigned<#= type.TypeName #> left, <#= type.Type #> right) => left._value - right;
  public static <#= type.Type #> operator -(<#= type.Type #> left, Unsigned<#= type.TypeName #> right) => left - right._value;

  // Multiplication
  public static Unsigned<#= type.TypeName #> operator *(Unsigned<#= type.TypeName #> left, Unsigned<#= type.TypeName #> right) => new(left._value * right._value);
  public static <#= type.Type #> operator *(Unsigned<#= type.TypeName #> left, <#= type.Type #> right) => left._value * right;
  public static <#= type.Type #> operator *(<#= type.Type #> left, Unsigned<#= type.TypeName #> right) => left * right._value;

  // Division
  public static Unsigned<#= type.TypeName #> operator /(Unsigned<#= type.TypeName #> left, Unsigned<#= type.TypeName #> right) => new(left._value / right._value);
  public static <#= type.Type #> operator /(Unsigned<#= type.TypeName #> left, <#= type.Type #> right) => left._value / right;
  public static <#= type.Type #> operator /(<#= type.Type #> left, Unsigned<#= type.TypeName #> right) => left / right._value;

  // Modulo
  public static Unsigned<#= type.TypeName #> operator %(Unsigned<#= type.TypeName #> left, Unsigned<#= type.TypeName #> right) => new(left._value % right._value);
  public static <#= type.Type #> operator %(Unsigned<#= type.TypeName #> left, <#= type.Type #> right) => left._value % right;

  #endregion

  #region Comparison Operations

  public static bool operator <(Unsigned<#= type.TypeName #> left, Unsigned<#= type.TypeName #> right) => left._value < right._value;
  public static bool operator <=(Unsigned<#= type.TypeName #> left, Unsigned<#= type.TypeName #> right) => left._value <= right._value;
  public static bool operator >(Unsigned<#= type.TypeName #> left, Unsigned<#= type.TypeName #> right) => left._value > right._value;
  public static bool operator >=(Unsigned<#= type.TypeName #> left, Unsigned<#= type.TypeName #> right) => left._value >= right._value;

  public static bool operator <(Unsigned<#= type.TypeName #> left, <#= type.Type #> right) => left._value < right;
  public static bool operator <=(Unsigned<#= type.TypeName #> left, <#= type.Type #> right) => left._value <= right;
  public static bool operator >(Unsigned<#= type.TypeName #> left, <#= type.Type #> right) => left._value > right;
  public static bool operator >=(Unsigned<#= type.TypeName #> left, <#= type.Type #> right) => left._value >= right;

  public static bool operator <(<#= type.Type #> left, Unsigned<#= type.TypeName #> right) => left < right._value;
  public static bool operator <=(<#= type.Type #> left, Unsigned<#= type.TypeName #> right) => left <= right._value;
  public static bool operator >(<#= type.Type #> left, Unsigned<#= type.TypeName #> right) => left > right._value;
  public static bool operator >=(<#= type.Type #> left, Unsigned<#= type.TypeName #> right) => left >= right._value;

  #endregion

  #region IComparable Implementation

  public int CompareTo(Unsigned<#= type.TypeName #> other) => this._value.CompareTo(other._value);
  public int CompareTo(<#= type.Type #> other) => this._value.CompareTo(other);
  public int CompareTo(object obj) => obj switch {
    null => 1,
    Unsigned<#= type.TypeName #> other => this.CompareTo(other),
    <#= type.Type #> f => this.CompareTo(f),
    _ => throw new ArgumentException($"Object must be of type {nameof(Unsigned<#= type.TypeName #>)} or <#= type.Type #>")
  };

  #endregion

  #region IFormattable Implementation

  /// <summary>
  /// Returns the string representation using the specified format and provider.
  /// </summary>
  public string ToString(string format, IFormatProvider formatProvider) => this._value.ToString(format, formatProvider);

  #endregion

  #region IConvertible Implementation

  public TypeCode GetTypeCode() => Type.GetTypeCode(typeof(<#= type.Type #>));
  public bool ToBoolean(IFormatProvider provider) => Convert.ToBoolean(this._value, provider);
  public byte ToByte(IFormatProvider provider) => Convert.ToByte(this._value, provider);
  public char ToChar(IFormatProvider provider) => Convert.ToChar(this._value, provider);
  public DateTime ToDateTime(IFormatProvider provider) => Convert.ToDateTime(this._value, provider);
  public decimal ToDecimal(IFormatProvider provider) => Convert.ToDecimal(this._value, provider);
  public double ToDouble(IFormatProvider provider) => Convert.ToDouble(this._value, provider);
  public short ToInt16(IFormatProvider provider) => Convert.ToInt16(this._value, provider);
  public int ToInt32(IFormatProvider provider) => Convert.ToInt32(this._value, provider);
  public long ToInt64(IFormatProvider provider) => Convert.ToInt64(this._value, provider);
  public sbyte ToSByte(IFormatProvider provider) => Convert.ToSByte(this._value, provider);
  public float ToSingle(IFormatProvider provider) => Convert.ToSingle(this._value, provider);
  public string ToString(IFormatProvider provider) => this._value.ToString(provider);
  public object ToType(Type conversionType, IFormatProvider provider) => Convert.ChangeType(this._value, conversionType, provider);
  public ushort ToUInt16(IFormatProvider provider) => Convert.ToUInt16(this._value, provider);
  public uint ToUInt32(IFormatProvider provider) => Convert.ToUInt32(this._value, provider);
  public ulong ToUInt64(IFormatProvider provider) => Convert.ToUInt64(this._value, provider);

  #endregion

#if NET7_0_OR_GREATER

  #region Modern .NET Parsing

  /// <summary>
  /// Parses a string as an Unsigned<#= type.TypeName #> using the specified provider.
  /// </summary>
  public static Unsigned<#= type.TypeName #> Parse(string s, IFormatProvider provider) => new(<#= type.Type #>.Parse(s, provider));

  /// <summary>
  /// Parses a ReadOnlySpan of characters as an Unsigned<#= type.TypeName #>.
  /// </summary>
  public static Unsigned<#= type.TypeName #> Parse(ReadOnlySpan<char> s, IFormatProvider provider) => new(<#= type.Type #>.Parse(s, provider));

  /// <summary>
  /// Attempts to parse a string as an Unsigned<#= type.TypeName #> using the specified provider.
  /// </summary>
  public static bool TryParse(string s, IFormatProvider provider, out Unsigned<#= type.TypeName #> result) {
    if (<#= type.Type #>.TryParse(s, provider, out var numericResult) && numericResult >= 0) {
      result = new(numericResult);
      return true;
    }

    result = default;
    return false;
  }

  /// <summary>
  /// Attempts to parse a ReadOnlySpan of characters as an Unsigned<#= type.TypeName #>.
  /// </summary>
  public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider provider, out Unsigned<#= type.TypeName #> result) {
    if (<#= type.Type #>.TryParse(s, provider, out var numericResult) && numericResult >= 0) {
      result = new(numericResult);
      return true;
    }

    result = default;
    return false;
  }

  /// <summary>
  /// Formats the value into the specified span.
  /// </summary>
  public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider provider) =>
    this._value.TryFormat(destination, out charsWritten, format, provider);

  #endregion

#endif

  #region String Conversion

  /// <summary>
  /// Returns the string representation of the underlying <#= type.Type #> value.
  /// </summary>
  // ReSharper disable once SpecifyACultureInStringConversionExplicitly
  public override string ToString() => this._value.ToString();

  /// <summary>
  /// Returns the string representation using the specified format.
  /// </summary>
  public string ToString(string format) => this._value.ToString(format);

  /// <summary>
  /// Attempts to parse a string as an Unsigned<#= type.TypeName #>.
  /// </summary>
  public static bool TryParse(string s, out Unsigned<#= type.TypeName #> result) {
    if (<#= type.Type #>.TryParse(s, out var numericResult) && numericResult >= 0) {
      result = new(numericResult);
      return true;
    }

    result = default;
    return false;
  }

  /// <summary>
  /// Parses a string as an Unsigned<#= type.TypeName #>.
  /// </summary>
  public static Unsigned<#= type.TypeName #> Parse(string s) {
    var value = <#= type.Type #>.Parse(s);
    return new(value);
  }

  #endregion

  #region Math Operations

  /// <summary>
  /// Calculates 1/x (reciprocal estimate).
  /// </summary>
  public Unsigned<#= type.TypeName #> ReciprocalEstimate() => new(this._value.ReciprocalEstimate());
  
  /// <summary>
  /// Determines whether the value is odd.
  /// </summary>
  public bool IsOdd() => this._value.IsOdd();
  
  /// <summary>
  /// Determines whether the value is even.
  /// </summary>
  public bool IsEven() => this._value.IsEven();

  /// <summary>
  /// Returns the largest integral value less than or equal to the value.
  /// </summary>
  public Unsigned<#= type.TypeName #> Floor() => new(this._value.Floor());
  
  /// <summary>
  /// Calculates the integral part of the value.
  /// </summary>
  public Unsigned<#= type.TypeName #> Truncate() => new(this._value.Truncate());
  
  /// <summary>
  /// Returns the smallest integral value greater than or equal to the value.
  /// </summary>
  public Unsigned<#= type.TypeName #> Ceiling() => new(this._value.Ceiling());
  
  /// <summary>
  /// Rounds the value to the nearest integral value.
  /// </summary>
  public Unsigned<#= type.TypeName #> Round() => new(this._value.Round());
  
  /// <summary>
  /// Rounds the value to the specified number of decimal places.
  /// </summary>
  public Unsigned<#= type.TypeName #> Round(int digits) => new(this._value.Round(digits));
  
  /// <summary>
  /// Rounds the value using the specified rounding convention.
  /// </summary>
  public Unsigned<#= type.TypeName #> Round(MidpointRounding method) => new(this._value.Round(method));
  
  /// <summary>
  /// Rounds the value to the specified number of decimal places using the specified rounding convention.
  /// </summary>
  public Unsigned<#= type.TypeName #> Round(int digits, MidpointRounding method) => new(this._value.Round(digits, method));
  
  <# if (type.Type != "decimal") { #>

  /// <summary>
  /// Determines whether the value is NaN (Not a Number).
  /// </summary>
  public bool IsNaN() => <#= type.Type #>.IsNaN(this._value);
  
  /// <summary>
  /// Determines whether the value is infinite.
  /// </summary>
  public bool IsInfinity() => <#= type.Type #>.IsInfinity(this._value);
  
  /// <summary>
  /// Determines whether the value is a valid numeric value.
  /// </summary>
  public bool IsNumeric() => this._value.IsNumeric();
  
  /// <summary>
  /// Determines whether the value is not a valid numeric value.
  /// </summary>
  public bool IsNonNumeric() => this._value.IsNonNumeric();

  <# } #>

  /// <summary>
  /// Determines whether the value is zero.
  /// </summary>
  public bool IsZero() => this._value == 0;
  
  /// <summary>
  /// Determines whether the value is not zero.
  /// </summary>
  public bool IsNotZero() => this._value != 0;
  
  /// <summary>
  /// Determines whether the value is positive (true for all non-zero unsigned values).
  /// </summary>
  public bool IsPositive() => this._value != 0;
  
  /// <summary>
  /// Determines whether the value is positive or zero (always true for unsigned types).
  /// </summary>
  public bool IsPositiveOrZero() => true;
  
  /// <summary>
  /// Determines whether the value is negative (always false for unsigned types).
  /// </summary>
  public bool IsNegative() => false;
  
  /// <summary>
  /// Determines whether the value is negative or zero (true only when zero).
  /// </summary>
  public bool IsNegativeOrZero() => this._value == 0;
  
  /// <summary>
  /// Determines whether the value is strictly below the specified exclusive upper limit.
  /// </summary>
  public bool IsBelow(Unsigned<#= type.TypeName #> exclusiveLimit) => this._value < exclusiveLimit._value;
  
  /// <summary>
  /// Determines whether the value is strictly above the specified exclusive lower limit.
  /// </summary>
  public bool IsAbove(Unsigned<#= type.TypeName #> exclusiveLimit) => this._value > exclusiveLimit._value;
  
  /// <summary>
  /// Determines whether the value is less than or equal to the specified inclusive upper limit.
  /// </summary>
  public bool IsBelowOrEqual(Unsigned<#= type.TypeName #> inclusiveLimit) => this._value <= inclusiveLimit._value;
  
  /// <summary>
  /// Determines whether the value is greater than or equal to the specified inclusive lower limit.
  /// </summary>
  public bool IsAboveOrEqual(Unsigned<#= type.TypeName #> inclusiveLimit) => this._value >= inclusiveLimit._value;
  
  /// <summary>
  /// Determines whether the value lies strictly between two exclusive bounds.
  /// </summary>
  public bool IsBetween(Unsigned<#= type.TypeName #> exclusiveLowerLimit, Unsigned<#= type.TypeName #> exclusiveUpperLimit) => this._value > exclusiveLowerLimit._value && this._value < exclusiveUpperLimit._value;
  
  /// <summary>
  /// Determines whether the value lies within the specified inclusive range.
  /// </summary>
  public bool IsInRange(Unsigned<#= type.TypeName #> inclusiveLowerLimit, Unsigned<#= type.TypeName #> inclusiveUpperLimit) => this._value >= inclusiveLowerLimit._value && this._value <= inclusiveUpperLimit._value;
    
  /// <summary>
  /// Returns the absolute value (which is just the value itself for Unsigned<#= type.TypeName #>).
  /// </summary>
  public Unsigned<#= type.TypeName #> Abs() => this;

  /// <summary>
  /// Returns the square root of the value.
  /// </summary>
  public Unsigned<#= type.TypeName #> Sqrt() => new(this._value.Sqrt());

  /// <summary>
  /// Returns the value raised to the specified power.
  /// </summary>
  public <#= type.Type #> Pow(<#= type.Type #> exponent) => this._value.Pow(exponent);

  /// <summary>
  /// Returns the cube of the value.
  /// </summary>
  public Unsigned<#= type.TypeName #> Cubed() => new(this._value.Cubed());
  
  /// <summary>
  /// Returns the square of the value.
  /// </summary>
  public Unsigned<#= type.TypeName #> Squared() => new(this._value.Squared());
  
  /// <summary>
  /// Returns the cube root of the value.
  /// </summary>
  public Unsigned<#= type.TypeName #> Cbrt() => new(this._value.Cbrt());
  
  /// <summary>
  /// Returns the smaller of two values.
  /// </summary>
  public static Unsigned<#= type.TypeName #> Min(Unsigned<#= type.TypeName #> left, Unsigned<#= type.TypeName #> right) => left._value <= right._value ? left : right;

  /// <summary>
  /// Returns the larger of two values.
  /// </summary>
  public static Unsigned<#= type.TypeName #> Max(Unsigned<#= type.TypeName #> left, Unsigned<#= type.TypeName #> right) => left._value >= right._value ? left : right;

  /// <summary>
  /// Determines whether this value is contained in the specified array.
  /// </summary>
  public bool IsIn(params Unsigned<#= type.TypeName #>[] values) {
    var needle = this._value;
    
    // ReSharper disable once CompareOfFloatsByEqualityOperator
    return values.Any(v => v._value == needle);
  }
  
  /// <summary>
  /// Determines whether this value is not contained in the specified array.
  /// </summary>
  public bool IsNotIn(params Unsigned<#= type.TypeName #>[] values) => !this.IsIn(values);

  #endregion

  #region Constants

  /// <summary>
  /// Represents zero.
  /// </summary>
  public static readonly Unsigned<#= type.TypeName #> Zero = new(0);

  /// <summary>
  /// Represents one.
  /// </summary>
  public static readonly Unsigned<#= type.TypeName #> One = new(1);

  /// <summary>
  /// Represents the maximum possible value.
  /// </summary>
  public static readonly Unsigned<#= type.TypeName #> MaxValue = new(<#= type.Type #>.MaxValue);

  /// <summary>
  /// Represents the smallest positive value.
  /// </summary>
  public static readonly Unsigned<#= type.TypeName #> Epsilon = new(<#= type.Epsilon #>);

  #endregion
}

<# } #>