<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#region (c)2010-2042 Hawkynt

// This file is part of Hawkynt's .NET Framework extensions.
// 
// Hawkynt's .NET Framework extensions are free software:
// you can redistribute and/or modify it under the terms
// given in the LICENSE file.
// 
// Hawkynt's .NET Framework extensions is distributed in the hope that
// it will be useful, but WITHOUT ANY WARRANTY without even the implied
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the LICENSE file for more details.
// 
// You should have received a copy of the License along with Hawkynt's
// .NET Framework extensions. If not, see
// <https://github.com/Hawkynt/C--FrameworkExtensions/blob/master/LICENSE>.

#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */

using System.Reflection;

namespace System;

public static partial class TypeExtensions {
  
  <#for(var i=0;i<10;++i){#>

  /// <summary>
  /// Creates an instance of the given type by calling the ctor with the given parameter type.
  /// </summary>
  /// <typeparam name="TType">The type to create.</typeparam>
  <#for(var j=0;j<=i;++j){#>/// <typeparam name="TParam<#=j#>">The type of the parameter number <#=j+1#>.</typeparam>
  <#}#>

  /// <param name="this">This Type to create the instance from.</param>
  <#for(var j=0;j<=i;++j){#>/// <param name="param<#=j#>">The parameter number <#=j+1#>.</param>
  <#}#>

  /// <returns>The instance of the given type.</returns>
  public static TType FromConstructor<TType<#=string.Join(string.Empty,Enumerable.Range(0,i+1).Select(j=>", TParam"+j))#>>(this Type @this<#=string.Join(string.Empty,Enumerable.Range(0,i+1).Select(j=>", TParam"+j+" param"+j))#>) 
    => _FromConstructor<TType>(
      @this,
<#for(var j=0;j<=i;++j){#>
      new TypeWithValue(typeof(TParam<#=j#>), param<#=j#>)<#=(j<i?",":string.Empty)#>
<#}#>
    );
  <#}#>

  <#for(var i=0;i<10;++i){#>
  <#  var pList=i<1?"T":string.Join(", ",Enumerable.Range(1,i+1).Select(j=>"T"+j));#>
  /// <summary>
  /// Gets a method pointer to a static method of the given type.
  /// </summary>
  /// <param name="this">This Type.</param>
  /// <param name="name">The name of the method.</param>
  /// <param name="flags">The BindingFlags if not simply public.</param>
  /// <returns>A method pointer or <c>null</c></returns>
  public static Action<<#=pList#>> GetStaticMethod<<#=pList#>>(this Type @this, string name, BindingFlags flags = BindingFlags.Public) 
    => (Action<<#=pList#>>)@this.GetMethod(name, BindingFlags.Static | flags)?.CreateDelegate(typeof(Action<<#=pList#>>))
    ;
  <#}#>

}
