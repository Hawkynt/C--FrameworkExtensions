<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Runtime.InteropServices" #>
<#@ output extension=".cs" #>
#region (c)2010-2042 Hawkynt

// This file is part of Hawkynt's .NET Framework extensions.
// 
// Hawkynt's .NET Framework extensions are free software:
// you can redistribute and/or modify it under the terms
// given in the LICENSE file.
// 
// Hawkynt's .NET Framework extensions is distributed in the hope that
// it will be useful, but WITHOUT ANY WARRANTY without even the implied
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the LICENSE file for more details.
// 
// You should have received a copy of the License along with Hawkynt's
// .NET Framework extensions. If not, see
// <https://github.com/Hawkynt/C--FrameworkExtensions/blob/master/LICENSE>.

#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */

using System.Runtime.CompilerServices;
using MethodImplOptions = Utilities.MethodImplOptions;

#if SUPPORTS_VECTOR_512 || SUPPORTS_VECTOR_256 || SUPPORTS_VECTOR_128
using System.Runtime.Intrinsics;
#endif

using Guard;

// ReSharper disable UnusedMember.Global
// ReSharper disable RedundantCast
// ReSharper disable CompareOfFloatsByEqualityOperator
namespace System;

public static partial class MathEx {

<#foreach (var type in new[]{"sbyte","short","int","long"}){#>
  /// <summary>
  /// Performs an arithmetic left shift on the specified value.
  /// </summary>
  /// <param name="this">The value to shift</param>
  /// <param name="count">The number of bits to shift</param>
  /// <returns>The result of the operation.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> ArithmeticShiftLeft(this <#=type#> @this, byte count) => (<#=type#>)(count >= <#=GetSizeInBits(type)-1#> ? 0 : ((<#=GetUnsignedType(type)#>)@this & 0x<#=(1UL << GetSizeInBits(type) - 1).ToString("X")#>) | (((<#=GetUnsignedType(type)#>)@this << count) & 0x<#=((1UL << GetSizeInBits(type) - 1) - 1).ToString("X")#>));

  /// <summary>
  /// Performs an arithmetic right shift on the specified value.
  /// </summary>
  /// <param name="this">The value to shift</param>
  /// <param name="count">The number of bits to shift</param>
  /// <returns>The result of the operation.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> ArithmeticShiftRight(this <#=type#> @this, byte count) => (<#=type#>)(count >= <#=GetSizeInBits(type)-1#> ? 0 : @this >> count);

  /// <summary>
  /// Performs a logical left shift on the specified value.
  /// </summary>
  /// <param name="this">The value to shift</param>
  /// <param name="count">The number of bits to shift</param>
  /// <returns>The result of the operation.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> LogicalShiftLeft(this <#=type#> @this, byte count) => (<#=type#>)ArithmeticShiftLeft((<#=(type=="sbyte"?"byte":"u"+type)#>)@this, count);

  /// <summary>
  /// Performs a logical right shift on the specified value.
  /// </summary>
  /// <param name="this">The value to shift</param>
  /// <param name="count">The number of bits to shift</param>
  /// <returns>The result of the operation.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> LogicalShiftRight(this <#=type#> @this, byte count) => (<#=type#>)ArithmeticShiftRight((<#=(type=="sbyte"?"byte":"u"+type)#>)@this, count);

<#}#>
<#foreach (var type in new[]{"byte","ushort","uint","ulong"}){#>
  /// <summary>
  /// Performs an arithmetic left shift on the specified value.
  /// </summary>
  /// <param name="this">The value to shift</param>
  /// <param name="count">The number of bits to shift</param>
  /// <returns>The result of the operation.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> ArithmeticShiftLeft(this <#=type#> @this, byte count) => (<#=type#>)(count >= <#=GetSizeInBits(type)#> ? 0 : @this << count);

  /// <summary>
  /// Performs an arithmetic right shift on the specified value.
  /// </summary>
  /// <param name="this">The value to shift</param>
  /// <param name="count">The number of bits to shift</param>
  /// <returns>The result of the operation.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> ArithmeticShiftRight(this <#=type#> @this, byte count) => (<#=type#>)(count >= <#=GetSizeInBits(type)#> ? 0 : @this >> count);
  
#if !SUPPORTS_BITOPERATIONS

  /// <summary>
  /// Performs a logical rotation to the left on the specified value.
  /// </summary>
  /// <param name="this">The value to rotate</param>
  /// <param name="count">The number of bits to rotate</param>
  /// <returns>The result of the operation.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> RotateLeft(this <#=type#> @this, byte count) {
    count &= <#=GetSizeInBits(type) - 1#>;
    return (<#=type#>)((@this << count) | (@this >> (<#=GetSizeInBits(type)#> - count)));
  }

  /// <summary>
  /// Performs a logical rotation to the right on the specified value.
  /// </summary>
  /// <param name="this">The value to rotate</param>
  /// <param name="count">The number of bits to rotate</param>
  /// <returns>The result of the operation.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> RotateRight(this <#=type#> @this, byte count) {
    count &= <#=GetSizeInBits(type) - 1#>;
    return (<#=type#>)((@this >> count) | (@this << (<#=GetSizeInBits(type)#> - count)));
  }

#endif

<#}#>

<#foreach (var type in new[]{"byte","sbyte","ushort","short","uint","int","ulong","long"}){#>

  /// <summary>
  /// Performs a bitwise AND operation on the specified operands.
  /// </summary>
  /// <param name="this">The left operand</param>
  /// <param name="other">The right operand</param>
  /// <returns>The result of the operation.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> And(this <#=type#> @this, <#=type#> other) => (<#=type#>)(@this & other);

  /// <summary>
  /// Performs a bitwise OR operation on the specified operands.
  /// </summary>
  /// <param name="this">The left operand</param>
  /// <param name="other">The right operand</param>
  /// <returns>The result of the operation.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> Or(this <#=type#> @this, <#=type#> other) => (<#=type#>)(@this | other);

  /// <summary>
  /// Performs a bitwise XOR (exclusive OR) operation on the specified operands.
  /// </summary>
  /// <param name="this">The left operand</param>
  /// <param name="other">The right operand</param>
  /// <returns>The result of the operation.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> Xor(this <#=type#> @this, <#=type#> other) => (<#=type#>)(@this ^ other);

  /// <summary>
  /// Performs a bitwise NAND (negated AND) operation on the specified operands.
  /// </summary>
  /// <param name="this">The left operand</param>
  /// <param name="other">The right operand</param>
  /// <returns>The result of the operation.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> Nand(this <#=type#> @this, <#=type#> other) => (<#=type#>)~(@this & other);

  /// <summary>
  /// Performs a bitwise NOR (negated OR) operation on the specified operands.
  /// </summary>
  /// <param name="this">The left operand</param>
  /// <param name="other">The right operand</param>
  /// <returns>The result of the operation.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> Nor(this <#=type#> @this, <#=type#> other) => (<#=type#>)~(@this | other);

  /// <summary>
  /// Performs a bitwise EQU (negated XOR, NXOR) operation on the specified operands.
  /// </summary>
  /// <param name="this">The left operand</param>
  /// <param name="other">The right operand</param>
  /// <returns>The result of the operation.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> Equ(this <#=type#> @this, <#=type#> other) => (<#=type#>)~(@this ^ other);

  /// <summary>
  /// Performs a bitwise NOT operation on the specified value.
  /// </summary>
  /// <param name="this">The value</param>
  /// <returns>The result of the operation.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> Not(this <#=type#> @this) => (<#=type#>)~@this;

    /// <summary>
  /// Extracts a specified number of consecutive bits from a value.
  /// </summary>
  /// <param name="this">The value to extract bits from</param>
  /// <param name="index">The starting index (0-based) to extract bits from</param>
  /// <param name="count">The number of bits to extract</param>
  /// <returns>The extracted bits.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> Bits(this <#=type#> @this, byte index, byte count) {
    var result = @this >> index;
    var andMask = ((<#=type#>)1 << count) - 1;
    result &= andMask;
    return (<#=type#>)result;
  }
    
  /// <summary>
  /// Determines whether the specified number is odd.
  /// </summary>
  /// <param name="this">This number.</param>
  /// <returns><c>true</c> if the number is odd; otherwise, <c>false</c>.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsOdd(this <#=type#> @this) => (@this & 1) != 0;
    
  /// <summary>
  /// Determines whether the specified number is even.
  /// </summary>
  /// <param name="this">This number.</param>
  /// <returns><c>true</c> if the number is even; otherwise, <c>false</c>.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsEven(this <#=type#> @this) => (@this & 1) == 0;

<#}#>
  
<#foreach (var type in new[]{"float","double","decimal"}){#>
    
  /// <summary>
  /// Calculates 1/x.
  /// </summary>
  /// <param name="this">This number.</param>
  /// <returns>An estimation of the reciprocal.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> ReciprocalEstimate(this <#=type#> @this) => 1 / @this;

  /// <summary>
  /// Determines whether the specified number is odd.
  /// </summary>
  /// <param name="this">This number.</param>
  /// <returns><c>true</c> if the number is odd; otherwise, <c>false</c>.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  // ReSharper disable once CompareOfFloatsByEqualityOperator
  public static bool IsOdd(this <#=type#> @this) => @this % 2 != 0;
    
  /// <summary>
  /// Determines whether the specified number is even.
  /// </summary>
  /// <param name="this">This number.</param>
  /// <returns><c>true</c> if the number is even; otherwise, <c>false</c>.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  // ReSharper disable once CompareOfFloatsByEqualityOperator
  public static bool IsEven(this <#=type#> @this) => @this % 2 == 0;
<#}#>
  
<#foreach (var type in new[]{"double","decimal"}){#>
    
  /// <summary>Returns the largest integral value less than or equal to the specified decimal number.</summary>
  /// <param name="this">A number.</param>
  /// <returns>The largest integral value less than or equal to <paramref name="this" />.  Note that the method returns an integral value of type <see cref="T:System.Decimal" />.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> Floor(this <#=type#> @this) => Math.Floor(@this);
    
  /// <summary>Returns the smallest integral value that is greater than or equal to the specified decimal number.</summary>
  /// <param name="this">A number.</param>
  /// <returns>The smallest integral value that is greater than or equal to <paramref name="this" />. Note that this method returns a <see cref="T:System.Decimal" /> instead of an integral type.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> Ceiling(this <#=type#> @this) => <#=(type=="float"?"("+type+")":"")#>Math.Ceiling(@this);
    
  /// <summary>Calculates the integral part of a specified decimal number.</summary>
  /// <param name="this">A number to truncate.</param>
  /// <returns>The integral part of <paramref name="this" />; that is, the number that remains after any fractional digits have been discarded.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> Truncate(this <#=type#> @this) => <#=(type=="float"?"("+type+")":"")#>Math.Truncate(@this);
<#}#>
      
<#foreach (var item in new[]{T("double",15),T("decimal",28)}){#>

  /// <summary>Rounds a value to the nearest integral value, and rounds midpoint values to the nearest even number.</summary>
  /// <param name="this">A number to be rounded.</param>
  /// <returns>The integer nearest the <paramref name="this" /> parameter. If the fractional component of <paramref name="this" /> is halfway between two integers, one of which is even and the other odd, the even number is returned.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=item.Item1#> Round(this <#=item.Item1#> @this) => <#=(item.Item1=="float"?"("+item.Item1+")":"")#>Math.Round(@this);

  /// <summary>Rounds a value to the nearest integral value, and rounds midpoint values to the nearest even number.</summary>
  /// <param name="this">A number to be rounded.</param>
  /// <param name="digits">The number of decimal places in the return value.</param>
  /// <returns>The integer nearest the <paramref name="this" /> parameter. If the fractional component of <paramref name="this" /> is halfway between two integers, one of which is even and the other odd, the even number is returned.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=item.Item1#> Round(this <#=item.Item1#> @this, int digits) {
    Against.ValuesOutOfRange(digits, 0, <#=item.Item2#>);

    return <#=(item.Item1=="float"?"("+item.Item1+")":"")#>Math.Round(@this, digits);
  }

  /// <summary>Rounds a value to an integer using the specified rounding convention.</summary>
  /// <param name="this">A number to be rounded.</param>
  /// <param name="method">One of the enumeration values that specifies which rounding strategy to use.</param>
  /// <returns>The integer that <paramref name="this" /> is rounded to.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=item.Item1#> Round(this <#=item.Item1#> @this, MidpointRounding method) => <#=(item.Item1=="float"?"("+item.Item1+")":"")#>Math.Round(@this, method);

  /// <summary>Rounds a value to an integer using the specified rounding convention.</summary>
  /// <param name="this">A number to be rounded.</param>
  /// <param name="digits">The number of decimal places in the return value.</param>
  /// <param name="method">One of the enumeration values that specifies which rounding strategy to use.</param>
  /// <returns>The integer that <paramref name="this" /> is rounded to.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=item.Item1#> Round(this <#=item.Item1#> @this, int digits, MidpointRounding method) {
    Against.ValuesOutOfRange(digits, 0, <#=item.Item2#>);

    return <#=(item.Item1=="float"?"("+item.Item1+")":"")#>Math.Round(@this, digits, method);
  }

<#}#>

<#foreach (var type in new[]{"sbyte","short","int","long","float","double","decimal"}){#>
    
  /// <summary>
  /// Returns the absolute value of the specified value.
  /// </summary>
  /// <param name="this">The number.</param>
  /// <returns>The result of the operation.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> Abs(this <#=type#> @this) => <#=(type=="float"?"(float)":"")#>Math.Abs(@this);

  /// <summary>
  /// Returns the sign (-1, 0, +1) of the specified value.
  /// </summary>
  /// <param name="this">The number.</param>
  /// <returns>The result of the operation.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> Sign(this <#=type#> @this) => <#=(type=="sbyte"||type=="short"?"("+type+")":"")#>(@this < 0 ? -1 : 1);

  /// <summary>
  /// Determines whether the specified value is positive (greater than zero).
  /// </summary>
  /// <param name="this">The value to check.</param>
  /// <returns><c>true</c> if the value is positive; otherwise, <c>false</c>.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsPositive(this <#=type#> @this) => @this > 0;

  /// <summary>
  /// Determines whether the specified value is positive or zero (greater than or equal to zero).
  /// </summary>
  /// <param name="this">The value to check.</param>
  /// <returns><c>true</c> if the value is positive or zero; otherwise, <c>false</c>.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsPositiveOrZero(this <#=type#> @this) => @this >= 0;

  /// <summary>
  /// Determines whether the specified value is negative (below zero).
  /// </summary>
  /// <param name="this">The value to check.</param>
  /// <returns><c>true</c> if the value is negative; otherwise, <c>false</c>.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsNegative(this <#=type#> @this) => @this < 0;

  /// <summary>
  /// Determines whether the specified value is negative or zero (below than or equal to zero).
  /// </summary>
  /// <param name="this">The value to check.</param>
  /// <returns><c>true</c> if the value is negative or zero; otherwise, <c>false</c>.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsNegativeOrZero(this <#=type#> @this) => @this <= 0;

<#}#>
  
<#foreach (var type in new[]{"float","double"}){#>

  /// <summary>
  /// Determines whether the specified <see cref="<#=type#>"/> is a valid numeric value (i.e., not NaN or infinity).
  /// </summary>
  /// <param name="this">The <see cref="<#=type#>"/> value to check.</param>
  /// <returns><see langword="true"/> if the value is finite and numeric; otherwise, <see langword="false"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> value = 3;
  /// bool isNumeric = value.IsNumeric(); // true
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsNumeric(this <#=type#> @this) => !(<#=type#>.IsNaN(@this) || <#=type#>.IsInfinity(@this));

  /// <summary>
  /// Determines whether the specified <see cref="<#=type#>"/> is not a valid numeric value (i.e., NaN or infinity).
  /// </summary>
  /// <param name="this">The <see cref="<#=type#>"/> value to check.</param>
  /// <returns><see langword="true"/> if the value is NaN or infinite; otherwise, <see langword="false"/>.</returns>
  /// <example>
  /// <code>
  /// var value = <#=type#>.NaN;
  /// bool isNonNumeric = value.IsNonNumeric(); // true
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsNonNumeric(this <#=type#> @this) => <#=type#>.IsNaN(@this) || <#=type#>.IsInfinity(@this);
    
  /// <summary>
  /// Determines whether the specified <see cref="<#=type#>"/> value is NaN (Not a Number).
  /// </summary>
  /// <param name="this">The <see cref="<#=type#>"/> value to check.</param>
  /// <returns><see langword="true"/> if the value is NaN; otherwise, <see langword="false"/>.</returns>
  /// <example>
  /// <code>
  /// var value = <#=type#>.NaN;
  /// bool isNaN = value.IsNaN(); // true
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsNaN(this <#=type#> @this) => <#=type#>.IsNaN(@this);

  /// <summary>
  /// Determines whether the specified <see cref="<#=type#>"/> value is infinite (positive or negative infinity).
  /// </summary>
  /// <param name="this">The <see cref="<#=type#>"/> value to check.</param>
  /// <returns><see langword="true"/> if the value is infinite; otherwise, <see langword="false"/>.</returns>
  /// <example>
  /// <code>
  /// var value = <#=type#>.PositiveInfinity;
  /// bool isInfinity = value.IsInfinity(); // true
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsInfinity(this <#=type#> @this) => <#=type#>.IsInfinity(@this);

  /// <summary>
  /// Determines whether the specified <see cref="<#=type#>"/> value is positive infinity.
  /// </summary>
  /// <param name="this">The <see cref="<#=type#>"/> value to check.</param>
  /// <returns><see langword="true"/> if the value is positive infinity; otherwise, <see langword="false"/>.</returns>
  /// <example>
  /// <code>
  /// var value = <#=type#>.PositiveInfinity;
  /// bool isNegInf = value.IsPositiveInfinity(); // true
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsPositiveInfinity(this <#=type#> @this) => <#=type#>.IsPositiveInfinity(@this);

  /// <summary>
  /// Determines whether the specified <see cref="<#=type#>"/> value is negative infinity.
  /// </summary>
  /// <param name="this">The <see cref="<#=type#>"/> value to check.</param>
  /// <returns><see langword="true"/> if the value is negative infinity; otherwise, <see langword="false"/>.</returns>
  /// <example>
  /// <code>
  /// var value = <#=type#>.NegativeInfinity;
  /// bool isNegInf = value.IsNegativeInfinity(); // true
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsNegativeInfinity(this <#=type#> @this) => <#=type#>.IsNegativeInfinity(@this);
    
<#}#>
  
<#foreach (var type in new[]{"sbyte","byte","short","ushort","int","uint","long","ulong","float","double","decimal"}){#>
<#  var needsChecked = !(type is "float" or "double" or "decimal");#>

  /// <summary>
  /// Returns the square of the specified <see cref="<#=type#>"/> value.
  /// </summary>
  /// <param name="this">The value to square.</param>
  /// <returns>The result of <paramref name="this"/> multiplied by itself, cast to <see cref="<#=type#>"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> value = 4;
  /// <#=type#> result = value.Squared(); // result == 16
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> Squared(this <#=type#> @this) => (<#=type#>)<#=(needsChecked ? "unchecked" : string.Empty)#>(@this * @this);
    
  /// <summary>
  /// Returns the cube of the specified <see cref="<#=type#>"/> value.
  /// </summary>
  /// <param name="this">The value to cube.</param>
  /// <returns>The result of <paramref name="this"/> multiplied by itself twice, cast to <see cref="<#=type#>"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> value = 3;
  /// <#=type#> result = value.Cubed(); // result == 27
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> Cubed(this <#=type#> @this) => (<#=type#>)<#=(needsChecked ? "unchecked" : string.Empty)#>(@this * @this * @this);
   
<# if (type != "decimal") { #>
  /// <summary>
  /// Raises the specified <see cref="<#=type#>"/> value to the given exponent.
  /// </summary>
  /// <param name="this">The base value.</param>
  /// <param name="exponent">The exponent to raise the base value to.</param>
  /// <returns>The result of raising <paramref name="this"/> to <paramref name="exponent"/>, cast to <see cref="<#=type#>"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> value = 2;
  /// <#=type#> result = value.Pow(3); // result == 8
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> Pow(this <#=type#> @this,<#=type#> exponent) => (<#=type#>)Math.Pow(@this, exponent);

<# } #>

  /// <summary>
  /// Adds the specified operand to the <see cref="<#=type#>"/> value.
  /// </summary>
  /// <param name="this">The base value.</param>
  /// <param name="operand">The value to add.</param>
  /// <returns>The sum of <paramref name="this"/> and <paramref name="operand"/>, cast to <see cref="<#=type#>"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> result = ((<#=type#>)10).Add(5); // result == 15
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> Add(this <#=type#> @this, <#=type#> operand) => (<#=type#>)<#=(needsChecked ? "unchecked" : string.Empty)#>(@this + operand);

  /// <summary>
  /// Substracts the specified operand from the <see cref="<#=type#>"/> value.
  /// </summary>
  /// <param name="this">The base value.</param>
  /// <param name="minuend">The value to subtract.</param>
  /// <returns>The difference of <paramref name="this"/> and <paramref name="minuend"/>, cast to <see cref="<#=type#>"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> result = ((<#=type#>)10).Subtract(5); // result == 5
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> Subtract(this <#=type#> @this, <#=type#> minuend) => (<#=type#>)<#=(needsChecked ? "unchecked" : string.Empty)#>(@this - minuend);
  
  /// <summary>
  /// Multiplies the <see cref="<#=type#>"/> value by the specified factor.
  /// </summary>
  /// <param name="this">The base value.</param>
  /// <param name="factor">The factor to multiply by.</param>
  /// <returns>The product of <paramref name="this"/> and <paramref name="factor"/>, cast to <see cref="<#=type#>"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> result = ((<#=type#>)5).MultipliedWith(2); // result == 10
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> MultipliedWith(this <#=type#> @this,<#=type#> factor) => (<#=type#>)<#=(needsChecked ? "unchecked" : string.Empty)#>(@this * factor);

  /// <summary>
  /// Divides the <see cref="<#=type#>"/> value by the specified divisor.
  /// </summary>
  /// <param name="this">The dividend.</param>
  /// <param name="divisor">The divisor.</param>
  /// <returns>The quotient of <paramref name="this"/> divided by <paramref name="divisor"/>, cast to <see cref="<#=type#>"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> result = ((<#=type#>)10).DividedBy(2); // result == 5
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> DividedBy(this <#=type#> @this,<#=type#> divisor) => (<#=type#>)(@this / divisor);

  /// <summary>
  /// Determines whether the given value is zero.
  /// </summary>
  /// <param name="this">This value.</param>
  /// <returns><c>true</c> if the value is zero; otherwise, <c>false</c>.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsZero(this <#=type#> @this) => @this == 0;
    
  /// <summary>
  /// Determines whether the given value is not zero.
  /// </summary>
  /// <param name="this">This value.</param>
  /// <returns><c>true</c> if the value is not zero; otherwise, <c>false</c>.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsNotZero(this <#=type#> @this) => @this != 0;

  /// <summary>
  /// Determines whether the <see cref="<#=type#>"/> value is strictly below the specified exclusive upper limit.
  /// </summary>
  /// <param name="this">The value to check.</param>
  /// <param name="exclusiveLimit">The exclusive upper bound.</param>
  /// <returns><see langword="true"/> if <paramref name="this"/> is less than <paramref name="exclusiveLimit"/>; otherwise, <see langword="false"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> result = 5;
  /// bool isBelow = result.IsBelow(10); // true
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsBelow(this <#=type#> @this, <#=type#> exclusiveLimit) => @this < exclusiveLimit;

  /// <summary>
  /// Determines whether the <see cref="<#=type#>"/> value is less than or equal to the specified inclusive upper limit.
  /// </summary>
  /// <param name="this">The value to check.</param>
  /// <param name="inclusiveLimit">The inclusive upper bound.</param>
  /// <returns><see langword="true"/> if <paramref name="this"/> is less than or equal to <paramref name="inclusiveLimit"/>; otherwise, <see langword="false"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> result = 10;
  /// bool isBelowOrEqual = result.IsBelowOrEqual(10); // true
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsBelowOrEqual(this <#=type#> @this, <#=type#> inclusiveLimit) => @this <= inclusiveLimit;

  /// <summary>
  /// Determines whether the <see cref="<#=type#>"/> value is strictly above the specified exclusive lower limit.
  /// </summary>
  /// <param name="this">The value to check.</param>
  /// <param name="exclusiveLimit">The exclusive lower bound.</param>
  /// <returns><see langword="true"/> if <paramref name="this"/> is greater than <paramref name="exclusiveLimit"/>; otherwise, <see langword="false"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> result = 10;
  /// bool isAbove = result.IsAbove(5); // true
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsAbove(this <#=type#> @this, <#=type#> exclusiveLimit) => @this > exclusiveLimit;

  /// <summary>
  /// Determines whether the <see cref="<#=type#>"/> value is greater than or equal to the specified inclusive lower limit.
  /// </summary>
  /// <param name="this">The value to check.</param>
  /// <param name="inclusiveLimit">The inclusive lower bound.</param>
  /// <returns><see langword="true"/> if <paramref name="this"/> is greater than or equal to <paramref name="inclusiveLimit"/>; otherwise, <see langword="false"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> result = 10;
  /// bool isAboveOrEqual = result.IsAboveOrEqual(10); // true
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsAboveOrEqual(this <#=type#> @this, <#=type#> inclusiveLimit) => @this >= inclusiveLimit;

  /// <summary>
  /// Determines whether the <see cref="<#=type#>"/> value lies strictly between two exclusive bounds.
  /// </summary>
  /// <param name="this">The value to check.</param>
  /// <param name="exclusiveLowerLimit">The exclusive lower bound.</param>
  /// <param name="exclusiveUpperLimit">The exclusive upper bound.</param>
  /// <returns><see langword="true"/> if <paramref name="this"/> is strictly between the two bounds; otherwise, <see langword="false"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> result = 5;
  /// bool isBetween = result.IsBetween(1, 10); // true
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsBetween(this <#=type#> @this, <#=type#> exclusiveLowerLimit, <#=type#> exclusiveUpperLimit) => @this > exclusiveLowerLimit && @this < exclusiveUpperLimit;

  /// <summary>
  /// Determines whether the <see cref="<#=type#>"/> value lies within the specified inclusive range.
  /// </summary>
  /// <param name="this">The value to check.</param>
  /// <param name="inclusiveLowerLimit">The inclusive lower bound.</param>
  /// <param name="inclusiveUpperLimit">The inclusive upper bound.</param>
  /// <returns><see langword="true"/> if <paramref name="this"/> lies within the inclusive range; otherwise, <see langword="false"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> result = 5;
  /// bool isInRange = result.IsInRange(1, 5); // true
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsInRange(this <#=type#> @this, <#=type#> inclusiveLowerLimit, <#=type#> inclusiveUpperLimit) => @this >= inclusiveLowerLimit && @this <= inclusiveUpperLimit;

<#}#>

<#foreach (var type in new[]{"float","double"}){#>
<#  foreach (var method in new[]{"Sqrt","Log10","Log","Sin","Cos","Tan","Sinh","Cosh","Tanh"}){#>

  /// <summary>
  /// Calculates the <#=method#> of the specified <see cref="<#=type#>"/> value.
  /// </summary>
  /// <param name="this">The value for which to calculate.</param>
  /// <returns>The result of the operation.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
<#    if(type == "float") {#>
  public static <#=type#> <#=method#>(this <#=type#> @this) => MathF.<#=method#>(@this);
<#    } else {#>
  public static <#=type#> <#=method#>(this <#=type#> @this) => Math.<#=method#>(@this);
<#    }#>
<#  }#>
<#}#>
 
<#foreach (var type in new[]{"sbyte","byte","short","ushort","int","uint","long","ulong","decimal"}){#>

  /// <summary>
  /// Computes a fused multiply-add operation: (<paramref name="this"/> × <paramref name="factor"/> + <paramref name="addend"/>).
  /// </summary>
  /// <param name="this">The base value to multiply.</param>
  /// <param name="factor">The factor to multiply with <paramref name="this"/>.</param>
  /// <param name="addend">The value to add after multiplication.</param>
  /// <returns>The result of the fused multiply-add operation, cast to <see cref="<#=type#>"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> result = ((<#=type#>)2).FusedMultiplyAdd(3, 4); // result == 10
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedMultiplyAdd(this <#=type#> @this, <#=type#> factor, <#=type#> addend) => <#=(type=="sbyte"||type=="byte"||type=="short"||type=="ushort"?$"({type})":string.Empty)#>(@this * factor + addend);

  /// <summary>
  /// Computes a fused multiply-subtract operation: (<paramref name="this"/> × <paramref name="factor"/> - <paramref name="subtrahend"/>).
  /// </summary>
  /// <param name="this">The base value to multiply.</param>
  /// <param name="factor">The factor to multiply with <paramref name="this"/>.</param>
  /// <param name="subtrahend">The value to subtract after multiplication.</param>
  /// <returns>The result of the fused multiply-subtract operation, cast to <see cref="<#=type#>"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> result = ((<#=type#>)2).FusedMultiplySubtract(3, 1); // result == 5
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedMultiplySubtract(this <#=type#> @this, <#=type#> factor, <#=type#> subtrahend) => <#=(type=="sbyte"||type=="byte"||type=="short"||type=="ushort"?$"({type})":string.Empty)#>(@this * factor - subtrahend);

  /// <summary>
  /// Computes a fused divide-add operation: (<paramref name="this"/> ÷ <paramref name="divisor"/> + <paramref name="addend"/>).
  /// </summary>
  /// <param name="this">The dividend value.</param>
  /// <param name="divisor">The divisor value.</param>
  /// <param name="addend">The value to add after division.</param>
  /// <returns>The result of the fused divide-add operation, cast to <see cref="<#=type#>"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> result = ((<#=type#>)10).FusedDivideAdd(2, 3); // result == 8
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedDivideAdd(this <#=type#> @this, <#=type#> divisor, <#=type#> addend) => <#=(type=="sbyte"||type=="byte"||type=="short"||type=="ushort"?$"({type})":string.Empty)#>(@this / divisor + addend);

  /// <summary>
  /// Computes a fused divide-subtract operation: (<paramref name="this"/> ÷ <paramref name="divisor"/> - <paramref name="subtrahend"/>).
  /// </summary>
  /// <param name="this">The dividend value.</param>
  /// <param name="divisor">The divisor value.</param>
  /// <param name="subtrahend">The value to subtract after division.</param>
  /// <returns>The result of the fused divide-subtract operation, cast to <see cref="<#=type#>"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> result = ((<#=type#>)10).FusedDivideSubtract(2, 3); // result == 2
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedDivideSubtract(this <#=type#> @this, <#=type#> divisor, <#=type#> subtrahend) => <#=(type=="sbyte"||type=="byte"||type=="short"||type=="ushort"?$"({type})":string.Empty)#>(@this / divisor - subtrahend);

<#}#>
    
#if SUPPORTS_FMADD
<#foreach (var type in new[]{"float","double"}){#>

  /// <summary>
  /// Computes a fused multiply-add operation: (<paramref name="this"/> × <paramref name="factor"/> + <paramref name="addend"/>).
  /// </summary>
  /// <param name="this">The base value to multiply.</param>
  /// <param name="factor">The factor to multiply with <paramref name="this"/>.</param>
  /// <param name="addend">The value to add after multiplication.</param>
  /// <returns>The result of the fused multiply-add operation, cast to <see cref="<#=type#>"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> result = ((<#=type#>)2).FusedMultiplyAdd(3, 4); // result == 10
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedMultiplyAdd(this <#=type#> @this, <#=type#> factor, <#=type#> addend) => <#=(type=="double"?"Math":"MathF")#>.FusedMultiplyAdd(@this, factor, addend);

  /// <summary>
  /// Computes a fused multiply-subtract operation: (<paramref name="this"/> × <paramref name="factor"/> - <paramref name="subtrahend"/>).
  /// </summary>
  /// <param name="this">The base value to multiply.</param>
  /// <param name="factor">The factor to multiply with <paramref name="this"/>.</param>
  /// <param name="subtrahend">The value to subtract after multiplication.</param>
  /// <returns>The result of the fused multiply-subtract operation, cast to <see cref="<#=type#>"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> result = ((<#=type#>)2).FusedMultiplySubtract(3, 1); // result == 5
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedMultiplySubtract(this <#=type#> @this, <#=type#> factor, <#=type#> subtrahend) => <#=(type=="double"?"Math":"MathF")#>.FusedMultiplyAdd(@this, factor, -subtrahend);

#if SUPPORTS_MATH_RECIPROCAL_ESTIMATE

  /// <summary>
  /// Computes a fused divide-add operation: (<paramref name="this"/> ÷ <paramref name="divisor"/> + <paramref name="addend"/>).
  /// </summary>
  /// <param name="this">The dividend value.</param>
  /// <param name="divisor">The divisor value.</param>
  /// <param name="addend">The value to add after division.</param>
  /// <returns>The result of the fused divide-add operation, cast to <see cref="<#=type#>"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> result = ((<#=type#>)10).FusedDivideAdd(2, 3); // result == 8
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedDivideAdd(this <#=type#> @this, <#=type#> divisor, <#=type#> addend) => <#=(type=="double"?"Math":"MathF")#>.FusedMultiplyAdd(@this, <#=(type=="double"?"Math":"MathF")#>.ReciprocalEstimate(divisor), addend);
  
  /// <summary>
  /// Computes a fused divide-subtract operation: (<paramref name="this"/> ÷ <paramref name="divisor"/> - <paramref name="subtrahend"/>).
  /// </summary>
  /// <param name="this">The dividend value.</param>
  /// <param name="divisor">The divisor value.</param>
  /// <param name="subtrahend">The value to subtract after division.</param>
  /// <returns>The result of the fused divide-subtract operation, cast to <see cref="<#=type#>"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> result = ((<#=type#>)10).FusedDivideSubtract(2, 3); // result == 2
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedDivideSubtract(this <#=type#> @this, <#=type#> divisor, <#=type#> subtrahend) => <#=(type=="double"?"Math":"MathF")#>.FusedMultiplyAdd(@this, <#=(type=="double"?"Math":"MathF")#>.ReciprocalEstimate(divisor), -subtrahend);

#else

  /// <summary>
  /// Computes a fused divide-add operation: (<paramref name="this"/> ÷ <paramref name="divisor"/> + <paramref name="addend"/>).
  /// </summary>
  /// <param name="this">The dividend value.</param>
  /// <param name="divisor">The divisor value.</param>
  /// <param name="addend">The value to add after division.</param>
  /// <returns>The result of the fused divide-add operation, cast to <see cref="<#=type#>"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> result = ((<#=type#>)10).FusedDivideAdd(2, 3); // result == 8
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedDivideAdd(this <#=type#> @this, <#=type#> divisor, <#=type#> addend) => @this / divisor + addend;

  /// <summary>
  /// Computes a fused divide-subtract operation: (<paramref name="this"/> ÷ <paramref name="divisor"/> - <paramref name="subtrahend"/>).
  /// </summary>
  /// <param name="this">The dividend value.</param>
  /// <param name="divisor">The divisor value.</param>
  /// <param name="subtrahend">The value to subtract after division.</param>
  /// <returns>The result of the fused divide-subtract operation, cast to <see cref="<#=type#>"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> result = ((<#=type#>)10).FusedDivideSubtract(2, 3); // result == 2
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedDivideSubtract(this <#=type#> @this, <#=type#> divisor, <#=type#> subtrahend) => @this / divisor - subtrahend;

#endif

<#}#>
#else
<#foreach (var type in new[]{"float","double"}){#>

  /// <summary>
  /// Computes a fused multiply-add operation: (<paramref name="this"/> × <paramref name="factor"/> + <paramref name="addend"/>).
  /// </summary>
  /// <param name="this">The base value to multiply.</param>
  /// <param name="factor">The factor to multiply with <paramref name="this"/>.</param>
  /// <param name="addend">The value to add after multiplication.</param>
  /// <returns>The result of the fused multiply-add operation, cast to <see cref="<#=type#>"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> result = ((<#=type#>)2).FusedMultiplyAdd(3, 4); // result == 10
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedMultiplyAdd(this <#=type#> @this, <#=type#> factor, <#=type#> addend) => @this * factor + addend;

  /// <summary>
  /// Computes a fused multiply-subtract operation: (<paramref name="this"/> × <paramref name="factor"/> - <paramref name="subtrahend"/>).
  /// </summary>
  /// <param name="this">The base value to multiply.</param>
  /// <param name="factor">The factor to multiply with <paramref name="this"/>.</param>
  /// <param name="subtrahend">The value to subtract after multiplication.</param>
  /// <returns>The result of the fused multiply-subtract operation, cast to <see cref="<#=type#>"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> result = ((<#=type#>)2).FusedMultiplySubtract(3, 1); // result == 5
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedMultiplySubtract(this <#=type#> @this, <#=type#> factor, <#=type#> subtrahend) => @this * factor - subtrahend;

  /// <summary>
  /// Computes a fused divide-add operation: (<paramref name="this"/> ÷ <paramref name="divisor"/> + <paramref name="addend"/>).
  /// </summary>
  /// <param name="this">The dividend value.</param>
  /// <param name="divisor">The divisor value.</param>
  /// <param name="addend">The value to add after division.</param>
  /// <returns>The result of the fused divide-add operation, cast to <see cref="<#=type#>"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> result = ((<#=type#>)10).FusedDivideAdd(2, 3); // result == 8
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedDivideAdd(this <#=type#> @this, <#=type#> divisor, <#=type#> addend) => @this / divisor + addend;

  /// <summary>
  /// Computes a fused divide-subtract operation: (<paramref name="this"/> ÷ <paramref name="divisor"/> - <paramref name="subtrahend"/>).
  /// </summary>
  /// <param name="this">The dividend value.</param>
  /// <param name="divisor">The divisor value.</param>
  /// <param name="subtrahend">The value to subtract after division.</param>
  /// <returns>The result of the fused divide-subtract operation, cast to <see cref="<#=type#>"/>.</returns>
  /// <example>
  /// <code>
  /// <#=type#> result = ((<#=type#>)10).FusedDivideSubtract(2, 3); // result == 2
  /// </code>
  /// </example>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedDivideSubtract(this <#=type#> @this, <#=type#> divisor, <#=type#> subtrahend) => @this / divisor - subtrahend;

<#}#>
#endif

  #region fast min/max/avg

<#foreach (var type in new[]{"sbyte","byte","short","ushort","int","uint","long","ulong","float","double","decimal"}){#>

  #region <#=type#>
  /// <summary>
  /// Gets the minimum value from the given ones.
  /// </summary>
  /// <param name="values">The values.</param>
  /// <returns>The min value.</returns>
  public static unsafe <#=type#> Min(params <#=type#>[] values) {
    var count = values.Length;
    if (count <= 0)
      return 0;

    fixed(<#=type#>* startPointer = &values[0]) {
      var result = values[0];
      var offset = startPointer;
      var endPointer = startPointer + count;

#pragma warning disable CS0219 // Variable is assigned but its value is never used
      var chunkSize = 1;
#pragma warning restore CS0219 // Variable is assigned but its value is never used

<#  foreach(var size in new []{ 512, 256, 128, 64 }) {#>
#if SUPPORTS_VECTOR_<#=size#> && SUPPORTS_VECTOR_IS_HARDWARE_ACCELERATED

      chunkSize = Vector<#=size#><<#=type#>>.Count;
      if (Vector<#=size#>.IsHardwareAccelerated && count >= chunkSize * 2) {
        var left = Vector<#=size#>.Load(offset);
        offset += chunkSize;  
        count -= chunkSize;

        do {
          var right = Vector<#=size#>.Load(offset);
          left = Vector<#=size#>.Min(left, right);
          offset += chunkSize;
          count -= chunkSize;
        } while (count >= chunkSize);

        for (var i = 0; i < chunkSize; ++i)
          result = Math.Min(result, left[i]);

      }

#endif
<#  }#>

      // Process any remaining elements
      for (; offset < endPointer; ++offset) 
        result = Math.Min(result, *offset);

      return result;
    }
  }

  /// <summary>
  /// Gets the maximum value from the given ones.
  /// </summary>
  /// <param name="values">The values.</param>
  /// <returns>The max value.</returns>
  public static unsafe <#=type#> Max(params <#=type#>[] values) {
    var count = values.Length;
    if (count <= 0)
      return 0;

    fixed(<#=type#>* startPointer = &values[0]) {
      var result = values[0];
      var offset = startPointer;
      var endPointer = startPointer + count;

#pragma warning disable CS0219 // Variable is assigned but its value is never used
      var chunkSize = 1;
#pragma warning restore CS0219 // Variable is assigned but its value is never used

<#  foreach(var size in new []{ 512, 256, 128, 64 }) {#>
#if SUPPORTS_VECTOR_<#=size#> && SUPPORTS_VECTOR_IS_HARDWARE_ACCELERATED

      chunkSize = Vector<#=size#><<#=type#>>.Count;
      if (Vector<#=size#>.IsHardwareAccelerated && count >= chunkSize * 2) {
        var left = Vector<#=size#>.Load(offset);
        offset += chunkSize;  
        count -= chunkSize;

        do {
          var right = Vector<#=size#>.Load(offset);
          left = Vector<#=size#>.Max(left, right);
          offset += chunkSize;
          count -= chunkSize;
        } while (count >= chunkSize);

        for (var i = 0; i < chunkSize; ++i)
          result = Math.Max(result, left[i]);

      }

#endif
<#  }#>

      // Process any remaining elements
      for (; offset < endPointer; ++offset) 
        result = Math.Max(result, *offset);

      return result;
    }
  }

  /// <summary>
  /// Gets the maximum value from the given ones.
  /// </summary>
  /// <param name="values">The values.</param>
  /// <returns>The max value.</returns>
  public static <#=type#> Average(params <#=type#>[] values) {
    var length = values.Length;
    if (length == 0)
      return 0;

<#
    var tempType = 
      "|decimal|double|ulong|long|".Contains($"|{type}|") 
      ? type 
      : 
        type == "float" 
        ? "double" 
        : 
          "|sbyte|short|int|".Contains($"|{type}|") 
          ? "long" 
          : "ulong"
    ;

    var downCast = type == tempType ? string.Empty : $"({type})";
    var upCast = type == tempType ? string.Empty : $"({tempType})";
#>
    var result = <#=upCast#>values[0];
    for (var i = 1; i < length; ++i) 
      result += values[i];

    return <#=downCast#>(result / (<#=tempType#>)length);
  }

  public static bool IsIn(<#=type#> @this, <#=type#>[] values) {
    var length = values.Length;
    if (length == 0)
      return false;

    for (var i = 0; i < length; ++i) 
      if (values[i] == @this)
        return true;

    return false;
  }

  public static bool IsNotIn(<#=type#> @this, <#=type#>[] values) {
    var length = values.Length;
    if (length == 0)
      return true;

    for (var i = 0; i < length; ++i) 
      if (values[i] == @this)
        return false;

    return true;
  }

  #endregion

<#}#>

  #endregion

}

<#+ 
  private static Tuple<A,B> T<A,B>(A a,B b){ return(Tuple.Create(a,b)); }
  private static Tuple<A,B,C> T<A,B,C>(A a,B b,C c){ return(Tuple.Create(a,b,c)); } 

  private static int GetSizeInBits(string type) => type switch {
    "byte" => 8,
    "sbyte" => 8,
    "ushort" => 16,
    "short" => 16,
    "uint" => 32,
    "int" => 32,
    "ulong" => 64,
    "long" => 64,
    _=>throw new NotSupportedException($"Unknown type: {type}")
  };

  private static string GetUnsignedType(string type) => type switch {
    "sbyte" => "byte",
    "short" => "ushort",
    "int" => "uint",
    "long" => "ulong",
    _=>throw new NotSupportedException($"Unknown type: {type}")
  };
#>