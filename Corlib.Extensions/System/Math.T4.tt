<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#region (c)2010-2042 Hawkynt

// This file is part of Hawkynt's .NET Framework extensions.
// 
// Hawkynt's .NET Framework extensions are free software:
// you can redistribute and/or modify it under the terms
// given in the LICENSE file.
// 
// Hawkynt's .NET Framework extensions is distributed in the hope that
// it will be useful, but WITHOUT ANY WARRANTY without even the implied
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the LICENSE file for more details.
// 
// You should have received a copy of the License along with Hawkynt's
// .NET Framework extensions. If not, see
// <https://github.com/Hawkynt/C--FrameworkExtensions/blob/master/LICENSE>.

#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */

#if SUPPORTS_INLINING
using System.Runtime.CompilerServices;
#endif
using Guard;

// ReSharper disable UnusedMember.Global
// ReSharper disable RedundantCast
// ReSharper disable CompareOfFloatsByEqualityOperator
namespace System;

public static partial class MathEx {
<#foreach (var type in new[]{"byte","sbyte","ushort","short","uint","int","ulong","long"}){#>

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> Bits(this <#=type#> @this, byte index, byte count) {
    var result = @this >> index;
    var andMask = ((<#=type#>)1 << count) - 1;
    result &= andMask;
    return (<#=type#>)result;
  }
    
  /// <summary>
  /// Determines whether the specified number is odd.
  /// </summary>
  /// <param name="this">This number.</param>
  /// <returns><c>true</c> if the number is odd; otherwise, <c>false</c>.</returns>
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsOdd(this <#=type#> @this) => (@this & 1) != 0;
    
  /// <summary>
  /// Determines whether the specified number is even.
  /// </summary>
  /// <param name="this">This number.</param>
  /// <returns><c>true</c> if the number is even; otherwise, <c>false</c>.</returns>
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsEven(this <#=type#> @this) => (@this & 1) == 0;

<#}#>
  
<#foreach (var type in new[]{"float","double","decimal"}){#>
    
  /// <summary>
  /// Calculates 1/x.
  /// </summary>
  /// <param name="this">This number.</param>
  /// <returns>An estimation of the reciprocal.</returns>
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> ReciprocalEstimate(<#=type#> @this) => 1 / @this;

  /// <summary>
  /// Determines whether the specified number is odd.
  /// </summary>
  /// <param name="this">This number.</param>
  /// <returns><c>true</c> if the number is odd; otherwise, <c>false</c>.</returns>
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  // ReSharper disable once CompareOfFloatsByEqualityOperator
  public static bool IsOdd(this <#=type#> @this) => @this % 2 != 0;
    
  /// <summary>
  /// Determines whether the specified number is even.
  /// </summary>
  /// <param name="this">This number.</param>
  /// <returns><c>true</c> if the number is even; otherwise, <c>false</c>.</returns>
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  // ReSharper disable once CompareOfFloatsByEqualityOperator
  public static bool IsEven(this <#=type#> @this) => @this % 2 == 0;
<#}#>
  
<#foreach (var type in new[]{"double","decimal"}){#>
    
  /// <summary>Returns the largest integral value less than or equal to the specified decimal number.</summary>
  /// <param name="this">A number.</param>
  /// <returns>The largest integral value less than or equal to <paramref name="this" />.  Note that the method returns an integral value of type <see cref="T:System.Decimal" />.</returns>
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> Floor(this <#=type#> @this) => Math.Floor(@this);
    
  /// <summary>Returns the smallest integral value that is greater than or equal to the specified decimal number.</summary>
  /// <param name="this">A number.</param>
  /// <returns>The smallest integral value that is greater than or equal to <paramref name="this" />. Note that this method returns a <see cref="T:System.Decimal" /> instead of an integral type.</returns>
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> Ceiling(this <#=type#> @this) => <#=(type=="float"?"("+type+")":"")#>Math.Ceiling(@this);
    
  /// <summary>Calculates the integral part of a specified decimal number.</summary>
  /// <param name="this">A number to truncate.</param>
  /// <returns>The integral part of <paramref name="this" />; that is, the number that remains after any fractional digits have been discarded.</returns>
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> Truncate(this <#=type#> @this) => <#=(type=="float"?"("+type+")":"")#>Math.Truncate(@this);
<#}#>
      
<#foreach (var item in new[]{T("double",15),T("decimal",28)}){#>

  /// <summary>Rounds a value to the nearest integral value, and rounds midpoint values to the nearest even number.</summary>
  /// <param name="this">A number to be rounded.</param>
  /// <returns>The integer nearest the <paramref name="this" /> parameter. If the fractional component of <paramref name="this" /> is halfway between two integers, one of which is even and the other odd, the even number is returned.</returns>
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=item.Item1#> Round(this <#=item.Item1#> @this) => <#=(item.Item1=="float"?"("+item.Item1+")":"")#>Math.Round(@this);

  /// <summary>Rounds a value to the nearest integral value, and rounds midpoint values to the nearest even number.</summary>
  /// <param name="this">A number to be rounded.</param>
  /// <param name="digits">The number of decimal places in the return value.</param>
  /// <returns>The integer nearest the <paramref name="this" /> parameter. If the fractional component of <paramref name="this" /> is halfway between two integers, one of which is even and the other odd, the even number is returned.</returns>
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=item.Item1#> Round(this <#=item.Item1#> @this, int digits) {
    Against.ValuesOutOfRange(digits, 0, <#=item.Item2#>);

    return <#=(item.Item1=="float"?"("+item.Item1+")":"")#>Math.Round(@this, digits);
  }

  /// <summary>Rounds a value to an integer using the specified rounding convention.</summary>
  /// <param name="this">A number to be rounded.</param>
  /// <param name="method">One of the enumeration values that specifies which rounding strategy to use.</param>
  /// <returns>The integer that <paramref name="this" /> is rounded to.</returns>
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=item.Item1#> Round(this <#=item.Item1#> @this, MidpointRounding method) => <#=(item.Item1=="float"?"("+item.Item1+")":"")#>Math.Round(@this, method);

  /// <summary>Rounds a value to an integer using the specified rounding convention.</summary>
  /// <param name="this">A number to be rounded.</param>
  /// <param name="digits">The number of decimal places in the return value.</param>
  /// <param name="method">One of the enumeration values that specifies which rounding strategy to use.</param>
  /// <returns>The integer that <paramref name="this" /> is rounded to.</returns>
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=item.Item1#> Round(this <#=item.Item1#> @this, int digits, MidpointRounding method) {
    Against.ValuesOutOfRange(digits, 0, <#=item.Item2#>);

    return <#=(item.Item1=="float"?"("+item.Item1+")":"")#>Math.Round(@this, digits, method);
  }

<#}#>

<#foreach (var type in new[]{"sbyte","short","int","long","float","double","decimal"}){#>
    
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> Abs(this <#=type#> @this) => <#=(type=="float"?"(float)":"")#>Math.Abs(@this);

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> Sign(this <#=type#> @this) => <#=(type=="sbyte"||type=="short"?"("+type+")":"")#>(@this < 0 ? -1 : 1);

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsPositive(this <#=type#> @this) => @this > 0;

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsPositiveOrZero(this <#=type#> @this) => @this >= 0;

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsNegative(this <#=type#> @this) => @this < 0;

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsNegativeOrZero(this <#=type#> @this) => @this <= 0;

<#}#>
  
<#foreach (var type in new[]{"float","double"}){#>

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsNumeric(this <#=type#> @this) => !(<#=type#>.IsNaN(@this) || <#=type#>.IsInfinity(@this));

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsNonNumeric(this <#=type#> @this) => <#=type#>.IsNaN(@this) || <#=type#>.IsInfinity(@this);
    
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsNaN(this <#=type#> @this) => <#=type#>.IsNaN(@this);

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsInfinity(this <#=type#> @this) => <#=type#>.IsInfinity(@this);

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsPositiveInfinity(this <#=type#> @this) => <#=type#>.IsPositiveInfinity(@this);

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsNegativeInfinity(this <#=type#> @this) => <#=type#>.IsNegativeInfinity(@this);
    
<#}#>
  
<#foreach (var type in new[]{"sbyte","byte","short","ushort","int","uint","long","ulong","float","double","decimal"}){#>
    
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> Squared(this <#=type#> @this) => (<#=type#>)(@this * @this);
    
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> Cubed(this <#=type#> @this) => (<#=type#>)(@this * @this * @this);
    
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> Pow(this <#=type#> @this,<#=type#> exponent) => (<#=type#>)Math.Pow(<#=(type=="decimal"?"(double)":"")#>@this,<#=(type=="decimal"?"(double)":"")#>exponent);

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> MultipliedWith(this <#=type#> @this,<#=type#> factor) => (<#=type#>)(@this * factor);

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> DividedBy(this <#=type#> @this,<#=type#> divisor) => (<#=type#>)(@this / divisor);

  /// <summary>
  /// Determines whether the given value is zero.
  /// </summary>
  /// <param name="this">This value.</param>
  /// <returns><c>true</c> if the value is zero; otherwise, <c>false</c>.</returns>
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsZero(this <#=type#> @this) => @this == 0;
    
  /// <summary>
  /// Determines whether the given value is not zero.
  /// </summary>
  /// <param name="this">This value.</param>
  /// <returns><c>true</c> if the value is not zero; otherwise, <c>false</c>.</returns>
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsNotZero(this <#=type#> @this) => @this != 0;

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsBelow(this <#=type#> @this, <#=type#> exclusiveLimit) => @this < exclusiveLimit;

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsBelowOrEqual(this <#=type#> @this, <#=type#> inclusiveLimit) => @this <= inclusiveLimit;

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsAbove(this <#=type#> @this, <#=type#> exclusiveLimit) => @this > exclusiveLimit;

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsAboveOrEqual(this <#=type#> @this, <#=type#> inclusiveLimit) => @this >= inclusiveLimit;

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsBetween(this <#=type#> @this, <#=type#> exclusiveLowerLimit, <#=type#> exclusiveUpperLimit) => @this > exclusiveLowerLimit && @this < exclusiveUpperLimit;

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsInRange(this <#=type#> @this, <#=type#> inclusiveLowerLimit, <#=type#> inclusiveUpperLimit) => @this >= inclusiveLowerLimit && @this <= inclusiveUpperLimit;

<#}#>

<#foreach (var type in new[]{"float","double"}){#>
<#  foreach (var method in new[]{"Sqrt","Log10","Log","Sin","Cos","Tan","Sinh","Cosh","Tanh"}){#>

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
<#    if(type == "float") {#>
#if SUPPORTS_MATHF
  public static <#=type#> <#=method#>(this <#=type#> @this) => MathF.<#=method#>(@this);
#else
  public static <#=type#> <#=method#>(this <#=type#> @this) => (<#=type#>)Math.<#=method#>(@this);
#endif
<#    } else {#>
  public static <#=type#> <#=method#>(this <#=type#> @this) => Math.<#=method#>(@this);
<#    }#>
<#  }#>
<#}#>
 
<#foreach (var type in new[]{"sbyte","byte","short","ushort","int","uint","long","ulong","decimal"}){#>

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> FusedMultiplyAdd(this <#=type#> @this, <#=type#> mul, <#=type#> add) => <#=(type=="sbyte"||type=="byte"||type=="short"||type=="ushort"?$"({type})":string.Empty)#>(@this * mul + add);

<#}#>
    
#if SUPPORTS_FMADD
<#foreach (var type in new[]{"float","double"}){#>

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> FusedMultiplyAdd(this <#=type#> @this, <#=type#> mul, <#=type#> add) => <#=(type=="double"?"Math":"MathF")#>.FusedMultiplyAdd(@this, mul, add);
<#}#>

#else
<#foreach (var type in new[]{"float","double"}){#>

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> FusedMultiplyAdd(this <#=type#> @this, <#=type#> mul, <#=type#> add) => @this * mul + add;
<#}#>

#endif

  #region fast min/max/avg

<#foreach (var type in new[]{"sbyte","byte","short","ushort","int","uint","long","ulong","float","double","decimal"}){#>

  #region <#=type#>
  /// <summary>
  /// Gets the minimum value from the given ones.
  /// </summary>
  /// <param name="values">The values.</param>
  /// <returns>The min value.</returns>
  public static <#=type#> Min(params <#=type#>[] values) {
    var length = values.Length;
    if (length == 0)
      return default;

    var result = values[0];
    for (var i = 1; i < length; ++i) 
      if (values[i] < result)
        result = values[i];

    return result;
  }

  /// <summary>
  /// Gets the maximum value from the given ones.
  /// </summary>
  /// <param name="values">The values.</param>
  /// <returns>The max value.</returns>
  public static <#=type#> Max(params <#=type#>[] values) {
    var length = values.Length;
    if (length == 0)
      return default;

    var result = values[0];
    for (var i = 1; i < length; ++i) 
      if (values[i] > result)
        result = values[i];

    return result;
  }

  /// <summary>
  /// Gets the maximum value from the given ones.
  /// </summary>
  /// <param name="values">The values.</param>
  /// <returns>The max value.</returns>
  public static <#=type#> Average(params <#=type#>[] values) {
    var length = values.Length;
    if (length == 0)
      return default;

<#
    var tempType = 
      "|decimal|double|ulong|long|".Contains($"|{type}|") 
      ? type 
      : 
        type == "float" 
        ? "double" 
        : 
          "|sbyte|short|int|".Contains($"|{type}|") 
          ? "long" 
          : "ulong"
    ;

    var downCast = type == tempType ? string.Empty : $"({type})";
    var upCast = type == tempType ? string.Empty : $"({tempType})";
#>
    var result = <#=upCast#>values[0];
    for (var i = 1; i < length; ++i) 
      result += values[i];

    return <#=downCast#>(result / (<#=tempType#>)length);
  }

  public static bool IsIn(<#=type#> @this, <#=type#>[] values) {
    var length = values.Length;
    if (length == 0)
      return false;

    for (var i = 0; i < length; ++i) 
      if (values[i] == @this)
        return true;

    return false;
  }

  public static bool IsNotIn(<#=type#> @this, <#=type#>[] values) {
    var length = values.Length;
    if (length == 0)
      return true;

    for (var i = 0; i < length; ++i) 
      if (values[i] == @this)
        return false;

    return true;
  }

  #endregion

<#}#>

  #endregion

}

<#+ 
  private static Tuple<A,B> T<A,B>(A a,B b){ return(Tuple.Create(a,b)); }
  private static Tuple<A,B,C> T<A,B,C>(A a,B b,C c){ return(Tuple.Create(a,b,c)); } 
#>