<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#region (c)2010-2042 Hawkynt
/*
  This file is part of Hawkynt's .NET Framework extensions.

    Hawkynt's .NET Framework extensions are free software: 
    you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Hawkynt's .NET Framework extensions is distributed in the hope that 
    it will be useful, but WITHOUT ANY WARRANTY; without even the implied 
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
    the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Hawkynt's .NET Framework extensions.  
    If not, see <http://www.gnu.org/licenses/>.
*/
#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */

#if NET40_OR_GREATER || NET5_0_OR_GREATER || NETCOREAPP || NETSTANDARD
#define SUPPORTS_CONTRACTS 
#endif

#if NET5_0_OR_GREATER || NETCOREAPP
#define SUPPORTS_FMADD
#define SUPPORTS_MATHF
#endif

#if NET45_OR_GREATER || NET5_0_OR_GREATER || NETCOREAPP || NETSTANDARD
#define SUPPORTS_INLINING 
#endif

#if SUPPORTS_CONTRACTS
using System.Diagnostics.Contracts;
#endif
#if SUPPORTS_INLINING
using System.Runtime.CompilerServices;
#endif
using word = System.UInt16;
using dword = System.UInt32;
using qword = System.UInt64;

// ReSharper disable UnusedMember.Global
// ReSharper disable RedundantCast
// ReSharper disable CompareOfFloatsByEqualityOperator
namespace System {

#if COMPILE_TO_EXTENSION_DLL
  public
#else
  internal
#endif
  static partial class MathEx {
  <# foreach (var type in new[]{"byte","sbyte","word","short","dword","int","qword","long"}){#>

#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=type#> Bits(this <#=type#> @this, byte index, byte count) {
      var result = @this >> index;
      var andMask = ((<#=type#>)1 << count) - 1;
      result &= andMask;
      return (<#=type#>)result;
    }
    
    /// <summary>
    /// Determines whether the specified number is odd.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is odd; otherwise, <c>false</c>.</returns>
#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsOdd(this <#=type#> @this) => (@this & 1) != 0;
    
    /// <summary>
    /// Determines whether the specified number is even.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is even; otherwise, <c>false</c>.</returns>
#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsEven(this <#=type#> @this) => (@this & 1) == 0;

  <#}#>
  
  <# foreach (var type in new[]{"float","double","decimal"}){#>
    
    /// <summary>
    /// Determines whether the specified number is odd.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is odd; otherwise, <c>false</c>.</returns>
#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    // ReSharper disable once CompareOfFloatsByEqualityOperator
    public static bool IsOdd(this <#=type#> @this) => @this % 2 != 0;
    
    /// <summary>
    /// Determines whether the specified number is even.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is even; otherwise, <c>false</c>.</returns>
#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    // ReSharper disable once CompareOfFloatsByEqualityOperator
    public static bool IsEven(this <#=type#> @this) => @this % 2 == 0;
  <#}#>
  
  <# foreach (var type in new[]{"double","decimal"}){#>
    
#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=type#> Floor(this <#=type#> @this) => Math.Floor(@this);
    
#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=type#> Ceiling(this <#=type#> @this) => <#=(type=="float"?"("+type+")":"")#>Math.Ceiling(@this);
    
#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=type#> Truncate(this <#=type#> @this) => <#=(type=="float"?"("+type+")":"")#>Math.Truncate(@this);
  <#}#>
      
  <# foreach (var item in new[]{T("double",15),T("decimal",28)}){#>

#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=item.Item1#> Round(this <#=item.Item1#> @this) => <#=(item.Item1=="float"?"("+item.Item1+")":"")#>Math.Round(@this);

#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=item.Item1#> Round(this <#=item.Item1#> @this, int digits) {
#if SUPPORTS_CONTRACTS
      Contract.Requires(digits >= 0 && digits <= <#=item.Item2#>);
#endif
      return <#=(item.Item1=="float"?"("+item.Item1+")":"")#>Math.Round(@this, digits);
    }

#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=item.Item1#> Round(this <#=item.Item1#> @this, MidpointRounding method) => <#=(item.Item1=="float"?"("+item.Item1+")":"")#>Math.Round(@this, method);

#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=item.Item1#> Round(this <#=item.Item1#> @this, int digits, MidpointRounding method) {
#if SUPPORTS_CONTRACTS
      Contract.Requires(digits >= 0 && digits <= <#=item.Item2#>);
#endif
      return <#=(item.Item1=="float"?"("+item.Item1+")":"")#>Math.Round(@this, digits, method);
    }

  <#}#>

  <# foreach (var type in new[]{"sbyte","short","int","long","float","double","decimal"}){#>
    
#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=type#> Abs(this <#=type#> @this) => <#=(type=="float"?"(float)":"")#>Math.Abs(@this);

#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=type#> Sign(this <#=type#> @this) => <#=(type=="sbyte"||type=="short"?"("+type+")":"")#>(@this < 0 ? -1 : 1);

  <#}#>
  
  <# foreach (var type in new[]{"float","double"}){#>
    
#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsNaN(this <#=type#> @this) => <#=type#>.IsNaN(@this);

#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsInfinity(this <#=type#> @this) => <#=type#>.IsInfinity(@this);

#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsPositiveInfinity(this <#=type#> @this) => <#=type#>.IsPositiveInfinity(@this);

#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsNegativeInfinity(this <#=type#> @this) => <#=type#>.IsNegativeInfinity(@this);
    
  <#}#>
  
  <# foreach (var type in new[]{"sbyte","byte","short","word","int","dword","long","qword","float","double","decimal"}){#>
    
#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=type#> Squared(this <#=type#> @this) => (<#=type#>)(@this * @this);
    
#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=type#> Cubed(this <#=type#> @this) => (<#=type#>)(@this * @this * @this);
    
#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=type#> ToThePower(this <#=type#> @this,<#=type#> exponent) => (<#=type#>)Math.Pow(<#=(type=="decimal"?"(double)":"")#>@this,<#=(type=="decimal"?"(double)":"")#>exponent);

#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=type#> MultipliedWith(this <#=type#> @this,<#=type#> factor) => (<#=type#>)(@this * factor);

#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=type#> DividedBy(this <#=type#> @this,<#=type#> divisor) => (<#=type#>)(@this / divisor);

    /// <summary>
    /// Determines whether the given value is zero.
    /// </summary>
    /// <param name="this">This value.</param>
    /// <returns><c>true</c> if the value is zero; otherwise, <c>false</c>.</returns>
#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsZero(this <#=type#> @this) => @this == 0;
    
    /// <summary>
    /// Determines whether the given value is not zero.
    /// </summary>
    /// <param name="this">This value.</param>
    /// <returns><c>true</c> if the value is not zero; otherwise, <c>false</c>.</returns>
#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsNotZero(this <#=type#> @this) => @this != 0;

  <#}#>

  <# foreach (var method in new[]{"Sqrt","Log10","Log","Sin","Cos","Tan","Sinh","Cosh","Tanh"}){#>

#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static double <#=method#>(this double @this) => Math.<#=method#>(@this);
  <#}#>
 
  <# foreach (var type in new[]{"sbyte","byte","short","word","int","dword","long","qword","decimal"}){#>

  #if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
  #endif
    public static <#=type#> MultiplyAdd(this <#=type#> @this, <#=type#> mul, <#=type#> add) => <#=(type=="sbyte"||type=="byte"||type=="short"||type=="word"?$"({type})":string.Empty)#>(@this * mul + add);

  <#}#>
    
#if SUPPORTS_FMADD
  <# foreach (var type in new[]{"float","double"}){#>

  #if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
  #endif
    public static <#=type#> MultiplyAdd(this <#=type#> @this, <#=type#> mul, <#=type#> add) => <#=(type=="double"?"Math":"MathF")#>.FusedMultiplyAdd(@this, mul, add);
  <#}#>

#else
  <# foreach (var type in new[]{"float","double"}){#>

  #if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
  #endif
    public static <#=type#> MultiplyAdd(this <#=type#> @this, <#=type#> mul, <#=type#> add) => @this * mul + add;
  <#}#>

#endif

    #region fast min/max

  <# foreach (var type in new[]{"sbyte","byte","short","word","int","dword","long","qword","float","double","decimal"}){#>

    #region <#=type#>
    /// <summary>
    /// Gets the minimum value from the given ones.
    /// </summary>
    /// <param name="values">The values.</param>
    /// <returns>The min value.</returns>
#if NET40_OR_GREATER
    [Pure]
#endif
    public static <#=type#> Min(params <#=type#>[] values) {
      var length = values.Length;
      if (length == 0)
        return default(<#=type#>);

      var result = values[0];
      for (var i = 1; i < length; ++i) 
        if (values[i] < result)
          result = values[i];

      return result;
    }

    /// <summary>
    /// Gets the maximum value from the given ones.
    /// </summary>
    /// <param name="values">The values.</param>
    /// <returns>The max value.</returns>
#if NET40_OR_GREATER
    [Pure]
#endif
    public static <#=type#> Max(params <#=type#>[] values) {
      var length = values.Length;
      if (length == 0)
        return default(<#=type#>);

      var result = values[0];
      for (var i = 1; i < length; ++i) 
        if (values[i] > result)
          result = values[i];

      return result;
    }

#if NET40_OR_GREATER
    [Pure]
#endif
    public static bool IsIn(<#=type#> @this, <#=type#>[] values) {
      var length = values.Length;
      if (length == 0)
        return false;

      for (var i = 0; i < length; ++i) 
        if (values[i] == @this)
          return true;

      return false;
    }

#if NET40_OR_GREATER
    [Pure]
#endif
    public static bool IsNotIn(<#=type#> @this, <#=type#>[] values) {
      var length = values.Length;
      if (length == 0)
        return true;

      for (var i = 0; i < length; ++i) 
        if (values[i] == @this)
          return false;

      return true;
    }

#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsBetween(<#=type#> @this, <#=type#> lowerBoundary, <#=type#> upperBoundary) => lowerBoundary<@this && @this<upperBoundary;
    
#if NET40_OR_GREATER
    [Pure]
#endif
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsInRange(<#=type#> @this, <#=type#> lowerBoundary, <#=type#> upperBoundary) => lowerBoundary<=@this && @this<=upperBoundary;

    #endregion

  <#}#>

    #endregion

  }
}
<#+ private static Tuple<A,B> T<A,B>(A a,B b){ return(Tuple.Create(a,b)); } #>
<#+ private static Tuple<A,B,C> T<A,B,C>(A a,B b,C c){ return(Tuple.Create(a,b,c)); } #>