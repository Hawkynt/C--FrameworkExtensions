<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#region (c)2010-2042 Hawkynt
/*
  This file is part of Hawkynt's .NET Framework extensions.

    Hawkynt's .NET Framework extensions are free software: 
    you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Hawkynt's .NET Framework extensions is distributed in the hope that 
    it will be useful, but WITHOUT ANY WARRANTY; without even the implied 
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
    the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Hawkynt's .NET Framework extensions.  
    If not, see <http://www.gnu.org/licenses/>.
*/
#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */

#if SUPPORTS_CONTRACTS
using System.Diagnostics.Contracts;
#endif
#if SUPPORTS_INLINING
using System.Runtime.CompilerServices;
#endif
using word = System.UInt16;
using dword = System.UInt32;
using qword = System.UInt64;

// ReSharper disable UnusedMember.Global
// ReSharper disable RedundantCast
// ReSharper disable CompareOfFloatsByEqualityOperator
namespace System;

public static partial class MathEx {
<# foreach (var type in new[]{"byte","sbyte","word","short","dword","int","qword","long"}){#>

#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> Bits(this <#=type#> @this, byte index, byte count) {
    var result = @this >> index;
    var andMask = ((<#=type#>)1 << count) - 1;
    result &= andMask;
    return (<#=type#>)result;
  }
    
  /// <summary>
  /// Determines whether the specified number is odd.
  /// </summary>
  /// <param name="this">This number.</param>
  /// <returns><c>true</c> if the number is odd; otherwise, <c>false</c>.</returns>
#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsOdd(this <#=type#> @this) => (@this & 1) != 0;
    
  /// <summary>
  /// Determines whether the specified number is even.
  /// </summary>
  /// <param name="this">This number.</param>
  /// <returns><c>true</c> if the number is even; otherwise, <c>false</c>.</returns>
#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsEven(this <#=type#> @this) => (@this & 1) == 0;

<#}#>
  
<# foreach (var type in new[]{"float","double","decimal"}){#>
    
  /// <summary>
  /// Calculates 1/x.
  /// </summary>
  /// <param name="this">This number.</param>
  /// <returns>An estimation of the reciprocal.</returns>
#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> ReciprocalEstimate(<#=type#> @this) => 1 / @this;

  /// <summary>
  /// Determines whether the specified number is odd.
  /// </summary>
  /// <param name="this">This number.</param>
  /// <returns><c>true</c> if the number is odd; otherwise, <c>false</c>.</returns>
#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  // ReSharper disable once CompareOfFloatsByEqualityOperator
  public static bool IsOdd(this <#=type#> @this) => @this % 2 != 0;
    
  /// <summary>
  /// Determines whether the specified number is even.
  /// </summary>
  /// <param name="this">This number.</param>
  /// <returns><c>true</c> if the number is even; otherwise, <c>false</c>.</returns>
#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  // ReSharper disable once CompareOfFloatsByEqualityOperator
  public static bool IsEven(this <#=type#> @this) => @this % 2 == 0;
<#}#>
  
<# foreach (var type in new[]{"double","decimal"}){#>
    
  /// <summary>Returns the largest integral value less than or equal to the specified decimal number.</summary>
  /// <param name="this">A number.</param>
  /// <returns>The largest integral value less than or equal to <paramref name="this" />.  Note that the method returns an integral value of type <see cref="T:System.Decimal" />.</returns>
#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> Floor(this <#=type#> @this) => Math.Floor(@this);
    
  /// <summary>Returns the smallest integral value that is greater than or equal to the specified decimal number.</summary>
  /// <param name="this">A number.</param>
  /// <returns>The smallest integral value that is greater than or equal to <paramref name="this" />. Note that this method returns a <see cref="T:System.Decimal" /> instead of an integral type.</returns>
#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> Ceiling(this <#=type#> @this) => <#=(type=="float"?"("+type+")":"")#>Math.Ceiling(@this);
    
  /// <summary>Calculates the integral part of a specified decimal number.</summary>
  /// <param name="this">A number to truncate.</param>
  /// <returns>The integral part of <paramref name="this" />; that is, the number that remains after any fractional digits have been discarded.</returns>
#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> Truncate(this <#=type#> @this) => <#=(type=="float"?"("+type+")":"")#>Math.Truncate(@this);
<#}#>
      
<# foreach (var item in new[]{T("double",15),T("decimal",28)}){#>

  /// <summary>Rounds a value to the nearest integral value, and rounds midpoint values to the nearest even number.</summary>
  /// <param name="this">A number to be rounded.</param>
  /// <returns>The integer nearest the <paramref name="this" /> parameter. If the fractional component of <paramref name="this" /> is halfway between two integers, one of which is even and the other odd, the even number is returned.</returns>
#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=item.Item1#> Round(this <#=item.Item1#> @this) => <#=(item.Item1=="float"?"("+item.Item1+")":"")#>Math.Round(@this);

  /// <summary>Rounds a value to the nearest integral value, and rounds midpoint values to the nearest even number.</summary>
  /// <param name="this">A number to be rounded.</param>
  /// <param name="digits">The number of decimal places in the return value.</param>
  /// <returns>The integer nearest the <paramref name="this" /> parameter. If the fractional component of <paramref name="this" /> is halfway between two integers, one of which is even and the other odd, the even number is returned.</returns>
#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=item.Item1#> Round(this <#=item.Item1#> @this, int digits) {
#if SUPPORTS_CONTRACTS
    Contract.Requires(digits is >= 0 and <= <#=item.Item2#>);
#endif
    return <#=(item.Item1=="float"?"("+item.Item1+")":"")#>Math.Round(@this, digits);
  }

  /// <summary>Rounds a value to an integer using the specified rounding convention.</summary>
  /// <param name="this">A number to be rounded.</param>
  /// <param name="method">One of the enumeration values that specifies which rounding strategy to use.</param>
  /// <returns>The integer that <paramref name="this" /> is rounded to.</returns>
#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=item.Item1#> Round(this <#=item.Item1#> @this, MidpointRounding method) => <#=(item.Item1=="float"?"("+item.Item1+")":"")#>Math.Round(@this, method);

  /// <summary>Rounds a value to an integer using the specified rounding convention.</summary>
  /// <param name="this">A number to be rounded.</param>
  /// <param name="digits">The number of decimal places in the return value.</param>
  /// <param name="method">One of the enumeration values that specifies which rounding strategy to use.</param>
  /// <returns>The integer that <paramref name="this" /> is rounded to.</returns>
#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=item.Item1#> Round(this <#=item.Item1#> @this, int digits, MidpointRounding method) {
#if SUPPORTS_CONTRACTS
    Contract.Requires(digits is >= 0 and <= <#=item.Item2#>);
#endif
    return <#=(item.Item1=="float"?"("+item.Item1+")":"")#>Math.Round(@this, digits, method);
  }

<#}#>

<# foreach (var type in new[]{"sbyte","short","int","long","float","double","decimal"}){#>
    
#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> Abs(this <#=type#> @this) => <#=(type=="float"?"(float)":"")#>Math.Abs(@this);

#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> Sign(this <#=type#> @this) => <#=(type=="sbyte"||type=="short"?"("+type+")":"")#>(@this < 0 ? -1 : 1);

#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsPositive(this <#=type#> @this) => @this > 0;

#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsPositiveOrZero(this <#=type#> @this) => @this >= 0;

#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsNegative(this <#=type#> @this) => @this < 0;

#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsNegativeOrZero(this <#=type#> @this) => @this <= 0;

<#}#>
  
<# foreach (var type in new[]{"float","double"}){#>

#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsNumeric(this <#=type#> @this) => !(<#=type#>.IsNaN(@this) || <#=type#>.IsInfinity(@this));

#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsNonNumeric(this <#=type#> @this) => <#=type#>.IsNaN(@this) || <#=type#>.IsInfinity(@this);
    
#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsNaN(this <#=type#> @this) => <#=type#>.IsNaN(@this);

#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsInfinity(this <#=type#> @this) => <#=type#>.IsInfinity(@this);

#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsPositiveInfinity(this <#=type#> @this) => <#=type#>.IsPositiveInfinity(@this);

#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsNegativeInfinity(this <#=type#> @this) => <#=type#>.IsNegativeInfinity(@this);
    
<#}#>
  
<# foreach (var type in new[]{"sbyte","byte","short","word","int","dword","long","qword","float","double","decimal"}){#>
    
#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> Squared(this <#=type#> @this) => (<#=type#>)(@this * @this);
    
#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> Cubed(this <#=type#> @this) => (<#=type#>)(@this * @this * @this);
    
#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> Pow(this <#=type#> @this,<#=type#> exponent) => (<#=type#>)Math.Pow(<#=(type=="decimal"?"(double)":"")#>@this,<#=(type=="decimal"?"(double)":"")#>exponent);

#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> MultipliedWith(this <#=type#> @this,<#=type#> factor) => (<#=type#>)(@this * factor);

#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> DividedBy(this <#=type#> @this,<#=type#> divisor) => (<#=type#>)(@this / divisor);

  /// <summary>
  /// Determines whether the given value is zero.
  /// </summary>
  /// <param name="this">This value.</param>
  /// <returns><c>true</c> if the value is zero; otherwise, <c>false</c>.</returns>
#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsZero(this <#=type#> @this) => @this == 0;
    
  /// <summary>
  /// Determines whether the given value is not zero.
  /// </summary>
  /// <param name="this">This value.</param>
  /// <returns><c>true</c> if the value is not zero; otherwise, <c>false</c>.</returns>
#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsNotZero(this <#=type#> @this) => @this != 0;

#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsBelow(this <#=type#> @this, <#=type#> exclusiveLimit) => @this < exclusiveLimit;

#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsBelowOrEqual(this <#=type#> @this, <#=type#> inclusiveLimit) => @this <= inclusiveLimit;

#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsAbove(this <#=type#> @this, <#=type#> exclusiveLimit) => @this > exclusiveLimit;

#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsAboveOrEqual(this <#=type#> @this, <#=type#> inclusiveLimit) => @this >= inclusiveLimit;

#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsBetween(this <#=type#> @this, <#=type#> exclusiveLowerLimit, <#=type#> exclusiveUpperLimit) => @this > exclusiveLowerLimit && @this < exclusiveUpperLimit;

#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static bool IsInRange(this <#=type#> @this, <#=type#> inclusiveLowerLimit, <#=type#> inclusiveUpperLimit) => @this >= inclusiveLowerLimit && @this <= inclusiveUpperLimit;

<#}#>

<# foreach (var method in new[]{"Sqrt","Log10","Log","Sin","Cos","Tan","Sinh","Cosh","Tanh"}){#>

#if SUPPORTS_CONTRACTS
  [Pure]
#endif
#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static double <#=method#>(this double @this) => Math.<#=method#>(@this);
<#}#>
 
<# foreach (var type in new[]{"sbyte","byte","short","word","int","dword","long","qword","decimal"}){#>

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> FusedMultiplyAdd(this <#=type#> @this, <#=type#> mul, <#=type#> add) => <#=(type=="sbyte"||type=="byte"||type=="short"||type=="word"?$"({type})":string.Empty)#>(@this * mul + add);

<#}#>
    
#if SUPPORTS_FMADD
<# foreach (var type in new[]{"float","double"}){#>

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> FusedMultiplyAdd(this <#=type#> @this, <#=type#> mul, <#=type#> add) => <#=(type=="double"?"Math":"MathF")#>.FusedMultiplyAdd(@this, mul, add);
<#}#>

#else
<# foreach (var type in new[]{"float","double"}){#>

#if SUPPORTS_INLINING
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
  public static <#=type#> FusedMultiplyAdd(this <#=type#> @this, <#=type#> mul, <#=type#> add) => @this * mul + add;
<#}#>

#endif

  #region fast min/max/avg

<# foreach (var type in new[]{"sbyte","byte","short","word","int","dword","long","qword","float","double","decimal"}){#>

  #region <#=type#>
  /// <summary>
  /// Gets the minimum value from the given ones.
  /// </summary>
  /// <param name="values">The values.</param>
  /// <returns>The min value.</returns>
#if SUPPORTS_CONTRACTS
  [Pure]
#endif
  public static <#=type#> Min(params <#=type#>[] values) {
    var length = values.Length;
    if (length == 0)
      return default;

    var result = values[0];
    for (var i = 1; i < length; ++i) 
      if (values[i] < result)
        result = values[i];

    return result;
  }

  /// <summary>
  /// Gets the maximum value from the given ones.
  /// </summary>
  /// <param name="values">The values.</param>
  /// <returns>The max value.</returns>
#if SUPPORTS_CONTRACTS
  [Pure]
#endif
  public static <#=type#> Max(params <#=type#>[] values) {
    var length = values.Length;
    if (length == 0)
      return default;

    var result = values[0];
    for (var i = 1; i < length; ++i) 
      if (values[i] > result)
        result = values[i];

    return result;
  }

  /// <summary>
  /// Gets the maximum value from the given ones.
  /// </summary>
  /// <param name="values">The values.</param>
  /// <returns>The max value.</returns>
#if SUPPORTS_CONTRACTS
  [Pure]
#endif
  public static <#=type#> Average(params <#=type#>[] values) {
    var length = values.Length;
    if (length == 0)
      return default;

<#
    var tempType = 
      "|decimal|double|qword|long|".Contains($"|{type}|") 
      ? type 
      : 
        type == "float" 
        ? "double" 
        : 
          "|sbyte|short|int|".Contains($"|{type}|") 
          ? "long" 
          : "qword"
    ;

    var downCast = type == tempType ? string.Empty : $"({type})";
    var upCast = type == tempType ? string.Empty : $"({tempType})";
#>
    var result = <#=upCast#>values[0];
    for (var i = 1; i < length; ++i) 
      result += values[i];

    return <#=downCast#>(result / (<#=tempType#>)length);
  }

#if SUPPORTS_CONTRACTS
  [Pure]
#endif
  public static bool IsIn(<#=type#> @this, <#=type#>[] values) {
    var length = values.Length;
    if (length == 0)
      return false;

    for (var i = 0; i < length; ++i) 
      if (values[i] == @this)
        return true;

    return false;
  }

#if SUPPORTS_CONTRACTS
  [Pure]
#endif
  public static bool IsNotIn(<#=type#> @this, <#=type#>[] values) {
    var length = values.Length;
    if (length == 0)
      return true;

    for (var i = 0; i < length; ++i) 
      if (values[i] == @this)
        return false;

    return true;
  }

  #endregion

<#}#>

  #endregion

}

<#+ 
  private static Tuple<A,B> T<A,B>(A a,B b){ return(Tuple.Create(a,b)); }
  private static Tuple<A,B,C> T<A,B,C>(A a,B b,C c){ return(Tuple.Create(a,b,c)); } 
#>