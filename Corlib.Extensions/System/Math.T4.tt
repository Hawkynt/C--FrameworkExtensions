<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Runtime.InteropServices" #>
<#@ output extension=".cs" #>
#region (c)2010-2042 Hawkynt

// This file is part of Hawkynt's .NET Framework extensions.
// 
// Hawkynt's .NET Framework extensions are free software:
// you can redistribute and/or modify it under the terms
// given in the LICENSE file.
// 
// Hawkynt's .NET Framework extensions is distributed in the hope that
// it will be useful, but WITHOUT ANY WARRANTY without even the implied
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the LICENSE file for more details.
// 
// You should have received a copy of the License along with Hawkynt's
// .NET Framework extensions. If not, see
// <https://github.com/Hawkynt/C--FrameworkExtensions/blob/master/LICENSE>.

#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */

using System.Runtime.CompilerServices;
using MethodImplOptions = Utilities.MethodImplOptions;

#if SUPPORTS_VECTOR_512 || SUPPORTS_VECTOR_256 || SUPPORTS_VECTOR_128
using System.Runtime.Intrinsics;
#endif

using Guard;

// ReSharper disable UnusedMember.Global
// ReSharper disable RedundantCast
// ReSharper disable CompareOfFloatsByEqualityOperator
namespace System;

public static partial class MathEx {

<#foreach (var type in new[]{"sbyte","short","int","long"}){#>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> ArithmeticShiftLeft(this <#=type#> @this, byte count) => (<#=type#>)(count >= <#=GetSizeInBits(type)-1#> ? 0 : ((<#=GetUnsignedType(type)#>)@this & 0x<#=(1UL << GetSizeInBits(type) - 1).ToString("X")#>) | (((<#=GetUnsignedType(type)#>)@this << count) & 0x<#=((1UL << GetSizeInBits(type) - 1) - 1).ToString("X")#>));

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> ArithmeticShiftRight(this <#=type#> @this, byte count) => (<#=type#>)(count >= <#=GetSizeInBits(type)-1#> ? 0 : @this >> count);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> LogicalShiftLeft(this <#=type#> @this, byte count) => (<#=type#>)((<#=(type=="sbyte"?"byte":"u"+type)#>)@this << count);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> LogicalShiftRight(this <#=type#> @this, byte count) => (<#=type#>)(@this >>> count);

<#}#>
<#foreach (var type in new[]{"byte","ushort","uint","ulong"}){#>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> ArithmeticShiftLeft(this <#=type#> @this, byte count) => (<#=type#>)(count >= <#=GetSizeInBits(type)#> ? 0 : @this << count);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> ArithmeticShiftRight(this <#=type#> @this, byte count) => (<#=type#>)(count >= <#=GetSizeInBits(type)#> ? 0 : @this >> count);
  
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> RotateLeft(this <#=type#> @this, byte count) {
    count &= <#=GetSizeInBits(type) - 1#>;
    return (<#=type#>)((@this << count) | (@this >> (<#=GetSizeInBits(type)#> - count)));
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> RotateRight(this <#=type#> @this, byte count) {
    count &= <#=GetSizeInBits(type) - 1#>;
    return (<#=type#>)((@this >> count) | (@this << (<#=GetSizeInBits(type)#> - count)));
  }

<#}#>

<#foreach (var type in new[]{"byte","sbyte","ushort","short","uint","int","ulong","long"}){#>

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> Bits(this <#=type#> @this, byte index, byte count) {
    var result = @this >> index;
    var andMask = ((<#=type#>)1 << count) - 1;
    result &= andMask;
    return (<#=type#>)result;
  }
    
  /// <summary>
  /// Determines whether the specified number is odd.
  /// </summary>
  /// <param name="this">This number.</param>
  /// <returns><c>true</c> if the number is odd; otherwise, <c>false</c>.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsOdd(this <#=type#> @this) => (@this & 1) != 0;
    
  /// <summary>
  /// Determines whether the specified number is even.
  /// </summary>
  /// <param name="this">This number.</param>
  /// <returns><c>true</c> if the number is even; otherwise, <c>false</c>.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsEven(this <#=type#> @this) => (@this & 1) == 0;

<#}#>
  
<#foreach (var type in new[]{"float","double","decimal"}){#>
    
  /// <summary>
  /// Calculates 1/x.
  /// </summary>
  /// <param name="this">This number.</param>
  /// <returns>An estimation of the reciprocal.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> ReciprocalEstimate(<#=type#> @this) => 1 / @this;

  /// <summary>
  /// Determines whether the specified number is odd.
  /// </summary>
  /// <param name="this">This number.</param>
  /// <returns><c>true</c> if the number is odd; otherwise, <c>false</c>.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  // ReSharper disable once CompareOfFloatsByEqualityOperator
  public static bool IsOdd(this <#=type#> @this) => @this % 2 != 0;
    
  /// <summary>
  /// Determines whether the specified number is even.
  /// </summary>
  /// <param name="this">This number.</param>
  /// <returns><c>true</c> if the number is even; otherwise, <c>false</c>.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  // ReSharper disable once CompareOfFloatsByEqualityOperator
  public static bool IsEven(this <#=type#> @this) => @this % 2 == 0;
<#}#>
  
<#foreach (var type in new[]{"double","decimal"}){#>
    
  /// <summary>Returns the largest integral value less than or equal to the specified decimal number.</summary>
  /// <param name="this">A number.</param>
  /// <returns>The largest integral value less than or equal to <paramref name="this" />.  Note that the method returns an integral value of type <see cref="T:System.Decimal" />.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> Floor(this <#=type#> @this) => Math.Floor(@this);
    
  /// <summary>Returns the smallest integral value that is greater than or equal to the specified decimal number.</summary>
  /// <param name="this">A number.</param>
  /// <returns>The smallest integral value that is greater than or equal to <paramref name="this" />. Note that this method returns a <see cref="T:System.Decimal" /> instead of an integral type.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> Ceiling(this <#=type#> @this) => <#=(type=="float"?"("+type+")":"")#>Math.Ceiling(@this);
    
  /// <summary>Calculates the integral part of a specified decimal number.</summary>
  /// <param name="this">A number to truncate.</param>
  /// <returns>The integral part of <paramref name="this" />; that is, the number that remains after any fractional digits have been discarded.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> Truncate(this <#=type#> @this) => <#=(type=="float"?"("+type+")":"")#>Math.Truncate(@this);
<#}#>
      
<#foreach (var item in new[]{T("double",15),T("decimal",28)}){#>

  /// <summary>Rounds a value to the nearest integral value, and rounds midpoint values to the nearest even number.</summary>
  /// <param name="this">A number to be rounded.</param>
  /// <returns>The integer nearest the <paramref name="this" /> parameter. If the fractional component of <paramref name="this" /> is halfway between two integers, one of which is even and the other odd, the even number is returned.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=item.Item1#> Round(this <#=item.Item1#> @this) => <#=(item.Item1=="float"?"("+item.Item1+")":"")#>Math.Round(@this);

  /// <summary>Rounds a value to the nearest integral value, and rounds midpoint values to the nearest even number.</summary>
  /// <param name="this">A number to be rounded.</param>
  /// <param name="digits">The number of decimal places in the return value.</param>
  /// <returns>The integer nearest the <paramref name="this" /> parameter. If the fractional component of <paramref name="this" /> is halfway between two integers, one of which is even and the other odd, the even number is returned.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=item.Item1#> Round(this <#=item.Item1#> @this, int digits) {
    Against.ValuesOutOfRange(digits, 0, <#=item.Item2#>);

    return <#=(item.Item1=="float"?"("+item.Item1+")":"")#>Math.Round(@this, digits);
  }

  /// <summary>Rounds a value to an integer using the specified rounding convention.</summary>
  /// <param name="this">A number to be rounded.</param>
  /// <param name="method">One of the enumeration values that specifies which rounding strategy to use.</param>
  /// <returns>The integer that <paramref name="this" /> is rounded to.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=item.Item1#> Round(this <#=item.Item1#> @this, MidpointRounding method) => <#=(item.Item1=="float"?"("+item.Item1+")":"")#>Math.Round(@this, method);

  /// <summary>Rounds a value to an integer using the specified rounding convention.</summary>
  /// <param name="this">A number to be rounded.</param>
  /// <param name="digits">The number of decimal places in the return value.</param>
  /// <param name="method">One of the enumeration values that specifies which rounding strategy to use.</param>
  /// <returns>The integer that <paramref name="this" /> is rounded to.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=item.Item1#> Round(this <#=item.Item1#> @this, int digits, MidpointRounding method) {
    Against.ValuesOutOfRange(digits, 0, <#=item.Item2#>);

    return <#=(item.Item1=="float"?"("+item.Item1+")":"")#>Math.Round(@this, digits, method);
  }

<#}#>

<#foreach (var type in new[]{"sbyte","short","int","long","float","double","decimal"}){#>
    
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> Abs(this <#=type#> @this) => <#=(type=="float"?"(float)":"")#>Math.Abs(@this);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> Sign(this <#=type#> @this) => <#=(type=="sbyte"||type=="short"?"("+type+")":"")#>(@this < 0 ? -1 : 1);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsPositive(this <#=type#> @this) => @this > 0;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsPositiveOrZero(this <#=type#> @this) => @this >= 0;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsNegative(this <#=type#> @this) => @this < 0;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsNegativeOrZero(this <#=type#> @this) => @this <= 0;

<#}#>
  
<#foreach (var type in new[]{"float","double"}){#>

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsNumeric(this <#=type#> @this) => !(<#=type#>.IsNaN(@this) || <#=type#>.IsInfinity(@this));

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsNonNumeric(this <#=type#> @this) => <#=type#>.IsNaN(@this) || <#=type#>.IsInfinity(@this);
    
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsNaN(this <#=type#> @this) => <#=type#>.IsNaN(@this);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsInfinity(this <#=type#> @this) => <#=type#>.IsInfinity(@this);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsPositiveInfinity(this <#=type#> @this) => <#=type#>.IsPositiveInfinity(@this);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsNegativeInfinity(this <#=type#> @this) => <#=type#>.IsNegativeInfinity(@this);
    
<#}#>
  
<#foreach (var type in new[]{"sbyte","byte","short","ushort","int","uint","long","ulong","float","double","decimal"}){#>
    
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> Squared(this <#=type#> @this) => (<#=type#>)(@this * @this);
    
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> Cubed(this <#=type#> @this) => (<#=type#>)(@this * @this * @this);
    
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> Pow(this <#=type#> @this,<#=type#> exponent) => (<#=type#>)Math.Pow(<#=(type=="decimal"?"(double)":"")#>@this,<#=(type=="decimal"?"(double)":"")#>exponent);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> MultipliedWith(this <#=type#> @this,<#=type#> factor) => (<#=type#>)(@this * factor);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> DividedBy(this <#=type#> @this,<#=type#> divisor) => (<#=type#>)(@this / divisor);

  /// <summary>
  /// Determines whether the given value is zero.
  /// </summary>
  /// <param name="this">This value.</param>
  /// <returns><c>true</c> if the value is zero; otherwise, <c>false</c>.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsZero(this <#=type#> @this) => @this == 0;
    
  /// <summary>
  /// Determines whether the given value is not zero.
  /// </summary>
  /// <param name="this">This value.</param>
  /// <returns><c>true</c> if the value is not zero; otherwise, <c>false</c>.</returns>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsNotZero(this <#=type#> @this) => @this != 0;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsBelow(this <#=type#> @this, <#=type#> exclusiveLimit) => @this < exclusiveLimit;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsBelowOrEqual(this <#=type#> @this, <#=type#> inclusiveLimit) => @this <= inclusiveLimit;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsAbove(this <#=type#> @this, <#=type#> exclusiveLimit) => @this > exclusiveLimit;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsAboveOrEqual(this <#=type#> @this, <#=type#> inclusiveLimit) => @this >= inclusiveLimit;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsBetween(this <#=type#> @this, <#=type#> exclusiveLowerLimit, <#=type#> exclusiveUpperLimit) => @this > exclusiveLowerLimit && @this < exclusiveUpperLimit;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static bool IsInRange(this <#=type#> @this, <#=type#> inclusiveLowerLimit, <#=type#> inclusiveUpperLimit) => @this >= inclusiveLowerLimit && @this <= inclusiveUpperLimit;

<#}#>

<#foreach (var type in new[]{"float","double"}){#>
<#  foreach (var method in new[]{"Sqrt","Log10","Log","Sin","Cos","Tan","Sinh","Cosh","Tanh"}){#>

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
<#    if(type == "float") {#>
#if SUPPORTS_MATHF
  public static <#=type#> <#=method#>(this <#=type#> @this) => MathF.<#=method#>(@this);
#else
  public static <#=type#> <#=method#>(this <#=type#> @this) => (<#=type#>)Math.<#=method#>(@this);
#endif
<#    } else {#>
  public static <#=type#> <#=method#>(this <#=type#> @this) => Math.<#=method#>(@this);
<#    }#>
<#  }#>
<#}#>
 
<#foreach (var type in new[]{"sbyte","byte","short","ushort","int","uint","long","ulong","decimal"}){#>

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedMultiplyAdd(this <#=type#> @this, <#=type#> factor, <#=type#> addend) => <#=(type=="sbyte"||type=="byte"||type=="short"||type=="ushort"?$"({type})":string.Empty)#>(@this * factor + addend);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedMultiplySubtract(this <#=type#> @this, <#=type#> factor, <#=type#> subtrahend) => <#=(type=="sbyte"||type=="byte"||type=="short"||type=="ushort"?$"({type})":string.Empty)#>(@this * factor - subtrahend);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedDivideAdd(this <#=type#> @this, <#=type#> divisor, <#=type#> addend) => <#=(type=="sbyte"||type=="byte"||type=="short"||type=="ushort"?$"({type})":string.Empty)#>(@this / divisor + addend);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedDivideSubtract(this <#=type#> @this, <#=type#> divisor, <#=type#> subtrahend) => <#=(type=="sbyte"||type=="byte"||type=="short"||type=="ushort"?$"({type})":string.Empty)#>(@this / divisor - subtrahend);

<#}#>
    
#if SUPPORTS_FMADD
<#foreach (var type in new[]{"float","double"}){#>

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedMultiplyAdd(this <#=type#> @this, <#=type#> factor, <#=type#> addend) => <#=(type=="double"?"Math":"MathF")#>.FusedMultiplyAdd(@this, factor, addend);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedMultiplySubtract(this <#=type#> @this, <#=type#> factor, <#=type#> subtrahend) => <#=(type=="double"?"Math":"MathF")#>.FusedMultiplyAdd(@this, factor, -subtrahend);

#if SUPPORTS_MATH_RECIPROCAL_ESTIMATE

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedDivideAdd(this <#=type#> @this, <#=type#> divisor, <#=type#> addend) => <#=(type=="double"?"Math":"MathF")#>.FusedMultiplyAdd(@this, <#=(type=="double"?"Math":"MathF")#>.ReciprocalEstimate(divisor), addend);

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedDivideSubtract(this <#=type#> @this, <#=type#> divisor, <#=type#> subtrahend) => <#=(type=="double"?"Math":"MathF")#>.FusedMultiplyAdd(@this, <#=(type=="double"?"Math":"MathF")#>.ReciprocalEstimate(divisor), -subtrahend);

#else

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedDivideAdd(this <#=type#> @this, <#=type#> divisor, <#=type#> addend) => @this / divisor + addend;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedDivideSubtract(this <#=type#> @this, <#=type#> divisor, <#=type#> subtrahend) => @this / divisor - subtrahend;

#endif

<#}#>
#else
<#foreach (var type in new[]{"float","double"}){#>

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedMultiplyAdd(this <#=type#> @this, <#=type#> factor, <#=type#> addend) => @this * factor + addend;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedMultiplySubtract(this <#=type#> @this, <#=type#> factor, <#=type#> subtrahend) => @this * factor - subtrahend;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedDivideAdd(this <#=type#> @this, <#=type#> divisor, <#=type#> addend) => @this / divisor + addend;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#=type#> FusedDivideSubtract(this <#=type#> @this, <#=type#> divisor, <#=type#> subtrahend) => @this / divisor - subtrahend;

<#}#>
#endif

  #region fast min/max/avg

<#foreach (var type in new[]{"sbyte","byte","short","ushort","int","uint","long","ulong","float","double","decimal"}){#>

  #region <#=type#>
  /// <summary>
  /// Gets the minimum value from the given ones.
  /// </summary>
  /// <param name="values">The values.</param>
  /// <returns>The min value.</returns>
  public static unsafe <#=type#> Min(params <#=type#>[] values) {
    var count = values.Length;
    if (count <= 0)
      return default;

    fixed(<#=type#>* startPointer = &values[0]) {
      var result = values[0];
      var offset = startPointer;
      var endPointer = startPointer + count;

      var chunkSize = 1;

<#  foreach(var size in new []{ 512, 256, 128, 64 }) {#>
#if SUPPORTS_VECTOR_<#=size#> && SUPPORTS_VECTOR_IS_HARDWARE_ACCELERATED

      chunkSize = Vector<#=size#><<#=type#>>.Count;
      if (Vector<#=size#>.IsHardwareAccelerated && count >= chunkSize * 2) {
        var left = Vector<#=size#>.Load(offset);
        offset += chunkSize;  
        count -= chunkSize;

        do {
          var right = Vector<#=size#>.Load(offset);
          left = Vector<#=size#>.Min(left, right);
          offset += chunkSize;
          count -= chunkSize;
        } while (count >= chunkSize);

        for (var i = 0; i < chunkSize; ++i)
          result = Math.Min(result, left[i]);

      }

#endif
<#  }#>

      // Process any remaining elements
      for (; offset < endPointer; ++offset) 
        result = Math.Min(result, *offset);

      return result;
    }
  }

  /// <summary>
  /// Gets the maximum value from the given ones.
  /// </summary>
  /// <param name="values">The values.</param>
  /// <returns>The max value.</returns>
  public static unsafe <#=type#> Max(params <#=type#>[] values) {
    var count = values.Length;
    if (count <= 0)
      return default;

    fixed(<#=type#>* startPointer = &values[0]) {
      var result = values[0];
      var offset = startPointer;
      var endPointer = startPointer + count;

      var chunkSize = 1;

<#  foreach(var size in new []{ 512, 256, 128, 64 }) {#>
#if SUPPORTS_VECTOR_<#=size#> && SUPPORTS_VECTOR_IS_HARDWARE_ACCELERATED

      chunkSize = Vector<#=size#><<#=type#>>.Count;
      if (Vector<#=size#>.IsHardwareAccelerated && count >= chunkSize * 2) {
        var left = Vector<#=size#>.Load(offset);
        offset += chunkSize;  
        count -= chunkSize;

        do {
          var right = Vector<#=size#>.Load(offset);
          left = Vector<#=size#>.Max(left, right);
          offset += chunkSize;
          count -= chunkSize;
        } while (count >= chunkSize);

        for (var i = 0; i < chunkSize; ++i)
          result = Math.Max(result, left[i]);

      }

#endif
<#  }#>

      // Process any remaining elements
      for (; offset < endPointer; ++offset) 
        result = Math.Max(result, *offset);

      return result;
    }
  }

  /// <summary>
  /// Gets the maximum value from the given ones.
  /// </summary>
  /// <param name="values">The values.</param>
  /// <returns>The max value.</returns>
  public static <#=type#> Average(params <#=type#>[] values) {
    var length = values.Length;
    if (length == 0)
      return default;

<#
    var tempType = 
      "|decimal|double|ulong|long|".Contains($"|{type}|") 
      ? type 
      : 
        type == "float" 
        ? "double" 
        : 
          "|sbyte|short|int|".Contains($"|{type}|") 
          ? "long" 
          : "ulong"
    ;

    var downCast = type == tempType ? string.Empty : $"({type})";
    var upCast = type == tempType ? string.Empty : $"({tempType})";
#>
    var result = <#=upCast#>values[0];
    for (var i = 1; i < length; ++i) 
      result += values[i];

    return <#=downCast#>(result / (<#=tempType#>)length);
  }

  public static bool IsIn(<#=type#> @this, <#=type#>[] values) {
    var length = values.Length;
    if (length == 0)
      return false;

    for (var i = 0; i < length; ++i) 
      if (values[i] == @this)
        return true;

    return false;
  }

  public static bool IsNotIn(<#=type#> @this, <#=type#>[] values) {
    var length = values.Length;
    if (length == 0)
      return true;

    for (var i = 0; i < length; ++i) 
      if (values[i] == @this)
        return false;

    return true;
  }

  #endregion

<#}#>

  #endregion

}

<#+ 
  private static Tuple<A,B> T<A,B>(A a,B b){ return(Tuple.Create(a,b)); }
  private static Tuple<A,B,C> T<A,B,C>(A a,B b,C c){ return(Tuple.Create(a,b,c)); } 

  private static int GetSizeInBits(string type) => type switch {
    "byte" => 8,
    "sbyte" => 8,
    "ushort" => 16,
    "short" => 16,
    "uint" => 32,
    "int" => 32,
    "ulong" => 64,
    "long" => 64,
    _=>throw new NotSupportedException($"Unknown type: {type}")
  };

  private static string GetUnsignedType(string type) => type switch {
    "sbyte" => "byte",
    "short" => "ushort",
    "int" => "uint",
    "long" => "ulong",
    _=>throw new NotSupportedException($"Unknown type: {type}")
  };
#>