<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Linq" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
#region (c)2010-2042 Hawkynt
/*
  This file is part of Hawkynt's .NET Framework extensions.

    Hawkynt's .NET Framework extensions are free software: 
    you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Hawkynt's .NET Framework extensions is distributed in the hope that 
    it will be useful, but WITHOUT ANY WARRANTY; without even the implied 
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
    the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Hawkynt's .NET Framework extensions.  
    If not, see <http://www.gnu.org/licenses/>.
*/
#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */

using System.Collections.Concurrent;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Linq;
using System.Threading;

// ReSharper disable RedundantCast
// ReSharper disable UnusedMember.Global
// TODO: do not gather statistics if not needed/requested
namespace System.Collections.Generic;

/// <summary>
/// Tells us how items get replaced when the cache exceeds its limits.
/// </summary>
public class CacheReplacementPolicy {

  internal byte Value { get; }

  protected CacheReplacementPolicy(byte value) => this.Value =  value;

  /// <summary>
  /// Removes random elements from the cache.
  /// </summary>
  public static CacheReplacementPolicy Random { get; } = new CacheReplacementPolicy(0);
  /// <summary>
  /// Removes the last n elements added to the cache.
  /// </summary>
  public static CacheReplacementPolicy LastInFirstOut { get; } = new CacheReplacementPolicy(1);
  /// <summary>
  /// Removes the first n elements added to the cache.
  /// </summary>
  public static CacheReplacementPolicy FirstInFirstOut { get; } = new CacheReplacementPolicy(2);
  /// <summary>
  /// Removes the n most recently accessed elements in the cache.
  /// </summary>
  public static CacheReplacementPolicy MostRecentlyUsed { get; } = new CacheReplacementPolicy(3);
  /// <summary>
  /// Remove the n least recently accessed element in the cache.
  /// </summary>
  public static CacheReplacementPolicy LeastRecentlyUsed { get; } = new CacheReplacementPolicy(4);
  /// <summary>
  /// Removes the n smallest elements.
  /// </summary>
  public static CacheReplacementPolicy SmallValuesFirst { get; } = new CacheReplacementPolicy(5);
  /// <summary>
  /// Removes the n largest elements.
  /// </summary>
  public static CacheReplacementPolicy LargeValuesFirst { get; } = new CacheReplacementPolicy(6);
  /// <summary>
  /// Removes the n least frequently used elements.
  /// </summary>
  public static CacheReplacementPolicy LeastFrequentlyUsed { get; } = new CacheReplacementPolicy(7);
  /// <summary>
  /// Removes the n most frequently used elements.
  /// </summary>
  public static CacheReplacementPolicy MostFrequentlyUsed { get; } = new CacheReplacementPolicy(8);
  /// <summary>
  /// Removes n elements with the least lifetime left.
  /// </summary>
  public static CacheReplacementPolicy LeastAvailableLifetimeLeft { get; } = new CacheReplacementPolicy(9);
  /// <summary>
  /// Removes n elements with the most lifetime left.
  /// </summary>
  public static CacheReplacementPolicy MostAvailableLifetimeLeft { get; } = new CacheReplacementPolicy(10);

  public override string ToString() {
    var value = this.Value;
    if (value == Random.Value) return nameof(Random);
    if (value == LastInFirstOut.Value) return nameof(LastInFirstOut);
    if (value == FirstInFirstOut.Value) return nameof(FirstInFirstOut);
    if (value == MostRecentlyUsed.Value) return nameof(MostRecentlyUsed);
    if (value == LeastRecentlyUsed.Value) return nameof(LeastRecentlyUsed);
    if (value == SmallValuesFirst.Value) return nameof(SmallValuesFirst);
    if (value == LargeValuesFirst.Value) return nameof(LargeValuesFirst);
    if (value == LeastFrequentlyUsed.Value) return nameof(LeastFrequentlyUsed);
    if (value == MostFrequentlyUsed.Value) return nameof(MostFrequentlyUsed);
    if (value == LeastAvailableLifetimeLeft.Value) return nameof(LeastAvailableLifetimeLeft);
    if (value == MostAvailableLifetimeLeft.Value) return nameof(MostAvailableLifetimeLeft);
    throw new NotSupportedException("Unknown value");
  }

  #region Equality members

  protected bool Equals(CacheReplacementPolicy other) => other!=null && this.Value == other.Value;
  public override bool Equals(object obj) => ReferenceEquals(this, obj) || obj is CacheReplacementPolicy o && this.Equals(o);
  public override int GetHashCode() => this.Value.GetHashCode();
  public static bool operator ==(CacheReplacementPolicy a, CacheReplacementPolicy b) => Equals(a, b);
  public static bool operator !=(CacheReplacementPolicy a, CacheReplacementPolicy b) => !Equals(a, b);
  public static bool Equals(CacheReplacementPolicy a, CacheReplacementPolicy b) => a is null && b is null || !(a is null) && a.Equals(b);

  #endregion

}

<#for(var i=1;i<8;++i){
var isSingleParameter=i<2;
var typeDef=isSingleParameter?"TInput":string.Join(", ",Enumerable.Range(1,i).Select(j=>"TInput"+j));
var covariantTypeDef=isSingleParameter?"in TInput":string.Join(", ",Enumerable.Range(1,i).Select(j=>"in TInput"+j));
var parameterDef=isSingleParameter?"TInput parameter":string.Join(", ",Enumerable.Range(1,i).Select(j=>"TInput"+j+" parameter"+j));
var parameterCall=isSingleParameter?"parameter":string.Join(", ",Enumerable.Range(1,i).Select(j=>"parameter"+j));
var tupleType=isSingleParameter?typeDef:"Tuple<"+typeDef+">";
var tupleCreate=isSingleParameter?parameterCall:"Tuple.Create("+parameterCall+")";
#>
#region dependend on number (<#=i#>) of input parameters

public interface ICache<<#=covariantTypeDef#>, out TValue> : IDisposable {
  TValue this[<#=parameterDef#>] { get; }
  CacheReplacementPolicy Policy { get; }
  int Count { get; }
  long MemoryOverhead { get; }
  long MemorySize { get; }
  void Clear();
}

public static class Cache<<#=typeDef#>, TValue> {
  private static TValue _CreateFromTuple(<#=tupleType#> tuple, Func<<#=typeDef#>, TValue> factory) 
    => factory(<#=isSingleParameter?"tuple":string.Join(", ",Enumerable.Range(1,i).Select(j=>"tuple.Item"+j))#>)
  ;
    
  private static _CacheTypes.LifetimeBasedItem<TValue> _CreateFromTuple(<#=tupleType#> tuple, Func<<#=typeDef#>, TValue> factory, TimeSpan maxAge) 
    => new _CacheTypes.LifetimeBasedItem<TValue>(factory(<#=isSingleParameter?"tuple":string.Join(", ",Enumerable.Range(1,i).Select(j=>"tuple.Item"+j))#>), maxAge)
  ;
    
  /// <summary>Creates a cache with a maximum number of entries</summary>
  /// <param name="factory">The method that is used to generate values for cache entries</param>
  /// <param name="maxItems">The maximum number of items to hold at once before discarding items</param>
  /// <param name="policy">The algorithm used to determine which items will be discarded first</param>
  /// <param name="lazyCollect">
  ///   <c>true</c> causes the cache to use a background thread to discard items; otherwise <c>false</c> (default).
  ///   <note>
  ///     <br /><c>true</c> - until the background thread discards items, the item limit may be temporarily overriden.
  ///     <br /><c>false</c> - causes items to be discarded just before adding new items thus slowing down add operations.
  ///   </note>
  /// </param>

  public static ICache<<#=typeDef#>, TValue> FromFactoryWithMaxItemCount(Func<<#=typeDef#>, TValue> factory, int maxItems, CacheReplacementPolicy policy, bool lazyCollect = false) {
    if (policy == CacheReplacementPolicy.LeastAvailableLifetimeLeft || policy == CacheReplacementPolicy.MostAvailableLifetimeLeft)
      throw new ArgumentException("Does not make sense, use FirstInFirstOut/LastInFirstOut", nameof(policy));

    return new _CacheWithItemWithoutLifetime<<#=typeDef#>, TValue>(
      new _Cache<<#=tupleType#>, TValue>(
        t => _CreateFromTuple(t, factory), 
        maxItems, 
        0, 
        policy, 
        !lazyCollect
      )
    );
  }

  /// <summary>Creates a cache with a maximum memory usage</summary>
  /// <param name="factory">The method that is used to generate values for cache entries</param>
  /// <param name="maxSizeInBytes">The maximum number of bytes to hold at once before discarding items</param>
  /// <param name="policy">The algorithm used to determine which items will be discarded first</param>
  /// <param name="lazyCollect">
  ///   <c>true</c> causes the cache to use a background thread to discard items; otherwise <c>false</c> (default).
  ///   <note>
  ///     <br /><c>true</c> - until the background thread discards items, the memory limit may be temporarily overriden.
  ///     <br /><c>false</c> - causes items to be discarded just before adding new items thus slowing down add operations.
  ///   </note>
  /// </param>
  public static ICache<<#=typeDef#>, TValue> FromFactoryWithMaxMemorySize(Func<<#=typeDef#>, TValue> factory, long maxSizeInBytes, CacheReplacementPolicy policy, bool lazyCollect = false) {
    if (policy == CacheReplacementPolicy.LeastAvailableLifetimeLeft || policy == CacheReplacementPolicy.MostAvailableLifetimeLeft)
      throw new ArgumentException("Does not make sense, use FirstInFirstOut/LastInFirstOut", nameof(policy));
      
    return new _CacheWithItemWithoutLifetime<<#=typeDef#>, TValue>(
      new _Cache<<#=tupleType#>, TValue>(
        t => _CreateFromTuple(t, factory), 
        0, 
        maxSizeInBytes, 
        policy, 
        !lazyCollect
      )
    );
  }

  /// <summary>Creates a cache with a maximum item lifetime</summary>
  /// <param name="factory">The method that is used to generate values for cache entries</param>
  /// <param name="maxAge">The maximum lifetime of items before they're discarded.</param>
  /// <note>A background thread removes dead items.</note>
  public static ICache<<#=typeDef#>, TValue> FromFactoryWithMaxItemLifetime(Func<<#=typeDef#>, TValue> factory, TimeSpan maxAge)
    => new _CacheWithItemLifetime<<#=typeDef#>, TValue>(
      new _Cache<<#=tupleType#>, _CacheTypes.LifetimeBasedItem<TValue>>(
        t=>_CreateFromTuple(t, factory, maxAge), 
        0, 
        0, 
        _CacheReplacementPolicy.NotNeeded, 
        false, 
        maxAge
      )
    )
  ;

  /// <summary>Creates a cache with a maximum item lifetime</summary>
  /// <param name="factory">The method that is used to generate values for cache entries</param>
  /// <param name="maxAge">The maximum lifetime of items before they're discarded.</param>
  /// <param name="maxItems">The maximum number of items to hold at once before discarding items</param>
  /// <param name="policy">The algorithm used to determine which items will be discarded first</param>
  /// <param name="lazyCollect">
  ///   <c>true</c> causes the cache to use a background thread to discard items; otherwise <c>false</c> (default).
  ///   <note>
  ///     <br /><c>true</c> - until the background thread discards items, the item limit may be temporarily overriden.
  ///     <br /><c>false</c> - causes items to be discarded just before adding new items thus slowing down add operations.
  ///   </note>
  /// </param>
  public static ICache<<#=typeDef#>, TValue> FromFactoryWithMaxItemLifetimeAndMaxItemCount(Func<<#=typeDef#>, TValue> factory, TimeSpan maxAge, int maxItems, CacheReplacementPolicy policy, bool lazyCollect = false)
    => new _CacheWithItemLifetime<<#=typeDef#>, TValue>(
      new _Cache<<#=tupleType#>, _CacheTypes.LifetimeBasedItem<TValue>>(
        t=>_CreateFromTuple(t, factory, maxAge), 
        maxItems, 
        0, 
        policy, 
        !lazyCollect,
        maxAge
      )
    )
  ;

  /// <summary>Creates a cache with a maximum item lifetime</summary>
  /// <param name="factory">The method that is used to generate values for cache entries</param>
  /// <param name="maxAge">The maximum lifetime of items before they're discarded.</param>
  /// <param name="maxSizeInBytes">The maximum number of bytes to hold at once before discarding items</param>
  /// <param name="policy">The algorithm used to determine which items will be discarded first</param>
  /// <param name="lazyCollect">
  ///   <c>true</c> causes the cache to use a background thread to discard items; otherwise <c>false</c> (default).
  ///   <note>
  ///     <br /><c>true</c> - until the background thread discards items, the memory limit may be temporarily overriden.
  ///     <br /><c>false</c> - causes items to be discarded just before adding new items thus slowing down add operations.
  ///   </note>
  /// </param>
  public static ICache<<#=typeDef#>, TValue> FromFactoryWithMaxItemLifetimeAndMaxMemorySize(Func<<#=typeDef#>, TValue> factory, TimeSpan maxAge, long maxSizeInBytes, CacheReplacementPolicy policy, bool lazyCollect = false)
    => new _CacheWithItemLifetime<<#=typeDef#>, TValue>(
      new _Cache<<#=tupleType#>, _CacheTypes.LifetimeBasedItem<TValue>>(
        t=>_CreateFromTuple(t, factory, maxAge), 
        0, 
        maxSizeInBytes, 
        policy, 
        !lazyCollect,
        maxAge
      )
    )
  ;

}

internal class _CacheWithItemWithoutLifetime<<#=typeDef#>, TValue> : ICache<<#=typeDef#>, TValue> {

  private readonly _Cache<<#=tupleType#>, TValue> _cache;
    
  public _CacheWithItemWithoutLifetime(_Cache<<#=tupleType#>, TValue> cache) => this._cache = cache;
    
  #region Implementation of IDisposable

  public void Dispose() {
    this._cache.Dispose();
    GC.SuppressFinalize(this);
  }

  ~_CacheWithItemWithoutLifetime() => this.Dispose();
    
  #endregion

  #region Implementation of ICache

  public TValue this[<#=parameterDef#>] => this._cache[<#=tupleCreate#>];
  public CacheReplacementPolicy Policy => this._cache.Policy;
  public int Count => this._cache.Count;
  public long MemoryOverhead => _CacheTypes.GetUsedMemory(this) - this.MemorySize;
  public long MemorySize => this._cache.MemorySize;
  public void Clear() => this._cache.Clear();

  #endregion
}

internal class _CacheWithItemLifetime<<#=typeDef#>, TValue> : ICache<<#=typeDef#>, TValue> {

  private readonly _Cache<<#=tupleType#>, _CacheTypes.LifetimeBasedItem<TValue>> _cache;
  public _CacheWithItemLifetime(_Cache<<#=tupleType#>, _CacheTypes.LifetimeBasedItem<TValue>> cache) 
    => this._cache = cache
  ;
    
  #region Implementation of IDisposable

  public void Dispose() {
    this._cache.Dispose();
    GC.SuppressFinalize(this);
  }

  ~_CacheWithItemLifetime() => this.Dispose();
    
  #endregion

  #region Implementation of ICache

  public TValue this[<#=parameterDef#>] => this._cache[<#=tupleCreate#>].Value;
  public CacheReplacementPolicy Policy => this._cache.Policy;
  public int Count => this._cache.Count;
  public long MemoryOverhead => _CacheTypes.GetUsedMemory(this) - this.MemorySize;
  public long MemorySize => this._cache.MemorySize;
  public void Clear() => this._cache.Clear();

  #endregion
}

#endregion

<#}#>
  
internal sealed class _CacheReplacementPolicy:CacheReplacementPolicy {
  public static CacheReplacementPolicy NotNeeded { get; } = new _CacheReplacementPolicy(255);

  public _CacheReplacementPolicy(byte value) : base(value) { }

  public override string ToString() {
    var value = this.Value;
    if (value == NotNeeded.Value) return nameof(NotNeeded);
    return base.ToString();
  }
}

internal class _CacheTypes {
  public interface ICacheItem<out TItem>: IDisposable {
    TItem Value { get; }
    long Size { get; }
    long Selector { get; }
  }

  public interface IValidTrackingCacheItem {
    bool IsStillValid { get; }
  }

  public abstract class ACacheItem<TItem>: ICacheItem<TItem> {
    private int _isDisposed;
    protected readonly TItem _value;

    protected ACacheItem(TItem value) => this._value = value;
    ~ACacheItem() => this.Dispose();

    public void Dispose() {
      if(Interlocked.CompareExchange(ref this._isDisposed,1,0) != 0)
        return;

      (this.Value as IDisposable)?.Dispose();
      GC.SuppressFinalize(this);
    }
      
    public virtual TItem Value => this._value;
    public abstract long Selector { get; }
    public virtual long Size => GetUsedMemory(this._value);

  }

  // for removing items based on pure randomness - Random
  public class SelectorLessItem<TItem>: ACacheItem<TItem> {
    public SelectorLessItem(TItem value): base(value) { }
    public override long Selector => 0;
  }

  // for removing items based on their size - SmallValuesFirst/LargeValueFirst
  public class SizeBasedItem<TItem>: ACacheItem<TItem> {
    private long _size;
      
    public SizeBasedItem(TItem value): base(value) => this.RecalculateSize();
    public override long Selector => this.Size;
    public override long Size => Interlocked.Read(ref this._size);

    public long RecalculateSize() {
      var result = GetUsedMemory(this.Value);
      Interlocked.Exchange(ref this._size, result);
      return result;
    }

  }

  // for removing the oldest or youngest items FirstInFirstOut/LastInFirstOut
  public class AgeBasedItem<TItem>: ACacheItem<TItem> {
    public AgeBasedItem(TItem value, long id): base(value) => this.Selector = id;
    public override long Selector { get; }
  }

  // for removing items based on their lifetime  
  public class LifetimeBasedItem<TItem>: ACacheItem<TItem>, IValidTrackingCacheItem {
    public LifetimeBasedItem(TItem value, TimeSpan lifetime): base(value) => this.Selector = Stopwatch.GetTimestamp() + (long)(Stopwatch.Frequency * lifetime.TotalSeconds);
    public override long Selector { get; }
    public bool IsStillValid => Stopwatch.GetTimestamp() < this.Selector;
  }

  // for removing items based on their last access time LeastRecentlyUsed/MostRecentlyUsed
  public class AccessBasedItem<TItem>: ACacheItem<TItem> {
    private long _lastAccessId;
    private readonly Func<long> _idGenerator;

    public AccessBasedItem(TItem value, Func<long> idGenerator): base(value) => this._idGenerator = idGenerator;
    public override long Selector => Interlocked.Read(ref this._lastAccessId);
    public override TItem Value {
      get {
        Interlocked.Exchange(ref this._lastAccessId, this._idGenerator());
        return base._value;
      }
    }
  }

  // for removing items based on their number of accesses LeastFrequentlyUsed/MostFrequentlyUsed
  public class FrequencyBasedItem<TItem>: ACacheItem<TItem> {
    private long _accessCount;

    public FrequencyBasedItem(TItem value): base(value) { }
    public override long Selector => Interlocked.Read(ref this._accessCount);
    public override TItem Value {
      get {
        Interlocked.Increment(ref this._accessCount);
        return base.Value;
      }
    }
  }
  
  #region calculate object size

  public static long GetUsedMemory<TType>(TType value) => _GetMemorySize(value, typeof(TType).IsValueType, new HashSet<object>());

  private static long _GetMemorySize(object value, bool withoutBoxing, HashSet<object> visitedRefs) {
    var pointerSize = IntPtr.Size;

    if (value == null)
      return pointerSize;

    var type = value.GetType();
    if (type.IsPrimitive)
      return Marshal.SizeOf(type) + (withoutBoxing ? 0 : pointerSize);

    if (!type.IsValueType) {
      if (visitedRefs.Contains(value))
        return pointerSize;

      visitedRefs.Add(value);
    }

    if (type.IsArray) {
        
      // ReSharper disable once PossibleNullReferenceException
      var hasValueElements = type.GetElementType().IsValueType;
      return pointerSize + sizeof(int) + ((IEnumerable)value).Cast<object>().Sum(v => _GetMemorySize(v, hasValueElements, visitedRefs));
    }

    var fields = type.GetFields(BindingFlags.FlattenHierarchy | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
    long sum = withoutBoxing ? 0 : pointerSize;
    foreach (var field in fields) {
      var fieldValue = field.GetValue(value);
      sum += _GetMemorySize(fieldValue, field.FieldType.IsValueType, visitedRefs);
    }

    return sum;
  }

  #endregion

}

internal class _Cache<TKey, TValue> {

  private ConcurrentDictionary<TKey, _CacheTypes.ICacheItem<TValue>> _items = new ConcurrentDictionary<TKey, _CacheTypes.ICacheItem<TValue>>();
  private readonly int _maxItems;
  private readonly long _maxSize;
  private long _lastUsedId = long.MinValue;
  private long _lastKnownSize;

  private readonly Timer _backgroundTasks;

  private readonly Action _garbageCollection;
  private readonly Func<TKey, TValue> _sourceValueFactory;
  private readonly Func<TKey, _CacheTypes.ICacheItem<TValue>> _valueFactory;
  private readonly Func<TKey, _CacheTypes.ICacheItem<TValue>> _creatorCall;
  private readonly Func<bool> _gcDetector;
  private readonly Func<TKey, _CacheTypes.ICacheItem<TValue>> _itemGetter;
    
  public _Cache(Func<TKey, TValue> valueFactory, int maxItems, long maxSize, CacheReplacementPolicy policy, bool enforceGarbageCollectionUponCreation, TimeSpan lifeTime = default(TimeSpan)) {
    this._sourceValueFactory = valueFactory;
    this.Policy = policy;
            
    var needSizeTracking = maxSize > 0;
    var needValidTracking = lifeTime != default(TimeSpan);

    if (policy == CacheReplacementPolicy.Random) {
      this._garbageCollection = this._RemoveRandom;
      this._valueFactory = this._CreateSelectorLessItem;
    } else if (policy == CacheReplacementPolicy.FirstInFirstOut) {
      this._garbageCollection = this._RemoveBySelector;
      this._valueFactory = this._CreateAgeBasedItem;
    } else if (policy == CacheReplacementPolicy.LastInFirstOut) {
      this._garbageCollection = this._RemoveBySelectorReversed;
      this._valueFactory = this._CreateAgeBasedItem;
    } else if (policy == CacheReplacementPolicy.SmallValuesFirst) {
      this._garbageCollection = this._RemoveBySelector;
      this._valueFactory = this._CreateSizeBasedItem;
      needSizeTracking = true;
    } else if (policy == CacheReplacementPolicy.LargeValuesFirst) {
      this._garbageCollection = this._RemoveBySelectorReversed;
      this._valueFactory = this._CreateSizeBasedItem;
      needSizeTracking = true;
    } else if (policy == CacheReplacementPolicy.LeastRecentlyUsed) {
      this._garbageCollection = this._RemoveBySelector;
      this._valueFactory = this._CreateAccessBasedItem;
    } else if (policy == CacheReplacementPolicy.MostRecentlyUsed) {
      this._garbageCollection = this._RemoveBySelectorReversed;
      this._valueFactory = this._CreateAccessBasedItem;
    } else if (policy == CacheReplacementPolicy.LeastFrequentlyUsed) {
      this._garbageCollection = this._RemoveBySelector;
      this._valueFactory = this._CreateFrequencyBasedItem;
    } else if (policy == CacheReplacementPolicy.MostFrequentlyUsed) {
      this._garbageCollection = this._RemoveBySelectorReversed;
      this._valueFactory = this._CreateFrequencyBasedItem;
    } else if (policy == CacheReplacementPolicy.LeastAvailableLifetimeLeft) {
      this._lastUsedId = lifeTime.Ticks;
      this._garbageCollection = this._RemoveBySelector;
      this._valueFactory = this._CreateLifetimeBasedItem;
    } else if (policy == CacheReplacementPolicy.MostAvailableLifetimeLeft) {
      this._lastUsedId = lifeTime.Ticks;
      this._garbageCollection = this._RemoveBySelectorReversed;
      this._valueFactory = this._CreateLifetimeBasedItem;
    } else if (policy == _CacheReplacementPolicy.NotNeeded) {
      this._garbageCollection = this._RemoveNone;
      this._valueFactory = this._CreateSelectorLessItem;
      maxItems = 0;
      maxSize = 0;
      needSizeTracking = false;
    } else
      throw new NotSupportedException($"Unknown policy: {this.Policy}");

    this._maxItems = maxItems;
    this._maxSize = maxSize;

    this._creatorCall = enforceGarbageCollectionUponCreation
        ? needSizeTracking
          ? (Func<TKey, _CacheTypes.ICacheItem<TValue>>)this._CreateValueWithStatsAndGarbageCollection
          : (Func<TKey, _CacheTypes.ICacheItem<TValue>>)this._CreateValueWithGarbageCollection
        : needSizeTracking
          ? (Func<TKey, _CacheTypes.ICacheItem<TValue>>)this._CreateValueWithStats
          : (Func<TKey, _CacheTypes.ICacheItem<TValue>>)this._CreateValueWithoutStats
      ;

    this._itemGetter = needValidTracking 
      ? (Func<TKey, _CacheTypes.ICacheItem<TValue>>)this._GetCacheForKeyChecked 
      : (Func<TKey, _CacheTypes.ICacheItem<TValue>>)this._GetCacheForKey
    ;

    this._gcDetector =
      maxItems > 0
      ? maxSize > 0
        ? (Func<bool>)this._IsAnyLimitReached
        : (Func<bool>)this._IsMaxItemsLimitReached
      : maxSize > 0
        ? (Func<bool>)this._IsMaxSizeLimitReached
        : (Func<bool>)this._IsLimitWhatever
      ;

    TimerCallback thread;
    if (enforceGarbageCollectionUponCreation)
      if (needValidTracking)
        thread = this._ThreadRemoveAndRecalculate;
      else
        thread = this._ThreadRecalculateStatistics;          
    else {
      if (needValidTracking)
        thread = this._ThreadRemoveRecalculateAndCollect;
      else
        thread = this._ThreadRecalculateAndCollect;
    }

    this._backgroundTasks = new Timer(thread, null, TimeSpan.FromSeconds(60), TimeSpan.FromSeconds(60));
  }

  private bool _NeedsGarbageCollection => this._gcDetector();

  #region gc detect

  private bool _IsLimitWhatever() => false;
  private bool _IsMaxItemsLimitReached() => this._items.Count > 0 && (this._items.Count >= this._maxItems);
  private bool _IsMaxSizeLimitReached() => this._items.Count > 0 && (Interlocked.Read(ref this._lastKnownSize) >= this._maxSize);
  private bool _IsAnyLimitReached() => this._items.Count > 0 && ((Interlocked.Read(ref this._lastKnownSize) >= this._maxSize) || (this._items.Count >= this._maxItems));

  #endregion

  #region possible used ctors

  private _CacheTypes.ICacheItem<TValue> _CreateSelectorLessItem(TKey key) => new _CacheTypes.SelectorLessItem<TValue>(this._sourceValueFactory(key));
  private _CacheTypes.ICacheItem<TValue> _CreateAgeBasedItem(TKey key) => new _CacheTypes.AgeBasedItem<TValue>(this._sourceValueFactory(key), Interlocked.Increment(ref this._lastUsedId));
  private _CacheTypes.ICacheItem<TValue> _CreateSizeBasedItem(TKey key) => new _CacheTypes.SizeBasedItem<TValue>(this._sourceValueFactory(key));
  private _CacheTypes.ICacheItem<TValue> _CreateAccessBasedItem(TKey key) => new _CacheTypes.AccessBasedItem<TValue>(this._sourceValueFactory(key), ()=>Interlocked.Increment(ref this._lastUsedId));
  private _CacheTypes.ICacheItem<TValue> _CreateFrequencyBasedItem(TKey key) => new _CacheTypes.FrequencyBasedItem<TValue>(this._sourceValueFactory(key));
  private _CacheTypes.ICacheItem<TValue> _CreateLifetimeBasedItem(TKey key) => new _CacheTypes.LifetimeBasedItem<TValue>(this._sourceValueFactory(key), new TimeSpan(this._lastUsedId));

  #endregion

  #region possible background tasks

  private void _ThreadRecalculateStatistics(object _)
    => this._RefreshStatistics()
  ;
    
  private void _ThreadRecalculateAndCollect(object _) {
    this._RefreshStatistics();
    this._DoGarbageCollection();
  }

  private void _ThreadRemoveAndRecalculate(object _) {
    this._RemoveEndOfLifeValues();
    this._RefreshStatistics();
  }

  private void _ThreadRemoveRecalculateAndCollect(object _) {
    this._RemoveEndOfLifeValues();
    this._RefreshStatistics();
    this._DoGarbageCollection();
  }

  #endregion

  #region messing with cache items

  private _CacheTypes.ICacheItem<TValue> _GetCacheForKey(TKey key) => this._items.GetOrAdd(key, this._creatorCall);

  private _CacheTypes.ICacheItem<TValue> _GetCacheForKeyChecked(TKey key) {
    do {
      var result = this._GetCacheForKey(key);
      if (((_CacheTypes.IValidTrackingCacheItem)result.Value).IsStillValid)
        return result;

      // value no longer valid - remove
      this._RemoveKey(key);
    } while (true);
  }

  private void _RemoveKey(TKey key) {
    if (!this._items.TryRemove(key, out var item))
      return;

    Interlocked.Add(ref this._lastKnownSize, -item.Size);
    item.Dispose();
  }

  #endregion

  #region how to get values from cache

  private _CacheTypes.ICacheItem<TValue> _CreateValueWithStatsAndGarbageCollection(TKey key) {
    this._DoGarbageCollection();
    return this._CreateValueWithStats(key);
  }
    
  private _CacheTypes.ICacheItem<TValue> _CreateValueWithGarbageCollection(TKey key) {
    this._DoGarbageCollection();
    return this._CreateValueWithoutStats(key);
  }

  private _CacheTypes.ICacheItem<TValue> _CreateValueWithStats(TKey key) {
    var result = this._valueFactory(key);
    Interlocked.Add(ref this._lastKnownSize, result.Size);
    return result;
  }

  private _CacheTypes.ICacheItem<TValue> _CreateValueWithoutStats(TKey key) => this._valueFactory(key);

  #endregion

  #region garbage collection

  private void _DoGarbageCollection() {
    if (!this._NeedsGarbageCollection)
      return;

    this._garbageCollection();
  }

  private void _RemoveEndOfLifeValues() {
    foreach (var kvp in this._items)
      if (!((_CacheTypes.IValidTrackingCacheItem)kvp.Value.Value).IsStillValid)
        this._RemoveKey(kvp.Key);
  }

  #endregion

  #region removal strategies

  private void _RemoveNone() { }

  private void _RemoveRandom() {
    if(this._NeedsGarbageCollection && this._items.Count==1) {
      this.Clear();
      return;
    }

    Random random = new();
    var keys = new TKey[0];
    var index = 0;
    while (this._NeedsGarbageCollection) {

      if (index >= keys.Length) {
        keys = this._items.Keys.ToArray();

        // Fisher-Yates-Shuffle
        for (var i = 0; i < keys.Length; ++i) {
          var j = random.Next(i + 1);
          if (j == i)
            continue;

          var temp = keys[i];
          keys[i] = keys[j];
          keys[j] = temp;
        }

        index = 0;
      }

      this._RemoveKey(keys[index++]);
    }
  }

  private void _RemoveOrdered(bool orderDescending) {
    var keys = new TKey[0];
    var index = 0;
      
    while (this._NeedsGarbageCollection) {
      if (index >= keys.Length) {
        var ordered = orderDescending ? this._items.OrderByDescending(kvp => kvp.Value.Selector) : this._items.OrderBy(kvp => kvp.Value.Selector);
        keys = ordered.Select(i => i.Key).ToArray();
        index = 0;
      }

      this._RemoveKey(keys[index++]);
    }
  }

  private void _RemoveBySelector() => this._RemoveOrdered(false);
  private void _RemoveBySelectorReversed() => this._RemoveOrdered(true);

  #endregion

  private void _RefreshStatistics() {

    var oldSize = Interlocked.Read(ref this._lastKnownSize);

    var size = 0L;
    foreach (var item in this._items.Values) {
      var sizeBasedItem = item.Value as _CacheTypes.SizeBasedItem<TValue>;
      var usedMemory = sizeBasedItem?.RecalculateSize() ?? item.Size;
      size += usedMemory;
    }

    var newSize = Interlocked.Read(ref this._lastKnownSize);
    Interlocked.Exchange(ref this._lastKnownSize, size + (newSize - oldSize));
  }
    
  #region Implementation of IDisposable

  private int _isDisposed;

  public void Dispose() {
    if (Interlocked.CompareExchange(ref this._isDisposed, 1, 0) != 0)
      return;

    this._backgroundTasks.Dispose();
    this.Clear();
    GC.SuppressFinalize(this);
  }

  ~_Cache() => this.Dispose();
    
  #endregion

  #region Implementation of ICache

  public TValue this[TKey key] => this._itemGetter(key).Value;
  public CacheReplacementPolicy Policy { get; }
  public int Count => this._items.Count;
  public long MemoryOverhead => _CacheTypes.GetUsedMemory(this) - this.MemorySize;
  public long MemorySize {
    get {
      var result = Interlocked.Read(ref this._lastKnownSize);
      if(this.Count == 0)
        return 0;

      if(result > 0) 
        return result;
        
      this._RefreshStatistics();
      return Interlocked.Read(ref this._lastKnownSize);
    }
  }

  public void Clear() {
      
    if(this.Policy != CacheReplacementPolicy.LeastAvailableLifetimeLeft && this.Policy != CacheReplacementPolicy.MostAvailableLifetimeLeft )
      Interlocked.Exchange(ref this._lastUsedId, long.MinValue);
      
    var oldCache = Interlocked.Exchange(ref this._items, new ConcurrentDictionary<TKey, _CacheTypes.ICacheItem<TValue>>());
    Interlocked.Exchange(ref this._lastKnownSize, 0);
    foreach (var item in oldCache.Values)
      item.Dispose();
  }

  #endregion
}
