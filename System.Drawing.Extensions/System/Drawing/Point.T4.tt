<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#region (c)2010-2042 Hawkynt
/*
  This file is part of Hawkynt's .NET Framework extensions.

    Hawkynt's .NET Framework extensions are free software: 
    you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Hawkynt's .NET Framework extensions is distributed in the hope that 
    it will be useful, but WITHOUT ANY WARRANTY; without even the implied 
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
    the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Hawkynt's .NET Framework extensions.  
    If not, see <http://www.gnu.org/licenses/>.
*/
#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */

// ReSharper disable PartialTypeWithSinglePart
// ReSharper disable UnusedMember.Global
// ReSharper disable MemberCanBePrivate.Global
#if SUPPORTS_INLINING
using System.Runtime.CompilerServices;
#endif

namespace System.Drawing {
<# 
var d=new[]{Tuple.Create("Point","int"),Tuple.Create("PointF","float")};
for(var k=0;k<d.Length;++k){ 
  var i=d[k];
  var j=d[(k+1)%d.Length];
#>

#if COMPILE_TO_EXTENSION_DLL
  public
#else
  internal
#endif
  static partial class <#=i.Item1#>Extensions {
    public static <#=i.Item1#> SetX(this <#=i.Item1#> @this, <#=i.Item2#> value) => new <#=i.Item1#>(value, @this.Y);
    public static <#=i.Item1#> SetY(this <#=i.Item1#> @this, <#=i.Item2#> value) => new <#=i.Item1#>(@this.X, value);

    public static <#=i.Item1#> Add(this <#=i.Item1#> @this, <#=i.Item1#> other) => Add(@this, other.X, other.Y);

    public static <#=i.Item1#> Add(this <#=i.Item1#> @this, Size other) => Add(@this, other.Width, other.Height);
    public static <#=i.Item1#> Add(this <#=i.Item1#> @this, SizeF other) => Add(@this, other.Width, other.Height);

#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=i.Item1#> Add(this <#=i.Item1#> @this, <#=i.Item2#> x, <#=i.Item2#> y) => new <#=i.Item1#>(@this.X + x, @this.Y + y);
    public static <#=i.Item1#> Add(this <#=i.Item1#> @this, <#=i.Item2#> c) => Add(@this, c, c);
    public static <#=i.Item1#> Add(this <#=i.Item1#> @this, <#=j.Item1#> other) => Add(@this, other.X, other.Y);

#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=i.Item1#> Add(this <#=i.Item1#> @this, <#=j.Item2#> x, <#=j.Item2#> y) => new <#=i.Item1#>((<#=i.Item2#>)(@this.X + x), (<#=i.Item2#>)(@this.Y + y));
    public static <#=i.Item1#> Add(this <#=i.Item1#> @this, <#=j.Item2#> c) => Add(@this, c, c);

    public static <#=i.Item1#> Substract(this <#=i.Item1#> @this, <#=i.Item1#> other) => Add(@this, -other.X, -other.Y);
    public static <#=i.Item1#> Substract(this <#=i.Item1#> @this, <#=i.Item2#> x, <#=i.Item2#> y) => Add(@this, -x, -y);
    public static <#=i.Item1#> Substract(this <#=i.Item1#> @this, <#=i.Item2#> c) => Add(@this, -c, -c);
    public static <#=i.Item1#> Substract(this <#=i.Item1#> @this, <#=j.Item1#> other) => Add(@this, -other.X, -other.Y);
    public static <#=i.Item1#> Substract(this <#=i.Item1#> @this, <#=j.Item2#> x, <#=j.Item2#> y) => Add(@this, -x, -y);
    public static <#=i.Item1#> Substract(this <#=i.Item1#> @this, <#=j.Item2#> c) => Add(@this, -c, -c);
    
    public static <#=i.Item1#> Substract(this <#=i.Item1#> @this, Size other) => Substract(@this, other.Width, other.Height);
    public static <#=i.Item1#> Substract(this <#=i.Item1#> @this, SizeF other) => Substract(@this, other.Width, other.Height);
    
    public static <#=i.Item1#> MultiplyBy(this <#=i.Item1#> @this, <#=i.Item1#> other) => MultiplyBy(@this, other.X, other.Y);

#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=i.Item1#> MultiplyBy(this <#=i.Item1#> @this, <#=i.Item2#> x, <#=i.Item2#> y) => new <#=i.Item1#>(@this.X * x, @this.Y * y);
    public static <#=i.Item1#> MultiplyBy(this <#=i.Item1#> @this, <#=i.Item2#> c) => MultiplyBy(@this, c, c);
    public static <#=i.Item1#> MultiplyBy(this <#=i.Item1#> @this, <#=j.Item1#> other) => MultiplyBy(@this, other.X, other.Y);

#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=i.Item1#> MultiplyBy(this <#=i.Item1#> @this, <#=j.Item2#> x, <#=j.Item2#> y) => new <#=i.Item1#>((<#=i.Item2#>)(@this.X * x), (<#=i.Item2#>)(@this.Y * y));
    public static <#=i.Item1#> MultiplyBy(this <#=i.Item1#> @this, <#=j.Item2#> c) => MultiplyBy(@this, c, c);

    public static <#=i.Item1#> DivideBy(this <#=i.Item1#> @this, <#=i.Item1#> other) => DivideBy(@this, other.X, other.Y);

#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=i.Item1#> DivideBy(this <#=i.Item1#> @this, <#=i.Item2#> x, <#=i.Item2#> y) => new <#=i.Item1#>(@this.X / x, @this.Y / y);
    public static <#=i.Item1#> DivideBy(this <#=i.Item1#> @this, <#=i.Item2#> c) => DivideBy(@this, c, c);
    public static <#=i.Item1#> DivideBy(this <#=i.Item1#> @this, <#=j.Item1#> other) => DivideBy(@this, other.X, other.Y);

#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=i.Item1#> DivideBy(this <#=i.Item1#> @this, <#=j.Item2#> x, <#=j.Item2#> y) => new <#=i.Item1#>((<#=i.Item2#>)(@this.X / x), (<#=i.Item2#>)(@this.Y / y));
    public static <#=i.Item1#> DivideBy(this <#=i.Item1#> @this, <#=j.Item2#> c) => DivideBy(@this, c, c);

    public static <#=i.Item2#> Amount(this <#=i.Item1#> @this) => Math.Abs(@this.X) + Math.Abs(@this.Y);
  }
<# } #>

#if COMPILE_TO_EXTENSION_DLL
  public
#else
  internal
#endif
  static partial class PointExtensions {

#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static PointF ToFloat(this Point @this) => new PointF(@this.X, @this.Y);

  }

#if COMPILE_TO_EXTENSION_DLL
  public
#else
  internal
#endif
  static partial class PointFExtensions {
  
#if SUPPORTS_INLINING
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static Point ToInteger(this PointF @this) => new Point((int)@this.X, (int)@this.Y);

  }

}