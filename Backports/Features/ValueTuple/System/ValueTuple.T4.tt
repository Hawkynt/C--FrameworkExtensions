<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
#region (c)2010-2042 Hawkynt

// This file is part of Hawkynt's .NET Framework extensions.
//
// Hawkynt's .NET Framework extensions are free software:
// you can redistribute and/or modify it under the terms
// given in the LICENSE file.
//
// Hawkynt's .NET Framework extensions is distributed in the hope that
// it will be useful, but WITHOUT ANY WARRANTY without even the implied
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the LICENSE file for more details.
//
// You should have received a copy of the License along with Hawkynt's
// .NET Framework extensions. If not, see
// <https://github.com/Hawkynt/C--FrameworkExtensions/blob/master/LICENSE>.

#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */

#if !SUPPORTS_VALUE_TUPLE

using Guard;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using MethodImplOptions = Utilities.MethodImplOptions;

namespace System;

<#
const int MaxArity = 7;

string TypeParams(int n) => string.Join(", ", Enumerable.Range(1, n).Select(i => $"T{i}"));
string Args(int n) => string.Join(", ", Enumerable.Range(1, n).Select(i => $"T{i} item{i}"));

string Ordinal(int i) => i switch {
    1 => "first", 2 => "second", 3 => "third", 4 => "fourth",
    5 => "fifth", 6 => "sixth", 7 => "seventh", 8 => "eighth", _ => $"{i}th"
};

string Summary(string text) => $"  /// <summary>\n  ///   {text.Replace("\n", "\n  ///   ")}\n  /// </summary>";
string Param(string name, string desc) => $"  /// <param name=\"{name}\">{desc}</param>";
string Returns(string desc) => $"  /// <returns>{desc}</returns>";
string TypeParam(string name, string desc) => $"  /// <typeparam name=\"{name}\">{desc}</typeparam>";
string EqualsBody(int n) =>
    string.Join(Environment.NewLine, Enumerable.Range(1, n).Select(i => $"    && EqualityComparer<T{i}>.Default.Equals(this.Item{i}, other.Item{i})"))
    .TrimStart('&', ' ');

string HashBody(int n) => n == 1 ? "EqualityComparer<T1>.Default.GetHashCode(this.Item1)" : $"NumericsHelpers.CombineHash({string.Join(", ", Enumerable.Range(1, n).Select(i => $"EqualityComparer<T{i}>.Default.GetHashCode(this.Item{i})"))})";
string HashBody2(int n) => n == 1 ? "comparer.GetHashCode(this.Item1)" : $"NumericsHelpers.CombineHash({string.Join(", ", Enumerable.Range(1, n).Select(i => $"comparer.GetHashCode(this.Item{i})"))})";

for (int arity = 1; arity <= MaxArity; arity++) {
#>
<#= Summary($"Represents a {arity}-tuple as a value type.") #>
<#
for (int i = 1; i <= arity; i++) {
#>
<#= TypeParam($"T{i}", $"The type of the {Ordinal(i)} component of the tuple.") #>
<#
}
#>
[StructLayout(LayoutKind.Auto)]
[method: MethodImpl(MethodImplOptions.AggressiveInlining)]
public struct ValueTuple<<#= TypeParams(arity) #>>(<#= Args(arity) #>) :
  IEquatable<ValueTuple<<#= TypeParams(arity) #>>>,
  IStructuralEquatable,
  IStructuralComparable,
  IComparable,
  IComparable<ValueTuple<<#= TypeParams(arity) #>>>,
  ITupleInternal {

<#
for (int i = 1; i <= arity; i++) {
#>
  /// <summary>The value of the <#= Ordinal(i) #> component.</summary>
  public T<#= i #> Item<#= i #> = item<#= i #>;
<#
}
#>

  int ITupleInternal.Size {
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    get => <#= arity #>;
  }

<#= Summary("Compares this instance to a specified instance and returns an indication of their relative values.") #>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public int CompareTo(ValueTuple<<#= TypeParams(arity) #>> other) {
<#
  for (int i = 1; i <= arity; ++i) {
      if (i == 1) {#>
    var c = Comparer<T<#=i#>>.Default.Compare(this.Item<#=i#>, other.Item<#=i#>);
<#    } else {#>
    if (c != 0) return c;
    c = Comparer<T<#=i#>>.Default.Compare(this.Item<#=i#>, other.Item<#=i#>);
<#    }
  }
#>
    return c;
  }

<#= Summary("Returns a value indicating whether this instance is equal to a specified object.") #>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public override bool Equals(object obj) =>
    obj is ValueTuple<<#= TypeParams(arity) #>> valueTuple && this.Equals(valueTuple);

<#= Summary($"Returns whether this tuple equals another {arity}-tuple of the same type.") #>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public bool Equals(ValueTuple<<#= TypeParams(arity) #>> other) =>
<#= EqualsBody(arity) #>;

<#= Summary("Returns the hash code for this instance.") #>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public override int GetHashCode() => <#= HashBody(arity) #>;

<#= Summary("Returns a string that represents the value of this tuple.") #>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public override string ToString() => "(" + this.ToStringEnd();

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public int CompareTo(object obj) {
    switch (obj) {
      case null: return 1;
      case ValueTuple<<#= TypeParams(arity) #>> tuple: return this.CompareTo(tuple);
      default:
        AlwaysThrow.ArgumentException(nameof(obj), "Expected ValueTuple of correct arity.");
        return 0;
    }
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public int CompareTo(object other, IComparer comparer) {
    switch (other) {
      case null: return 1;
      case ValueTuple<<#= TypeParams(arity) #>> tuple:
<#
  for (int i = 1; i <= arity; ++i) {
      if (i == 1) {#>
        var c = comparer.Compare(this.Item<#=i#>, tuple.Item<#=i#>);
<#    } else {#>
        if (c != 0) return c;
        c = comparer.Compare(this.Item<#=i#>, tuple.Item<#=i#>);
<#    }
  }
#>
        return c;
      default:
        AlwaysThrow.ArgumentException(nameof(other), "Expected ValueTuple of correct arity.");
        return 0;
    }
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public bool Equals(object other, IEqualityComparer comparer) =>
    other is ValueTuple<<#= TypeParams(arity) #>> tuple
<#= string.Join(Environment.NewLine, Enumerable.Range(1, arity).Select(i => $"      && comparer.Equals(this.Item{i}, tuple.Item{i})")) #>;

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public int GetHashCode(IEqualityComparer comparer) => <#= HashBody2(arity) #>;
    
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public readonly string ToStringEnd() => <#= $"$\"{string.Join(", ", Enumerable.Range(1, arity).Select(i => $"{{this.Item{i}}}"))})\"" #>;
}

<#
} // end for
#>

/// <summary>
///   Provides extension methods for <see cref="Tuple" /> instances to interop with C# tuples features (deconstruction
///   syntax, converting from and to <see cref="ValueTuple" />).
/// </summary>
partial class TupleExtensions {
<#
int Max = 21;

string GenList(int count, Func<int, string> gen) =>
    string.Join(", ", Enumerable.Range(1, count).Select(gen));

string GetTupleType(int count, int start = 1) {
    if (count <= 7)
        return $"Tuple<{GenList(count, i => $"T{start + i - 1}")}>";
    return $"Tuple<{GenList(7, i => $"T{start + i - 1}")}, {GetTupleType(count - 7, start + 7)}>";
}

string GetValueTupleType(int count, int start = 1) {
    if (count <= 7)
        return $"ValueTuple<{GenList(count, i => $"T{start + i - 1}")}>";
    return $"ValueTuple<{GenList(7, i => $"T{start + i - 1}")}, {GetValueTupleType(count - 7, start + 7)}>";
}

string GetArgs(int count) =>
    GenList(count, i => $"value.Item{i}");

string GetArgsNested(int count, string prefix = "value.Rest") {
    if (count <= 7)
        return $"ValueTuple.Create({GenList(count, i => $"{prefix}.Item{i}")})";

    string head = GenList(7, i => $"{prefix}.Item{i}");
    string rest = GetArgsNested(count - 7, $"{prefix}.Rest");
    return $"CreateLong({head}, {rest})";
}

string GetArgsNestedRef(int count, string prefix = "value.Rest") {
    if (count <= 7)
        return $"Tuple.Create({GenList(count, i => $"{prefix}.Item{i}")})";

    string head = GenList(7, i => $"{prefix}.Item{i}");
    string rest = GetArgsNestedRef(count - 7, $"{prefix}.Rest");
    return $"CreateLongRef({head}, {rest})";
}

for (int count = 1; count <= Max; count++) {
#>
  [EditorBrowsable(EditorBrowsableState.Never)]
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Deconstruct<<#= GenList(count, i => $"T{i}") #>>(
    this <#= GetTupleType(count, 1) #> value,
    <#= GenList(count, i => $"out T{i} item{i}") #>
  ) {
    if (value == null)
      AlwaysThrow.NullReferenceException(nameof(value));
<#
    for (int i = 1; i <= count; i++) {
        var prefix = i <= 7 ? "" : string.Concat(Enumerable.Repeat(".Rest", (i - 1) / 7));
        var itemNum = ((i - 1) % 7) + 1;
#>
    item<#= i #> = value<#= prefix #>.Item<#= itemNum #>;
<#
    }
#>
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#= GetTupleType(count, 1) #>
    ToTuple<<#= GenList(count, i => $"T{i}") #>>(this <#= GetValueTupleType(count, 1) #> value) =>
<#
    if (count <= 7) {
#>
    Tuple.Create(<#= GetArgs(count) #>);
<#
    } else {
#>
    CreateLongRef(
      <#= GenList(7, i => $"value.Item{i}") #>,
      <#= GetArgsNestedRef(count - 7) #>
    );
<#
    }
#>

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static <#= GetValueTupleType(count, 1) #>
    ToValueTuple<<#= GenList(count, i => $"T{i}") #>>(this <#= GetTupleType(count, 1) #> value) {
    if (value == null)
      AlwaysThrow.NullReferenceException(nameof(value));
<#
    if (count <= 7) {
#>
    return ValueTuple.Create(<#= GetArgs(count) #>);
<#
    } else {
#>
    return CreateLong(
      <#= GenList(7, i => $"value.Item{i}") #>,
      <#= GetArgsNested(count - 7) #>
    );
<#
    }
#>
  }

<#
}
#>
}

#endif
