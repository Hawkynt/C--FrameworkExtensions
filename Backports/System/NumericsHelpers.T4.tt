<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
#region (c)2010-2042 Hawkynt
/*
  This file is part of Hawkynt's .NET Framework extensions.

    Hawkynt's .NET Framework extensions are free software: 
    you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Hawkynt's .NET Framework extensions is distributed in the hope that 
    it will be useful, but WITHOUT ANY WARRANTY; without even the implied 
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
    the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Hawkynt's .NET Framework extensions.  
    If not, see <http://www.gnu.org/licenses/>.
*/
#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */

namespace System.Numerics;

using Runtime.CompilerServices;
using MethodImplOptions = Utilities.MethodImplOptions;

internal static class NumericsHelpers {
  <# 
  var primes = new[] { 16777619, 334214459, 2147483647, 1610612741, 805306457, 402653189, 2038074743, 4856531 };
  var rotations = new[] { 5, 13, 9, 7, 15, 3, 11, 17 };

  for (int paramCount = 2; paramCount <= 8; ++paramCount)
      GenerateGetHashCode(paramCount, primes, rotations);
  #>
}

<#+
  private void GenerateGetHashCode(int paramCount, int[] primes, int[] rotations) {
    // Define the argument list
    var arguments = Enumerable.Range(1, paramCount).Select(i => $"int n{i}").ToArray();
  
    var builder = new StringBuilder();
    
    // Begin preprocessor directive for built-in CombineHash
    builder.AppendLine();
    builder.AppendLine("  [MethodImpl(MethodImplOptions.AggressiveInlining)]");
    builder.AppendLine("#if SUPPORTS_SYSTEM_HASHCODE");

    // use built-in CombineHash if available
    builder.AppendLine($"  public static int CombineHash({string.Join(", ", arguments)}) => HashCode.Combine({string.Join(", ", Enumerable.Range(1, paramCount).Select(i => $"n{i}"))});");
        
    // Else part for custom implementation
    builder.AppendLine("#else");

    // Create method signature again for custom implementation
    builder.AppendLine($"  public static int CombineHash({string.Join(", ", arguments)}) {{");
    builder.AppendLine("    var hash = 2166136261U;"); // FNV-1a offset basis
    builder.AppendLine("    unchecked {");
    for (var i = 1; i <= paramCount; ++i) {
      builder.AppendLine($"      hash = (hash ^ (uint)n{i}) * {primes[i - 1]}U;");
      builder.AppendLine($"      hash = {GenerateRotateLeftCode("hash", rotations[i - 1])};");
    }
    
    builder.AppendLine("    }");
    builder.AppendLine("    return (int)hash;");
    builder.AppendLine("  }");
    
    builder.AppendLine("#endif");

    WriteLine(builder.ToString());
  }

  // Generate the inlined rotate-left operation
  private string GenerateRotateLeftCode(string variableName, int count) {
    return $"({variableName} << {count}) | ({variableName} >> {32 - count})";
  }  
#>
