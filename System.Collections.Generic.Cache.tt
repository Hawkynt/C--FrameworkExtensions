<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Linq" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
#region (c)2010-2020 Hawkynt
/*
  This file is part of Hawkynt's .NET Framework extensions.

    Hawkynt's .NET Framework extensions are free software: 
    you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Hawkynt's .NET Framework extensions is distributed in the hope that 
    it will be useful, but WITHOUT ANY WARRANTY; without even the implied 
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
    the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Hawkynt's .NET Framework extensions.  
    If not, see <http://www.gnu.org/licenses/>.
*/
#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */

using System.Collections.Concurrent;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Linq;

  #if NETFX_4
using System.Diagnostics.Contracts;
#endif

namespace System.Collections.Generic {


  /// <summary>
  /// Tells us how items get replaced when the cache exceeds its limits.
  /// </summary>
  internal enum CacheReplacementPolicy {
    
    /// <summary>
    /// Removes the n least recently used elements from the cache to get new space.
    /// </summary>
    LeastRecentlyUsed,
    
    /// <summary>
    /// Removes the n most recently used elements from the cache to get new space.
    /// </summary>
    MostRecentlyUsed,
    
    /// <summary>
    /// Removes the first n elements from the cache to get new space.
    /// </summary>
    FirstInFirstOut,
    
    /// <summary>
    /// Removes the last n added elements from the cache to get new space.
    /// </summary>
    LastInFirstOut,

    /// <summary>
    /// Removes random elements from the cache to get new space.
    /// </summary>
    Random,
  }

<#for(var i=1;i<8;++i){
  var isSingleParameter=i<2;
  var typeDef=isSingleParameter?"TInput":string.Join(", ",Enumerable.Range(1,i).Select(j=>"TInput"+j));
  var parameterDef=isSingleParameter?"TInput parameter":string.Join(", ",Enumerable.Range(1,i).Select(j=>"TInput"+j+" parameter"+j));
  var parameterCall=isSingleParameter?"parameter":string.Join(", ",Enumerable.Range(1,i).Select(j=>"parameter"+j));
  var tupleType="Tuple<"+(isSingleParameter?typeDef+", byte":typeDef)+">";
  var tupleCreate="Tuple.Create("+(isSingleParameter?parameterCall+", (byte)0":parameterCall)+")";
#>

  /// <summary>
  /// Provides a Cache for methods returning one result of TOuput and getting <#=i#> parameters.
  /// </summary>
  internal sealed class Cache<<#=typeDef#>, TOutput> {
    private readonly Func<<#=typeDef#>, TOutput> _valueGetter;
    private readonly Func<int> _countGetter;
    private readonly Func<long> _sizeGetter;

    public static Cache<<#=typeDef#>, TOutput> FromFactory(Func<<#=typeDef#>, TOutput> factory, bool isThreadSafe = false) {
#if NETFX_4
      Contract.Requires(factory != null);
#endif
      return new Cache<<#=typeDef#>, TOutput>(factory, isThreadSafe, 0, 0, null);
    }

    public static Cache<<#=typeDef#>, TOutput> FromFactoryWithMaxItemCount(Func<<#=typeDef#>, TOutput> factory, int maxItems, CacheReplacementPolicy policy = CacheReplacementPolicy.LeastRecentlyUsed, bool isThreadSafe = false) {
#if NETFX_4
      Contract.Requires(factory != null);
      Contract.Requires(maxItems > 0);
#endif
      return new Cache<<#=typeDef#>, TOutput>(factory, isThreadSafe, maxItems, 0, policy);
    }

    public static Cache<<#=typeDef#>, TOutput> FromFactoryWithMaxMemorySize(Func<<#=typeDef#>, TOutput> factory, long maxSizeInBytes, CacheReplacementPolicy policy = CacheReplacementPolicy.LeastRecentlyUsed, bool isThreadSafe = false) {
#if NETFX_4
      Contract.Requires(factory != null);
      Contract.Requires(maxSizeInBytes > 0);
#endif
      return new Cache<<#=typeDef#>, TOutput>(factory, isThreadSafe, 0, maxSizeInBytes, policy);
    }
    
    private Cache(Func<<#=typeDef#>, TOutput> factory, bool isThreadSafe, int maxItemCount, long maxMemoryFootprint, CacheReplacementPolicy? policy) {
      
      if(isThreadSafe){
        var values = new ConcurrentDictionary<<#=tupleType#>, TOutput>();
        Action tryTidyCache = null;
        var hasMaxItems = maxItemCount > 0;
        if(policy != null && (hasMaxItems || maxMemoryFootprint > 0)) {
          switch(policy.Value){
            case CacheReplacementPolicy.Random: {
              if(hasMaxItems)
                tryTidyCache = () => _CacheUtils._RemoveRandomElementsByCount(values, 1, maxItemCount);
              else
                throw new NotImplementedException();
              break;
            }
            default:
              throw new NotSupportedException(nameof(policy));
          }
        }
        
        if(tryTidyCache == null)
          this._valueGetter = (<#=parameterCall#>) => values.GetOrAdd(<#=tupleCreate#>, _ => factory(<#=parameterCall#>));
        else
          this._valueGetter = (<#=parameterCall#>) => values.GetOrAdd(<#=tupleCreate#>, _ => { tryTidyCache(); return factory(<#=parameterCall#>); });

        this._countGetter = () => values.Count;
        this._sizeGetter = () => _CacheUtils._GetUsedMemory(values);
      }else{
        var values = new Dictionary<<#=tupleType#>, TOutput>();
        Action tryTidyCache = null;
        var hasMaxItems = maxItemCount > 0;
        if(policy != null && (hasMaxItems || maxMemoryFootprint > 0)) {
          switch(policy.Value){
            case CacheReplacementPolicy.Random: {
              if(hasMaxItems)
                tryTidyCache = () => _CacheUtils._RemoveRandomElementsByCount(values, 1, maxItemCount);
              else
                throw new NotImplementedException();
              break;
            }
            default:
              throw new NotSupportedException(nameof(policy));
          }
        }
        
        if(tryTidyCache == null)
          this._valueGetter = (<#=parameterCall#>) => {
            var key = <#=tupleCreate#>;
            if(values.ContainsKey(key))
              return values[key];

            var result = factory(<#=parameterCall#>);
            values.Add(key,result);
            return result;
          };
        else
          this._valueGetter = (<#=parameterCall#>) => {
            var key = <#=tupleCreate#>;
            if(values.ContainsKey(key))
              return values[key];

            var result = factory(<#=parameterCall#>);
            tryTidyCache();
            values.Add(key,result);
            return result;
          };
        this._countGetter = () => values.Count;
        this._sizeGetter = () => _CacheUtils._GetUsedMemory(values);
      }
    }

    /// <summary>
    /// Get the number of currently cached elements.
    /// </summary>
    public int Count => this._countGetter();
    public long MemorySize => this._sizeGetter();

    /// <summary>
    /// Gets the value (either from cache or calculates it and stores it for later re-usage).
    /// </summary><#for(var j=1;j<=i;++j){#>

    /// <parameter name="parameter<#=j#>">Parameter #<#=j#></parameter><#}#>

    /// <returns>The calculated value</returns>
    public TOutput Value(<#=parameterDef#>) => this._valueGetter(<#=parameterCall#>);

  }

<#}#>

  internal static class _CacheUtils {
    
    internal static void _RemoveRandomElementsByCount<TKey, TValue>(ConcurrentDictionary<TKey, TValue> values, int newItems, int maxItems) {
      var random = new Lazy<Random>(() => new Random(), false);
      TValue dummy;
      while(true) {
        var shouldRemove = (values.Count - maxItems + newItems) > 0;
        if(!shouldRemove)
          return;

        var keys = values.Keys.ToArray();
        values.TryRemove(keys[random.Value.Next(keys.Length)], out dummy);
      }
    }

    internal static void _RemoveRandomElementsByCount<TKey, TValue>(Dictionary<TKey, TValue> values, int newItems, int maxItems) {
      var itemsToRemove = values.Count - maxItems + newItems;
      if(itemsToRemove <= 0)
        return;

      // Fisher-Yates-Shuffle
      var random = new Random();
      var keyCount = values.Count;
      var keys = new TKey[keyCount];
      var i = 0;
      foreach(var key in values.Keys) {
        var j = random.Next(i + 1);
        if(j == i)
          keys[i]=key;
        else {
          keys[i]=keys[j];
          keys[j]=key;
        }
        ++i;
      }

      for(i = 0; i < itemsToRemove; ++i) 
        values.Remove(keys[i]);
    }

    internal static long _GetUsedMemory<TValue>(TValue value)=> _GetMemorySize(value, typeof(TValue).IsValueType);

    private static long _GetMemorySize(object value, bool withoutBoxing, HashSet<object> visitedRefs = null) {
      var pointerSize = IntPtr.Size;

      if (ReferenceEquals(null, value))
        return pointerSize;

      var type = value.GetType();
      if (type.IsPrimitive)
        return Marshal.SizeOf(type) + (withoutBoxing ? 0 : pointerSize);

      if (visitedRefs == null)
        visitedRefs = new HashSet<object>();

      if (type.IsArray) {
        if (visitedRefs.Contains(value))
          return pointerSize;

        var valueElements = type.GetElementType().IsValueType;
        return pointerSize + sizeof(int) + ((IEnumerable)value).Cast<object>().Sum(v => _GetMemorySize(v, valueElements, visitedRefs));
      }

      var fields = type.GetFields(BindingFlags.FlattenHierarchy | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
      long sum = withoutBoxing ? 0 : pointerSize;
      foreach (var field in fields) {
        var fieldValue = field.GetValue(value);
        if (visitedRefs.Contains(fieldValue))
          sum += pointerSize;
        else {
          sum += _GetMemorySize(fieldValue, field.FieldType.IsValueType, visitedRefs);
          visitedRefs.Add(fieldValue);
        }
      }

      return sum;
    }

  }

}