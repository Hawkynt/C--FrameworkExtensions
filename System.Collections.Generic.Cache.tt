<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Linq" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
#region (c)2010-2020 Hawkynt
/*
  This file is part of Hawkynt's .NET Framework extensions.

    Hawkynt's .NET Framework extensions are free software: 
    you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Hawkynt's .NET Framework extensions is distributed in the hope that 
    it will be useful, but WITHOUT ANY WARRANTY; without even the implied 
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
    the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Hawkynt's .NET Framework extensions.  
    If not, see <http://www.gnu.org/licenses/>.
*/
#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */

using System.Collections.Concurrent;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Linq;
using System.Threading;

// ReSharper disable RedundantCast
// ReSharper disable UnusedMember.Global
// TODO: do not gather statistics if not needed/requested
// TODO: least frequently used/most frequently used
namespace System.Collections.Generic {

  /// <summary>
  /// Tells us how items get replaced when the cache exceeds its limits.
  /// </summary>
  internal enum CacheReplacementPolicy:byte {
    /// <summary>
    /// Removes random elements from the cache.
    /// </summary>
    Random = 0,
    /// <summary>
    /// Removes the last n elements added to the cache.
    /// </summary>
    LastInFirstOut = 1,
    /// <summary>
    /// Removes the first n elements added to the cache.
    /// </summary>
    FirstInFirstOut = 2,
    /// <summary>
    /// Removes the n most recently accessed elements in the cache.
    /// </summary>
    MostRecentlyUsed = 3,
    /// <summary>
    /// Remove the n least recently accessed element in the cache.
    /// </summary>
    LeastRecentlyUsed = 4,
    /// <summary>
    /// Removes the n smallest elements.
    /// </summary>
    SmallValuesFirst = 5,
    /// <summary>
    /// Removes the n largest elements.
    /// </summary>
    LargeValuesFirst = 6,
  }

<#for(var i=1;i<8;++i){
  var isSingleParameter=i<2;
  var typeDef=isSingleParameter?"TInput":string.Join(", ",Enumerable.Range(1,i).Select(j=>"TInput"+j));
  var covariantTypeDef=isSingleParameter?"in TInput":string.Join(", ",Enumerable.Range(1,i).Select(j=>"in TInput"+j));
  var parameterDef=isSingleParameter?"TInput parameter":string.Join(", ",Enumerable.Range(1,i).Select(j=>"TInput"+j+" parameter"+j));
  var parameterCall=isSingleParameter?"parameter":string.Join(", ",Enumerable.Range(1,i).Select(j=>"parameter"+j));
  var tupleType="Tuple<"+(isSingleParameter?typeDef+", byte":typeDef)+">";
  var tupleCreate="Tuple.Create("+(isSingleParameter?parameterCall+", (byte)0":parameterCall)+")";
#>
  #region dependend on number (<#=i#>) of input parameters

  internal interface ICache<<#=covariantTypeDef#>, out TValue> : IDisposable {
    TValue this[<#=parameterDef#>] { get; }
    _CacheReplacementPolicy Policy { get; }
    int Count { get; }
    long MemorySize { get; }
    void Clear();
  }

  internal static class Cache<<#=typeDef#>, TValue> {
    private static TValue _CreateFromTuple(<#=tupleType#> tuple, Func<<#=typeDef#>, TValue> factory) {
      return factory(<#=string.Join(", ",Enumerable.Range(1,i).Select(j=>"tuple.Item"+j))#>);
    }

    private static _CacheItemWithLifetime<TValue> _CreateFromTuple(<#=tupleType#> tuple, Func<<#=typeDef#>, TValue> factory, TimeSpan maxAge) {
      return new _CacheItemWithLifetime<TValue>(factory(<#=string.Join(", ",Enumerable.Range(1,i).Select(j=>"tuple.Item"+j))#>), maxAge);
    }

    /// <summary>Creates a cache with a maximum number of entries</summary>
    /// <param name="factory">The method that is used to generate values for cache entries</param>
    /// <param name="maxItems">The maximum number of items to hold at once before discarding items</param>
    /// <param name="policy">The algorithm used to determine which items will be discarded first</param>
    /// <param name="lazyCollect">
    ///   <c>true</c> causes the cache to use a background thread to discard items; otherwise <c>false</c> (default).
    ///   <note>
    ///     <br /><c>true</c> - until the background thread discards items, the item limit may be temporarily overriden.
    ///     <br /><c>false</c> - causes items to be discarded just before adding new items thus slowing down add operations.
    ///   </note>
    /// </param>

    public static ICache<<#=typeDef#>, TValue> FromFactoryWithMaxItemCount(Func<<#=typeDef#>, TValue> factory, int maxItems, CacheReplacementPolicy policy, bool lazyCollect = false)
      => new _CacheWithItemWithoutLifetime<<#=typeDef#>, TValue>(new _Cache<<#=tupleType#>, TValue>(t => _CreateFromTuple(t, factory), maxItems, 0, (_CacheReplacementPolicy)policy, !lazyCollect, null))
      ;

    /// <summary>Creates a cache with a maximum memory usage</summary>
    /// <param name="factory">The method that is used to generate values for cache entries</param>
    /// <param name="maxSizeInBytes">The maximum number of bytes to hold at once before discarding items</param>
    /// <param name="policy">The algorithm used to determine which items will be discarded first</param>
    /// <param name="lazyCollect">
    ///   <c>true</c> causes the cache to use a background thread to discard items; otherwise <c>false</c> (default).
    ///   <note>
    ///     <br /><c>true</c> - until the background thread discards items, the memory limit may be temporarily overriden.
    ///     <br /><c>false</c> - causes items to be discarded just before adding new items thus slowing down add operations.
    ///   </note>
    /// </param>
    public static ICache<<#=typeDef#>, TValue> FromFactoryWithMaxMemorySize(Func<<#=typeDef#>, TValue> factory, long maxSizeInBytes, CacheReplacementPolicy policy, bool lazyCollect = false)
      => new _CacheWithItemWithoutLifetime<<#=typeDef#>, TValue>(new _Cache<<#=tupleType#>, TValue>(t => _CreateFromTuple(t, factory), 0, maxSizeInBytes, (_CacheReplacementPolicy)policy, !lazyCollect, null))
    ;

    /// <summary>Creates a cache with a maximum item lifetime</summary>
    /// <param name="factory">The method that is used to generate values for cache entries</param>
    /// <param name="maxAge">The maximum lifetime of items before they're discarded.</param>
    /// <note>A background thread removes dead items.</note>
    public static ICache<<#=typeDef#>, TValue> FromFactoryWithMaxItemLifetime(Func<<#=typeDef#>, TValue> factory, TimeSpan maxAge)
      => new _CacheWithItemLifetime<<#=typeDef#>, TValue>(new _Cache<<#=tupleType#>, _CacheItemWithLifetime<TValue>>(t=>_CreateFromTuple(t, factory, maxAge), 0, 0, _CacheReplacementPolicy.NotNeeded, false, i => DateTime.UtcNow < i.validUntil))
      ;

  }

  internal class _CacheWithItemWithoutLifetime<<#=typeDef#>, TValue> : ICache<<#=typeDef#>, TValue> {

    private readonly _Cache<<#=tupleType#>, TValue> _cache;
    public _CacheWithItemWithoutLifetime(_Cache<<#=tupleType#>, TValue> cache) {
      this._cache = cache;
    }

    #region Implementation of IDisposable

    public void Dispose() {
      this._cache.Dispose();
      GC.SuppressFinalize(this);
    }

    ~_CacheWithItemWithoutLifetime() {
      this.Dispose();
    }

    #endregion

    #region Implementation of ICache

    public TValue this[<#=parameterDef#>] => this._cache[<#=tupleCreate#>];
    public _CacheReplacementPolicy Policy => this._cache.Policy;
    public int Count => this._cache.Count;
    public long MemorySize => this._cache.MemorySize;
    public void Clear() => this._cache.Clear();

    #endregion
  }

  internal class _CacheWithItemLifetime<<#=typeDef#>, TValue> : ICache<<#=typeDef#>, TValue> {

    private readonly _Cache<<#=tupleType#>, _CacheItemWithLifetime<TValue>> _cache;
    public _CacheWithItemLifetime(_Cache<<#=tupleType#>, _CacheItemWithLifetime<TValue>> cache) {
      this._cache = cache;
    }

    #region Implementation of IDisposable

    public void Dispose() {
      this._cache.Dispose();
      GC.SuppressFinalize(this);
    }

    ~_CacheWithItemLifetime() {
      this.Dispose();
    }

    #endregion

    #region Implementation of ICache

    public TValue this[<#=parameterDef#>] => this._cache[<#=tupleCreate#>].value;
    public _CacheReplacementPolicy Policy => this._cache.Policy;
    public int Count => this._cache.Count;
    public long MemorySize => this._cache.MemorySize;
    public void Clear() => this._cache.Clear();

    #endregion
  }

  #endregion

<#}#>
  
  internal class _CacheItemWithLifetime<TItem> : IDisposable {
    public readonly DateTime validUntil;
    public readonly TItem value;

    public _CacheItemWithLifetime(TItem value, TimeSpan timeout) {
      this.value = value;
      this.validUntil = DateTime.UtcNow + timeout;
    }

    #region IDisposable

    private int _isDisposed;

    ~_CacheItemWithLifetime() {
      this.Dispose();
    }

    public void Dispose() {
      if (Interlocked.CompareExchange(ref this._isDisposed, 1, 0) != 0)
        return;

      (this.value as IDisposable)?.Dispose();
      GC.SuppressFinalize(this);
    }

    #endregion
  }

  internal enum _CacheReplacementPolicy:byte {
    Random = 0,
    LastInFirstOut = 1,
    FirstInFirstOut = 2,
    MostRecentlyUsed = 3,
    LeastRecentlyUsed = 4,
    SmallValuesFirst = 5,
    LargeValuesFirst = 6,
    NotNeeded = 255,
  }

  internal class _Cache<TKey, TValue> {

    private class CacheItem<TItem> {
      public readonly long id;
      public long size;
      public readonly TItem value;
      public long accessId;
      public CacheItem(long id, TItem value, long size) {
        this.id = id;
        this.value = value;
        this.size = size;
      }

    }

    private ConcurrentDictionary<TKey, CacheItem<TValue>> _items = new ConcurrentDictionary<TKey, CacheItem<TValue>>();
    private readonly Func<TKey, TValue> _valueFactory;
    private readonly int _maxItems;
    private readonly long _maxSize;
    private long _currentInitId = long.MinValue;
    private long _currentAccessId = long.MinValue;
    private long _lastKnownSize;

    private readonly Action _garbageCollection;
    private readonly Func<TKey, CacheItem<TValue>> _creatorCall;
    private readonly Func<TKey, TValue> _valueGetter;
    private readonly Func<bool> _gcDetector;
    private readonly Timer _backgroundTasks;

    public _Cache(Func<TKey, TValue> valueFactory, int maxItems, long maxSize, _CacheReplacementPolicy policy, bool enforceGarbageCollectionUponCreation, Func<TValue, bool> precheckValue) {
      this.Policy = policy;
      var needAccessTracking = false;
      var needSizeTracking = maxSize > 0;
      switch (policy) {
        case _CacheReplacementPolicy.Random:
          this._garbageCollection = this._RemoveRandom;
          break;
        case _CacheReplacementPolicy.FirstInFirstOut:
          this._garbageCollection = this._RemoveFIFO;
          break;
        case _CacheReplacementPolicy.LargeValuesFirst:
          this._garbageCollection = this._RemoveLargeValuesFirst;
          needSizeTracking = true;
          break;
        case _CacheReplacementPolicy.LastInFirstOut:
          this._garbageCollection = this._RemoveLIFO;
          break;
        case _CacheReplacementPolicy.SmallValuesFirst:
          this._garbageCollection = this._RemoveSmallValuesFirst;
          needSizeTracking = true;
          break;
        case _CacheReplacementPolicy.MostRecentlyUsed:
          this._garbageCollection = this._RemoveMostRecentlyUsed;
          needAccessTracking = true;
          break;
        case _CacheReplacementPolicy.LeastRecentlyUsed:
          this._garbageCollection = this._RemoveLeastRecentlyUsed;
          needAccessTracking = true;
          break;
        case _CacheReplacementPolicy.NotNeeded:
          this._garbageCollection = this._RemoveNone;
          maxItems = 0;
          maxSize = 0;
          needSizeTracking = false;
          break;
        default:
          throw new NotSupportedException($"Unknown policy: {this.Policy}");
      }

      this._valueFactory = valueFactory;
      this._maxItems = maxItems;
      this._maxSize = maxSize;

      this._creatorCall = enforceGarbageCollectionUponCreation
          ? needSizeTracking
            ? (Func<TKey, CacheItem<TValue>>)this._CreateValueWithStatsAndGarbageCollection
            : (Func<TKey, CacheItem<TValue>>)this._CreateValueWithGarbageCollection
          : needSizeTracking
            ? (Func<TKey, CacheItem<TValue>>)this._CreateValueWithStats
            : (Func<TKey, CacheItem<TValue>>)this._CreateValueWithoutStats
        ;

      this._valueGetter = precheckValue == null
          ? needAccessTracking
            ? (Func<TKey, TValue>)this._GetValueForKeyUncheckedWithAccessNotification
            : (Func<TKey, TValue>)this._GetValueForKeyUncheckedWithoutAccessNotification
          : needAccessTracking
            ? (Func<TKey, TValue>)(k => this._GetValueForKeyCheckedWithAccessNotification(k, precheckValue))
            : (Func<TKey, TValue>)(k => this._GetValueForKeyCheckedWithoutAccessNotification(k, precheckValue))
        ;

      this._gcDetector =
        maxItems > 0
        ? maxSize > 0
          ? (Func<bool>)this._IsAnyLimitReached
          : (Func<bool>)this._IsMaxItemsLimitReached
        : maxSize > 0
          ? (Func<bool>)this._IsMaxSizeLimitReached
          : (Func<bool>)this._IsLimitWhatever
        ;

      TimerCallback thread;
      if (enforceGarbageCollectionUponCreation)
        if (precheckValue == null)
          thread = this._ThreadRecalculateStatistics;
        else
          thread = this._ThreadRemoveAndRecalculate;
      else {
        if (precheckValue == null)
          thread = this._ThreadRecalculateAndCollect;
        else
          thread = this._ThreadRemoveRecalculateAndCollect;
      }

      this._backgroundTasks = new Timer(thread, precheckValue, TimeSpan.FromSeconds(60), TimeSpan.FromSeconds(60));
    }

    private bool _NeedsGarbageCollection => this._gcDetector();

    #region gc detect

    private bool _IsLimitWhatever() => false;
    private bool _IsMaxItemsLimitReached() => this._items.Count > 0 && (this._items.Count >= this._maxItems);
    private bool _IsMaxSizeLimitReached() => this._items.Count > 0 && (Interlocked.Read(ref this._lastKnownSize) >= this._maxSize);
    private bool _IsAnyLimitReached() => this._items.Count > 0 && ((Interlocked.Read(ref this._lastKnownSize) >= this._maxSize) || (this._items.Count >= this._maxItems));

    #endregion

    #region possible background tasks

    private void _ThreadRecalculateStatistics(object _) {
      this._RefreshStatistics();
    }

    private void _ThreadRecalculateAndCollect(object _) {
      this._RefreshStatistics();
      this._DoGarbageCollection();
    }

    private void _ThreadRemoveAndRecalculate(object precheckValue) {
      this._RemoveEndOfLifeValues((Func<TValue, bool>)precheckValue);
      this._RefreshStatistics();
    }

    private void _ThreadRemoveRecalculateAndCollect(object precheckValue) {
      this._RemoveEndOfLifeValues((Func<TValue, bool>)precheckValue);
      this._RefreshStatistics();
      this._DoGarbageCollection();
    }

    #endregion

    #region messing with cache items

    private CacheItem<TValue> _GetCacheForKey(TKey key) => this._items.GetOrAdd(key, this._creatorCall);
    private CacheItem<TValue> _GetCacheForKeyChecked(TKey key, Func<TValue, bool> checker) {
      do {
        var result = this._GetCacheForKey(key);
        if (checker(result.value))
          return result;

        // value no longer valid - remove
        this._RemoveKey(key);
      } while (true);
    }

    private void _RemoveKey(TKey key) {
      CacheItem<TValue> item;
      if (!this._items.TryRemove(key, out item))
        return;

      Interlocked.Add(ref this._lastKnownSize, -item.size);
      (item.value as IDisposable)?.Dispose();
    }

    #endregion

    #region how to get values from cache

    private TValue _GetValueForKeyUncheckedWithoutAccessNotification(TKey key) => this._GetCacheForKey(key).value;

    private TValue _GetValueForKeyUncheckedWithAccessNotification(TKey key) {
      var result = this._GetCacheForKey(key);
      var accessId = Interlocked.Increment(ref this._currentAccessId);
      result.accessId = accessId;
      return result.value;
    }

    private TValue _GetValueForKeyCheckedWithoutAccessNotification(TKey key, Func<TValue, bool> checker)
      => this._GetCacheForKeyChecked(key, checker).value
      ;

    private TValue _GetValueForKeyCheckedWithAccessNotification(TKey key, Func<TValue, bool> checker) {
      var result = this._GetCacheForKeyChecked(key, checker);
      var accessId = Interlocked.Increment(ref this._currentAccessId);
      result.accessId = accessId;
      return result.value;
    }

    private CacheItem<TValue> _CreateValueWithStatsAndGarbageCollection(TKey key) {
      this._DoGarbageCollection();
      return this._CreateValueWithStats(key);
    }
    
    private CacheItem<TValue> _CreateValueWithGarbageCollection(TKey key) {
      this._DoGarbageCollection();
      return this._CreateValueWithoutStats(key);
    }

    private CacheItem<TValue> _CreateValueWithStats(TKey key) {
      var result = this._CreateValueWithoutStats(key);
      var valueSize = _GetUsedMemory(result.value);
      Interlocked.Add(ref this._lastKnownSize, valueSize);
      Interlocked.Exchange(ref result.size, valueSize);
      return result;
    }

    private CacheItem<TValue> _CreateValueWithoutStats(TKey key) {
      var value = this._valueFactory(key);
      var index = Interlocked.Increment(ref this._currentInitId);
      return new CacheItem<TValue>(index, value, 0);
    }

    #endregion

    #region garbage collection

    private void _DoGarbageCollection() {
      if (!this._NeedsGarbageCollection)
        return;

      this._garbageCollection();
    }

    private void _RemoveEndOfLifeValues(Func<TValue, bool> func) {
      foreach (var kvp in this._items)
        if (!func(kvp.Value.value))
          this._RemoveKey(kvp.Key);
    }

    #endregion

    #region removal strategies

    private void _RemoveNone() { }

    private void _RemoveRandom() {
      var random = new Random();
      var keys = new TKey[0];
      var index = 0;
      while (this._NeedsGarbageCollection) {

        if (index >= keys.Length) {
          keys = this._items.Keys.ToArray();

          // Fisher-Yates-Shuffle
          for (var i = 0; i < keys.Length; ++i) {
            var j = random.Next(i + 1);
            if (j == i)
              continue;

            var temp = keys[i];
            keys[i] = keys[j];
            keys[j] = temp;
          }

          index = 0;
        }

        this._RemoveKey(keys[index++]);
      }
    }

    private void _RemoveFIFO() {
      var keys = new TKey[0];
      var index = 0;
      while (this._NeedsGarbageCollection) {
        if (index >= keys.Length) {
          keys = this._items.OrderBy(i => i.Value.id).Select(i => i.Key).ToArray();
          index = 0;
        }

        this._RemoveKey(keys[index++]);
      }
    }

    private void _RemoveLIFO() {
      var keys = new TKey[0];
      var index = 0;
      while (this._NeedsGarbageCollection) {
        if (index >= keys.Length) {
          keys = this._items.OrderByDescending(i => i.Value.id).Select(i => i.Key).ToArray();
          index = 0;
        }

        this._RemoveKey(keys[index++]);
      }
    }

    private void _RemoveLeastRecentlyUsed() {
      var keys = new TKey[0];
      var index = 0;
      while (this._NeedsGarbageCollection) {
        if (index >= keys.Length) {
          keys = this._items.OrderBy(i => i.Value.accessId).Select(i => i.Key).ToArray();
          index = 0;
        }

        this._RemoveKey(keys[index++]);
      }
    }

    private void _RemoveMostRecentlyUsed() {
      var keys = new TKey[0];
      var index = 0;
      while (this._NeedsGarbageCollection) {
        if (index >= keys.Length) {
          keys = this._items.OrderByDescending(i => i.Value.accessId).Select(i => i.Key).ToArray();
          index = 0;
        }

        this._RemoveKey(keys[index++]);
      }
    }

    private void _RemoveSmallValuesFirst() {
      var keys = new TKey[0];
      var index = 0;
      while (this._NeedsGarbageCollection) {
        if (index >= keys.Length) {
          keys = this._items.OrderBy(i => i.Value.size).Select(i => i.Key).ToArray();
          index = 0;
        }

        this._RemoveKey(keys[index++]);
      }
    }

    private void _RemoveLargeValuesFirst() {
      var keys = new TKey[0];
      var index = 0;
      while (this._NeedsGarbageCollection) {
        if (index >= keys.Length) {
          keys = this._items.OrderByDescending(i => i.Value.size).Select(i => i.Key).ToArray();
          index = 0;
        }

        this._RemoveKey(keys[index++]);
      }
    }

    #endregion

    private void _RefreshStatistics() {

      var oldSize = Interlocked.Read(ref this._lastKnownSize);

      var lowestId = (long?)null;
      var size = 0L;
      foreach (var item in this._items.Values) {
        var usedMemory = _GetUsedMemory(item.value);
        Interlocked.Exchange(ref item.size, usedMemory);
        size += item.size;

        if (lowestId == null)
          lowestId = item.id;
        else if (item.id < lowestId)
          lowestId = item.id;
      }

      var newSize = Interlocked.Read(ref this._lastKnownSize);
      Interlocked.Exchange(ref this._lastKnownSize, size + (newSize - oldSize));
    }

    #region calculate object size

    private static long _GetUsedMemory<TType>(TType value) => _GetMemorySize(value, typeof(TType).IsValueType);

    private static long _GetMemorySize(object value, bool withoutBoxing, HashSet<object> visitedRefs = null) {
      var pointerSize = IntPtr.Size;

      if (ReferenceEquals(null, value))
        return pointerSize;

      var type = value.GetType();
      if (type.IsPrimitive)
        return Marshal.SizeOf(type) + (withoutBoxing ? 0 : pointerSize);

      if (visitedRefs == null)
        visitedRefs = new HashSet<object>();

      if (type.IsArray) {
        if (visitedRefs.Contains(value))
          return pointerSize;

        var valueElements = type.GetElementType().IsValueType;
        return pointerSize + sizeof(int) + ((IEnumerable)value).Cast<object>().Sum(v => _GetMemorySize(v, valueElements, visitedRefs));
      }

      var fields = type.GetFields(BindingFlags.FlattenHierarchy | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
      long sum = withoutBoxing ? 0 : pointerSize;
      foreach (var field in fields) {
        var fieldValue = field.GetValue(value);
        if (visitedRefs.Contains(fieldValue))
          sum += pointerSize;
        else {
          visitedRefs.Add(fieldValue);
          sum += _GetMemorySize(fieldValue, field.FieldType.IsValueType, visitedRefs);
        }
      }

      return sum;
    }

    #endregion

    #region Implementation of IDisposable

    private int _isDisposed;

    public void Dispose() {
      if (Interlocked.CompareExchange(ref this._isDisposed, 1, 0) != 0)
        return;

      this._backgroundTasks.Dispose();
      this.Clear();
      GC.SuppressFinalize(this);
    }

    ~_Cache() {
      this.Dispose();
    }

    #endregion

    #region Implementation of ICache

    public TValue this[TKey key] => this._valueGetter(key);
    public _CacheReplacementPolicy Policy { get; }
    public int Count => this._items.Count;
    public long MemorySize => Interlocked.Read(ref this._lastKnownSize);

    public void Clear() {
      Interlocked.Exchange(ref this._lastKnownSize, 0);
      Interlocked.Exchange(ref this._currentAccessId, long.MinValue);
      Interlocked.Exchange(ref this._currentInitId, long.MinValue);
      var oldCache = Interlocked.Exchange(ref this._items, new ConcurrentDictionary<TKey, CacheItem<TValue>>());
      foreach (var item in oldCache.Values)
        (item.value as IDisposable)?.Dispose();
    }

    #endregion
  }
}