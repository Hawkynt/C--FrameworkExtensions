<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#region (c)2010-2042 Hawkynt
/*
  This file is part of Hawkynt's .NET Framework extensions.

    Hawkynt's .NET Framework extensions are free software: 
    you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Hawkynt's .NET Framework extensions is distributed in the hope that 
    it will be useful, but WITHOUT ANY WARRANTY; without even the implied 
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
    the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Hawkynt's .NET Framework extensions.  
    If not, see <http://www.gnu.org/licenses/>.
*/
#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */

using System.Diagnostics;
using System.Reflection;
using System.Reflection.Emit;

// ReSharper disable PartialTypeWithSinglePart
// ReSharper disable UnusedMember.Global
// ReSharper disable MemberCanBePrivate.Global
// ReSharper disable CompareOfFloatsByEqualityOperator
namespace System.Threading {

  internal static partial class InterlockedEx {

    #region nested types

    /// <summary>
    /// Used to force the compiler to chose a method-overload with a class constraint on a generic type.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    // ReSharper disable once UnusedTypeParameter
    public abstract class ClassForcingTag<T> where T : class { private ClassForcingTag() { } }
    /// <summary>
    /// Used to force the compiler to chose a method-overload with a struct constraint on a generic type.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    // ReSharper disable once UnusedTypeParameter
    public abstract class StructForcingTag<T> where T : struct { private StructForcingTag() { } }

    private static class HelperForEnum<TValue> {
      public delegate TValue CompareExchangeDelegateType(ref TValue source, TValue value, TValue comparand);
      public delegate TValue ExchangeDelegateType(ref TValue source, TValue value);
      public delegate bool HasFlagDelegateType(ref TValue source, TValue value);
      public delegate TValue SetFlagDelegateType(ref TValue source, TValue value);
      public delegate TValue ClearFlagDelegateType(ref TValue source, TValue value);
      public delegate TValue ToggleFlagDelegateType(ref TValue source, TValue value);
      public static readonly CompareExchangeDelegateType CompareExchangeImplementation = _CreateCompareExchangeImplementation();
      public static readonly ExchangeDelegateType ExchangeImplementation = _CreateExchangeImplementation();
      public static readonly HasFlagDelegateType HasFlagImplementation = _CreateHasFlagImplementation();
      public static readonly SetFlagDelegateType SetFlagImplementation = _CreateSetFlagImplementation();
      public static readonly ClearFlagDelegateType ClearFlagImplementation = _CreateClearFlagImplementation();
      public static readonly ToggleFlagDelegateType ToggleFlagImplementation = _CreateToggleFlagImplementation();

      // ReSharper disable once StaticMemberInGenericType
      private static Type _originalType;
      // ReSharper disable once StaticMemberInGenericType
      private static Type _signedType;
      // ReSharper disable once StaticMemberInGenericType
      private static MethodInfo _usedMethodForCompareExchange;

      private static void _InitIfNeeded() {
        if(_originalType != null)
          return;

        var originalType = typeof(TValue);
        if (!originalType.IsEnum)
          throw new ArgumentException("Must be enum!");

        var underlyingType = Enum.GetUnderlyingType(originalType);
        var signedType = 
          underlyingType == typeof(int) || underlyingType == typeof(uint) ? typeof(int)
          : underlyingType == typeof(long) || underlyingType == typeof(ulong) ? typeof(long)
          : null
          ;

        if (signedType == null)
          throw new NotSupportedException("Enum type must be int, uint, long or ulong!");

        _originalType = originalType;
        _signedType = signedType;
        _usedMethodForCompareExchange = typeof(Interlocked).GetMethod(
          "CompareExchange",
          BindingFlags.Static | BindingFlags.Public,
          null,
          new[] { signedType.MakeByRefType(), signedType, signedType },
          null
        );
      }
      
      private static CompareExchangeDelegateType _CreateCompareExchangeImplementation() {
        _InitIfNeeded();
        var dynamicMethod = new DynamicMethod(string.Empty, _originalType, new[] { _originalType.MakeByRefType(), _originalType, _originalType }, true);
        var ilGenerator = dynamicMethod.GetILGenerator();
        ilGenerator.Emit(OpCodes.Ldarg_0);
        ilGenerator.Emit(OpCodes.Ldarg_1);
        ilGenerator.Emit(OpCodes.Ldarg_2);
        ilGenerator.Emit(OpCodes.Call, _usedMethodForCompareExchange);
        ilGenerator.Emit(OpCodes.Ret);
        return (CompareExchangeDelegateType)dynamicMethod.CreateDelegate(typeof(CompareExchangeDelegateType));
      }

      private static ExchangeDelegateType _CreateExchangeImplementation() {
        _InitIfNeeded();
        var dynamicMethod = new DynamicMethod(string.Empty, _originalType, new[] { _originalType.MakeByRefType(), _originalType }, true);
        var ilGenerator = dynamicMethod.GetILGenerator();
        ilGenerator.Emit(OpCodes.Ldarg_0);
        ilGenerator.Emit(OpCodes.Ldarg_1);
        ilGenerator.Emit(OpCodes.Call, typeof(Interlocked).GetMethod(
          "Exchange",
          BindingFlags.Static | BindingFlags.Public,
          null,
          new[] { _signedType.MakeByRefType(), _signedType },
          null
        ));
        ilGenerator.Emit(OpCodes.Ret);
        return (ExchangeDelegateType)dynamicMethod.CreateDelegate(typeof(ExchangeDelegateType));
      }

      private static HasFlagDelegateType _CreateHasFlagImplementation() {
        _InitIfNeeded();
        var dynamicMethod = new DynamicMethod(string.Empty, typeof(bool), new[] { _originalType.MakeByRefType(), _originalType }, true);
        var ilGenerator = dynamicMethod.GetILGenerator();
        
        ilGenerator.Emit(OpCodes.Ldarg_1); /* 2nd argument for ceq */               /* Stack: arg1 */
        ilGenerator.Emit(OpCodes.Dup);     /* 2nd argument for and */               /* Stack: arg1, arg1 */
        ilGenerator.Emit(OpCodes.Ldarg_0);                                          /* Stack: arg1, arg1, arg0 */
        ilGenerator.Emit(OpCodes.Ldc_I4_0);                                         /* Stack: arg1, arg1, arg0, 0 */
        ilGenerator.Emit(OpCodes.Dup);                                              /* Stack: arg1, arg1, arg0, 0, 0 */
        ilGenerator.Emit(OpCodes.Call, _usedMethodForCompareExchange);              /* Stack: arg1, arg1, value */
        ilGenerator.Emit(OpCodes.And);                                              /* Stack: arg1, and */
        ilGenerator.Emit(OpCodes.Ceq);                                              /* Stack: result */
        ilGenerator.Emit(OpCodes.Ret);
        return (HasFlagDelegateType)dynamicMethod.CreateDelegate(typeof(HasFlagDelegateType));
      }

      private static SetFlagDelegateType _CreateSetFlagImplementation(){
        _InitIfNeeded();
        var dynamicMethod = new DynamicMethod(string.Empty, _originalType, new[] { _originalType.MakeByRefType(), _originalType }, true);
        var ilGenerator = dynamicMethod.GetILGenerator();
        var loopLabel = ilGenerator.DefineLabel();
        var oldValue = ilGenerator.DeclareLocal(_signedType);
        var newValue = ilGenerator.DeclareLocal(_signedType);

        ilGenerator.MarkLabel(loopLabel);                                           /* Stack: */
        
        // read value
        ilGenerator.Emit(OpCodes.Ldarg_0); /* 1st argument for call */              /* Stack: arg0 */
        ilGenerator.Emit(OpCodes.Ldarg_1); /* 2nd argument for or */                /* Stack: arg0, arg1 */
        
        ilGenerator.Emit(OpCodes.Ldarg_0);                                          /* Stack: arg0, arg1, arg0 */
        ilGenerator.Emit(OpCodes.Ldc_I4_0);                                         /* Stack: arg0, arg1, arg0, 0 */
        ilGenerator.Emit(OpCodes.Dup);                                              /* Stack: arg0, arg1, arg0, 0, 0 */
        ilGenerator.Emit(OpCodes.Call, _usedMethodForCompareExchange);              /* Stack: arg0, arg1, oldValue */
        
        // write value to variable
        ilGenerator.Emit(OpCodes.Dup);                                              /* Stack: arg0, arg1, oldValue, oldValue */
        ilGenerator.Emit(OpCodes.Stloc, oldValue);                                  /* Stack: arg0, arg1, oldValue */

        // set flags
        ilGenerator.Emit(OpCodes.Or);                                               /* Stack: arg0, newValue */
        ilGenerator.Emit(OpCodes.Dup); /* 2nd argument for call */                  /* Stack: arg0, newValue, newValue */
        ilGenerator.Emit(OpCodes.Stloc, newValue);                                  /* Stack: arg0, newValue */
        
        // compare exchange
        ilGenerator.Emit(OpCodes.Ldloc, oldValue);                                  /* Stack: arg0, newValue, oldValue */
        ilGenerator.Emit(OpCodes.Call, _usedMethodForCompareExchange);              /* Stack: result */
        
        // if changed, loop
        ilGenerator.Emit(OpCodes.Ldloc, oldValue);                                  /* Stack: result, oldValue */
        ilGenerator.Emit(OpCodes.Ceq);                                              /* Stack: success */
        ilGenerator.Emit(OpCodes.Brfalse_S, loopLabel);                             /* Stack: */

        // return changed value
        ilGenerator.Emit(OpCodes.Ldloc, newValue);                                  /* Stack: newValue */
        ilGenerator.Emit(OpCodes.Ret);
        return (SetFlagDelegateType)dynamicMethod.CreateDelegate(typeof(SetFlagDelegateType));
      }

      private static ClearFlagDelegateType _CreateClearFlagImplementation(){
        _InitIfNeeded();
        var dynamicMethod = new DynamicMethod(string.Empty, _originalType, new[] { _originalType.MakeByRefType(), _originalType }, true);
        var ilGenerator = dynamicMethod.GetILGenerator();
        var loopLabel = ilGenerator.DefineLabel();
        var maskValue = ilGenerator.DeclareLocal(_signedType);
        var oldValue = ilGenerator.DeclareLocal(_signedType);
        var newValue = ilGenerator.DeclareLocal(_signedType);

        // create mask
        ilGenerator.Emit(OpCodes.Ldc_I4_M1);
        if (_signedType == typeof(long))
          ilGenerator.Emit(OpCodes.Conv_I8);

        ilGenerator.Emit(OpCodes.Ldarg_1);
        ilGenerator.Emit(OpCodes.Xor);
        ilGenerator.Emit(OpCodes.Stloc, maskValue);

        ilGenerator.MarkLabel(loopLabel);
        
        // read value
        ilGenerator.Emit(OpCodes.Ldarg_0);
        ilGenerator.Emit(OpCodes.Ldc_I4_0);
        ilGenerator.Emit(OpCodes.Dup);
        ilGenerator.Emit(OpCodes.Call, _usedMethodForCompareExchange);
        
        // write value to variable
        ilGenerator.Emit(OpCodes.Dup);
        ilGenerator.Emit(OpCodes.Stloc, oldValue);

        // set flags
        ilGenerator.Emit(OpCodes.Ldloc, maskValue);
        ilGenerator.Emit(OpCodes.And);
        ilGenerator.Emit(OpCodes.Stloc, newValue);
        
        // compare exchange
        ilGenerator.Emit(OpCodes.Ldarg_0);
        ilGenerator.Emit(OpCodes.Ldloc, newValue);
        ilGenerator.Emit(OpCodes.Ldloc, oldValue);
        ilGenerator.Emit(OpCodes.Call, _usedMethodForCompareExchange);
        
        // if changed, loop
        ilGenerator.Emit(OpCodes.Ldloc, oldValue);
        ilGenerator.Emit(OpCodes.Ceq);
        ilGenerator.Emit(OpCodes.Brfalse_S, loopLabel);

        // return changed value
        ilGenerator.Emit(OpCodes.Ldloc, newValue);
        ilGenerator.Emit(OpCodes.Ret);
        return (ClearFlagDelegateType)dynamicMethod.CreateDelegate(typeof(ClearFlagDelegateType));
      }

      private static ToggleFlagDelegateType _CreateToggleFlagImplementation(){
        _InitIfNeeded();
        var dynamicMethod = new DynamicMethod(string.Empty, _originalType, new[] { _originalType.MakeByRefType(), _originalType }, true);
        var ilGenerator = dynamicMethod.GetILGenerator();
        var loopLabel = ilGenerator.DefineLabel();
        var oldValue = ilGenerator.DeclareLocal(_signedType);
        var newValue = ilGenerator.DeclareLocal(_signedType);

        ilGenerator.MarkLabel(loopLabel);
        
        // read value
        ilGenerator.Emit(OpCodes.Ldarg_0);
        ilGenerator.Emit(OpCodes.Ldc_I4_0);
        ilGenerator.Emit(OpCodes.Dup);
        ilGenerator.Emit(OpCodes.Call, _usedMethodForCompareExchange);
        
        // write value to variable
        ilGenerator.Emit(OpCodes.Dup);
        ilGenerator.Emit(OpCodes.Stloc, oldValue);

        // toggle flags
        ilGenerator.Emit(OpCodes.Ldarg_1);
        ilGenerator.Emit(OpCodes.Xor);
        ilGenerator.Emit(OpCodes.Stloc, newValue);
        
        // compare exchange
        ilGenerator.Emit(OpCodes.Ldarg_0);
        ilGenerator.Emit(OpCodes.Ldloc, newValue);
        ilGenerator.Emit(OpCodes.Ldloc, oldValue);
        ilGenerator.Emit(OpCodes.Call, _usedMethodForCompareExchange);
        
        // if changed, loop
        ilGenerator.Emit(OpCodes.Ldloc, oldValue);
        ilGenerator.Emit(OpCodes.Ceq);
        ilGenerator.Emit(OpCodes.Brfalse_S, loopLabel);

        // return changed value
        ilGenerator.Emit(OpCodes.Ldloc, newValue);
        ilGenerator.Emit(OpCodes.Ret);
        return (ToggleFlagDelegateType)dynamicMethod.CreateDelegate(typeof(ToggleFlagDelegateType));
      }

    }
            
    #endregion

    // ReSharper disable once UnusedParameter.Global
    public static TValue CompareExchange<TValue>(ref TValue source, TValue value, TValue comparand, StructForcingTag<TValue> _ = null) where TValue:struct 
      => HelperForEnum<TValue>.CompareExchangeImplementation(ref source, value, comparand)
      ;

    // ReSharper disable once UnusedParameter.Global
    public static TValue Exchange<TValue>(ref TValue source, TValue value, StructForcingTag<TValue> _ = null) where TValue:struct 
      => HelperForEnum<TValue>.ExchangeImplementation(ref source, value)
      ;

    // ReSharper disable once UnusedParameter.Global
    public static TValue Read<TValue>(ref TValue source, StructForcingTag<TValue> _ = null) where TValue:struct 
      => HelperForEnum<TValue>.CompareExchangeImplementation(ref source, default(TValue), default(TValue))
      ;

    // ReSharper disable once UnusedParameter.Global
    public static bool HasFlag<TValue>(ref TValue source, TValue value, StructForcingTag<TValue> _ = null) where TValue:struct 
      => HelperForEnum<TValue>.HasFlagImplementation(ref source, value)
      ;

    // ReSharper disable once UnusedParameter.Global
    public static TValue SetFlag<TValue>(ref TValue source, TValue value, StructForcingTag<TValue> _ = null) where TValue:struct 
      => HelperForEnum<TValue>.SetFlagImplementation(ref source, value)
      ;

    // ReSharper disable once UnusedParameter.Global
    public static TValue ClearFlag<TValue>(ref TValue source, TValue value, StructForcingTag<TValue> _ = null) where TValue:struct 
      => HelperForEnum<TValue>.ClearFlagImplementation(ref source, value)
      ;

    // ReSharper disable once UnusedParameter.Global
    public static TValue ToggleFlag<TValue>(ref TValue source, TValue value, StructForcingTag<TValue> _ = null) where TValue:struct 
      => HelperForEnum<TValue>.ToggleFlagImplementation(ref source, value)
      ;

    // ReSharper disable once UnusedParameter.Global
    public static TValue CompareExchange<TValue>(ref TValue source, TValue value, TValue comparand, ClassForcingTag<TValue> _ = null) where TValue:class 
      => Interlocked.CompareExchange(ref source, value, comparand)
      ;

    // ReSharper disable once UnusedParameter.Global
    public static TValue Exchange<TValue>(ref TValue source, TValue value, ClassForcingTag<TValue> _ = null) where TValue:class
      => Interlocked.Exchange(ref source, value)
      ;
      
    <#foreach(var type in new[]{"int","long","float","double","uint","ulong"}){
        var isIntegerType=type=="int"||type=="long"||type=="uint"||type=="ulong";
        var isUnsupported=type=="uint"||type=="ulong";
        var isUnsigned=type=="uint"||type=="ulong";
        var unsignedType=isUnsigned?type:"u"+type;
        var signedType=isUnsigned?type.Substring(1):type;
        var supportsNativeIncrementDecrement=type=="int"||type=="long";
        var supportsNativeAdd=type=="int"||type=="long";
        var supportsNativeExchange=type=="int"||type=="long"||type=="float"||type=="double";
        var helperClassName="HelperFor"+type[0].ToString().ToUpperInvariant()+type.Substring(1);
        var bitsUsed=type=="uint"||type=="int"||type=="float"?32:64;
    #>

<#if(isUnsupported){#>
    private static class <#=helperClassName#> {
      public delegate <#=type#> CompareExchangeDelegateType(ref <#=type#> source, <#=type#> value, <#=type#> comparand);
      public delegate <#=type#> ExchangeDelegateType(ref <#=type#> source, <#=type#> value);
      public static readonly CompareExchangeDelegateType CompareExchangeImplementation = _CreateCompareExchangeImplementation();
      public static readonly ExchangeDelegateType ExchangeImplementation = _CreateExchangeImplementation();
      
      private static CompareExchangeDelegateType _CreateCompareExchangeImplementation() {
        var originalType = typeof(<#=type#>);
        var signedType = typeof(<#=signedType#>);
        var dynamicMethod = new DynamicMethod(string.Empty, originalType, new[] { originalType.MakeByRefType(), originalType, originalType });
        var ilGenerator = dynamicMethod.GetILGenerator();
        ilGenerator.Emit(OpCodes.Ldarg_0);
        ilGenerator.Emit(OpCodes.Ldarg_1);
        ilGenerator.Emit(OpCodes.Ldarg_2);
        ilGenerator.Emit(
          OpCodes.Call,
          typeof(Interlocked).GetMethod(
            "CompareExchange",
            BindingFlags.Static | BindingFlags.Public,
            null,
            new[] { signedType.MakeByRefType(), signedType, signedType },
            null
          )
        );
        ilGenerator.Emit(OpCodes.Ret);
        return (CompareExchangeDelegateType)dynamicMethod.CreateDelegate(typeof(CompareExchangeDelegateType));
      }

      private static ExchangeDelegateType _CreateExchangeImplementation() {
        var originalType = typeof(<#=type#>);
        var signedType = typeof(<#=signedType#>);
        var dynamicMethod = new DynamicMethod(string.Empty, originalType, new[] { originalType.MakeByRefType(), originalType });
        var ilGenerator = dynamicMethod.GetILGenerator();
        ilGenerator.Emit(OpCodes.Ldarg_0);
        ilGenerator.Emit(OpCodes.Ldarg_1);
        ilGenerator.Emit(
          OpCodes.Call,
          typeof(Interlocked).GetMethod(
            "Exchange",
            BindingFlags.Static | BindingFlags.Public,
            null,
            new[] { signedType.MakeByRefType(), signedType },
            null
          )
        );
        ilGenerator.Emit(OpCodes.Ret);
        return (ExchangeDelegateType)dynamicMethod.CreateDelegate(typeof(ExchangeDelegateType));
      }
    }
<#}#>

#if NET45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    [DebuggerStepThrough]
<#if(isUnsupported){#>
    public static <#=type#> CompareExchange(ref <#=type#> source, <#=type#> value, <#=type#> comparand) => <#=helperClassName#>.CompareExchangeImplementation(ref source, value, comparand);
<#}else{#>
    public static <#=type#> CompareExchange(ref <#=type#> source, <#=type#> value, <#=type#> comparand) => Interlocked.CompareExchange(ref source, value, comparand);
<#}#>

#if NET45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    [DebuggerStepThrough]
<#if(isUnsupported){#>
    public static <#=type#> Read(ref <#=type#> source) => <#=helperClassName#>.CompareExchangeImplementation(ref source, 0, 0);
<#}else{#>
    public static <#=type#> Read(ref <#=type#> source) => Interlocked.CompareExchange(ref source, 0, 0);
<#}#>

<#if(supportsNativeExchange){#>
#if NET45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    [DebuggerStepThrough]
    public static <#=type#> Exchange(ref <#=type#> source, <#=type#> value) => Interlocked.Exchange(ref source, value);
<#}else{#>
    public static <#=type#> Exchange(ref <#=type#> source, <#=type#> value) => <#=helperClassName#>.ExchangeImplementation(ref source, value);
<#}#>

<#if(supportsNativeIncrementDecrement){#>
#if NET45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    [DebuggerStepThrough]
    public static <#=type#> Increment(ref <#=type#> source) => Interlocked.Increment(ref source);

#if NET45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    [DebuggerStepThrough]
    public static <#=type#> Decrement(ref <#=type#> source) => Interlocked.Decrement(ref source);
<#}else{#>
#if NET45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    [DebuggerStepThrough]
    public static <#=type#> Increment(ref <#=type#> source) => Add(ref source, 1);

#if NET45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    [DebuggerStepThrough]
    public static <#=type#> Decrement(ref <#=type#> source) => Substract(ref source, 1);
<#}#>

<#if(supportsNativeAdd){#>
#if NET45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    [DebuggerStepThrough]
    public static <#=type#> Add(ref <#=type#> source, <#=type#> value) => Interlocked.Add(ref source, value);

#if NET45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    [DebuggerStepThrough]
    public static <#=type#> Substract(ref <#=type#> source, <#=type#> value) => Interlocked.Add(ref source, -value);
<#}else{#>
    public static <#=type#> Add(ref <#=type#> source, <#=type#> value) {
      while (true) {
        var current = Read(ref source);
        var next = current + value;
        if (CompareExchange(ref source, next, current) == current)
          return next;
      }
    }

    public static <#=type#> Substract(ref <#=type#> source, <#=type#> value) {
      while (true) {
        var current = Read(ref source);
        var next = current - value;
        if (CompareExchange(ref source, next, current) == current)
          return next;
      }
    }
<#}#>

    public static <#=type#> Multiply(ref <#=type#> source, <#=type#> value) {
      while (true) {
        var current = Read(ref source);
        var next = current * value;
        if (CompareExchange(ref source, next, current) == current)
          return next;
      }
    }

    public static <#=type#> Divide(ref <#=type#> source, <#=type#> value) {
      while (true) {
        var current = Read(ref source);
        var next = current / value;
        if (CompareExchange(ref source, next, current) == current)
          return next;
      }
    }

    public static <#=type#> Modulo(ref <#=type#> source, <#=type#> value) {
      while (true) {
        var current = Read(ref source);
        var next = current % value;
        if (CompareExchange(ref source, next, current) == current)
          return next;
      }
    }
<#if(isIntegerType){#>

    public static <#=type#> And(ref <#=type#> source, <#=type#> value) {
      while (true) {
        var current = Read(ref source);
        var next = current & value;
        if (CompareExchange(ref source, next, current) == current)
          return next;
      }
    }

    public static <#=type#> NAnd(ref <#=type#> source, <#=type#> value) {
      while (true) {
        var current = Read(ref source);
        var next = ~(current & value);
        if (CompareExchange(ref source, next, current) == current)
          return next;
      }
    }

    public static <#=type#> Or(ref <#=type#> source, <#=type#> value) {
      while (true) {
        var current = Read(ref source);
        var next = current | value;
        if (CompareExchange(ref source, next, current) == current)
          return next;
      }
    }

    public static <#=type#> NOr(ref <#=type#> source, <#=type#> value) {
      while (true) {
        var current = Read(ref source);
        var next = ~(current | value);
        if (CompareExchange(ref source, next, current) == current)
          return next;
      }
    }

    public static <#=type#> Xor(ref <#=type#> source, <#=type#> value) {
      while (true) {
        var current = Read(ref source);
        var next = current ^ value;
        if (CompareExchange(ref source, next, current) == current)
          return next;
      }
    }

    public static <#=type#> NXor(ref <#=type#> source, <#=type#> value) {
      while (true) {
        var current = Read(ref source);
        var next = ~(current ^ value);
        if (CompareExchange(ref source, next, current) == current)
          return next;
      }
    }

    public static <#=type#> Not(ref <#=type#> source) {
      while (true) {
        var current = Read(ref source);
        var next = ~current;
        if (CompareExchange(ref source, next, current) == current)
          return next;
      }
    }

<#if(isUnsigned){#>
    public static <#=type#> ShiftLeft(ref <#=type#> source, int value) {
      while (true) {
        var current = Read(ref source);
        var next = current << value;
        if (CompareExchange(ref source, next, current) == current)
          return next;
      }
    }

    public static <#=type#> ShiftRight(ref <#=type#> source, int value) {
      while (true) {
        var current = Read(ref source);
        var next = current >> value;
        if (CompareExchange(ref source, next, current) == current)
          return next;
      }
    }

    public static <#=type#> RotateLeft(ref <#=type#> source, int value) {
      while (true) {
        var current = Read(ref source);
        var next = current << value | current >> (<#=bitsUsed#> - value);
        if (CompareExchange(ref source, next, current) == current)
          return next;
      }
    }

    public static <#=type#> RotateRight(ref <#=type#> source, int value) {
      while (true) {
        var current = Read(ref source);
        var next = current >> value | current << (<#=bitsUsed#> - value);
        if (CompareExchange(ref source, next, current) == current)
          return next;
      }
    }
<#}else{#>
    public static <#=type#> ArithmeticShiftLeft(ref <#=type#> source, int value) {
      while (true) {
        var current = Read(ref source);
        var next = current << value;
        if(next < current)
          throw new OverflowException("Shifted value bits into the sign bit");

        if (CompareExchange(ref source, next, current) == current)
          return next;
      }
    }

    public static <#=type#> ArithmeticShiftRight(ref <#=type#> source, int value) {
      while (true) {
        var current = Read(ref source);
        var next = current >> value;
        if (CompareExchange(ref source, next, current) == current)
          return next;
      }
    }

    public static <#=type#> LogicalShiftLeft(ref <#=type#> source, int value) {
      while (true) {
        var current = Read(ref source);
        var next = (<#=type#>)((<#=unsignedType#>)current << value);
        if (CompareExchange(ref source, next, current) == current)
          return next;
      }
    }

    public static <#=type#> LogicalShiftRight(ref <#=type#> source, int value) {
      while (true) {
        var current = Read(ref source);
        var next = (<#=type#>)((<#=unsignedType#>)current >> value);
        if(next > current)
          throw new OverflowException("Shifted sign bit into value bits");

        if (CompareExchange(ref source, next, current) == current)
          return next;
      }
    }
<#}#>

      <#}#>
    <#}#>

  }

}