<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#region (c)2010-2020 Hawkynt
/*
  This file is part of Hawkynt's .NET Framework extensions.

    Hawkynt's .NET Framework extensions are free software: 
    you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Hawkynt's .NET Framework extensions is distributed in the hope that 
    it will be useful, but WITHOUT ANY WARRANTY; without even the implied 
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
    the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Hawkynt's .NET Framework extensions.  
    If not, see <http://www.gnu.org/licenses/>.
*/
#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */

#if NETFX_4
using System.Diagnostics.Contracts;
#endif
#if NETFX_45
using System.Runtime.CompilerServices;
#endif
using word = System.UInt16;
using dword = System.UInt32;
using qword = System.UInt64;

// ReSharper disable UnusedMember.Global
// ReSharper disable RedundantCast
// ReSharper disable CompareOfFloatsByEqualityOperator
namespace System {
  internal static class MathEx {
  <# foreach (var type in new[]{"byte","sbyte","word","short","dword","int","qword","long"}){#>

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=type#> Bits(this <#=type#> @this, byte index, byte count) {
      var result = @this >> index;
      var andMask = ((<#=type#>)1 << count) - 1;
      result = result & andMask;
      return (<#=type#>)result;
    }
    
    /// <summary>
    /// Determines whether the specified number is odd.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is odd; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsOdd(this <#=type#> @this) => (@this & 1) != 0;
    
    /// <summary>
    /// Determines whether the specified number is even.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is even; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsEven(this <#=type#> @this) => (@this & 1) == 0;

  <#}#>
  
  <# foreach (var type in new[]{"float","double","decimal"}){#>
    
    /// <summary>
    /// Determines whether the specified number is odd.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is odd; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    // ReSharper disable once CompareOfFloatsByEqualityOperator
    public static bool IsOdd(this <#=type#> @this) => (@this % 2) != 0;
    
    /// <summary>
    /// Determines whether the specified number is even.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is even; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    // ReSharper disable once CompareOfFloatsByEqualityOperator
    public static bool IsEven(this <#=type#> @this) => (@this % 2) == 0;
    
  <#}#>
  
  <# foreach (var type in new[]{"float","double","decimal"}){#>
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=type#> Floor(this <#=type#> @this) => <#=(type=="float"?"("+type+")":"")#>Math.Floor(@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=type#> Ceiling(this <#=type#> @this) => <#=(type=="float"?"("+type+")":"")#>Math.Ceiling(@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=type#> Truncate(this <#=type#> @this) => <#=(type=="float"?"("+type+")":"")#>Math.Truncate(@this);

  <#}#>
    
  <# foreach (var item in new[]{T("float",15),T("double",15),T("decimal",28)}){#>

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=item.Item1#> Round(this <#=item.Item1#> @this) => <#=(item.Item1=="float"?"("+item.Item1+")":"")#>Math.Round(@this);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=item.Item1#> Round(this <#=item.Item1#> @this, int digits) {
#if NETFX_4
      Contract.Requires(digits >= 0 && digits <= <#=item.Item2#>);
#endif
      return (<#=(item.Item1=="float"?"("+item.Item1+")":"")#>Math.Round(@this, digits));
    }

  <#}#>

  <# foreach (var type in new[]{"sbyte","short","int","long","float","double","decimal"}){#>
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=type#> Abs(this <#=type#> @this) => <#=(type=="float"?"(float)":"")#>Math.Abs(@this);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=type#> Sign(this <#=type#> @this) => <#=(type=="sbyte"||type=="short"?"("+type+")":"")#>(@this<0?-1:1);

  <#}#>
  
  <# foreach (var type in new[]{"float","double"}){#>
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsNaN(this <#=type#> @this) => <#=type#>.IsNaN(@this);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsInfinity(this <#=type#> @this) => <#=type#>.IsInfinity(@this);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsPositiveInfinity(this <#=type#> @this) => <#=type#>.IsPositiveInfinity(@this);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsNegativeInfinity(this <#=type#> @this) => <#=type#>.IsNegativeInfinity(@this);
    
  <#}#>
  
  <# foreach (var type in new[]{"sbyte","byte","short","word","int","dword","long","qword","float","double","decimal"}){#>
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=type#> Squared(this <#=type#> @this) => (<#=type#>)(@this*@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=type#> Cubed(this <#=type#> @this) => (<#=type#>)(@this*@this*@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=type#> ToThePower(this <#=type#> @this,<#=type#> exponent) => (<#=type#>)Math.Pow(<#=(type=="decimal"?"(double)":"")#>@this,<#=(type=="decimal"?"(double)":"")#>exponent);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=type#> MultipliedWith(this <#=type#> @this,<#=type#> factor) => (<#=type#>)(@this * factor);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static <#=type#> DividedBy(this <#=type#> @this,<#=type#> divisor) => (<#=type#>)(@this / divisor);

    /// <summary>
    /// Determines whether the given value is zero.
    /// </summary>
    /// <param name="this">This value.</param>
    /// <returns><c>true</c> if the value is zero; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsZero(this <#=type#> @this) => @this == 0;
    
    /// <summary>
    /// Determines whether the given value is not zero.
    /// </summary>
    /// <param name="this">This value.</param>
    /// <returns><c>true</c> if the value is not zero; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsNotZero(this <#=type#> @this) => @this != 0;

  <#}#>

  <# foreach (var method in new[]{"Sin","Sinh","Cos","Cosh","Tan","Tanh","Sqrt","Log10","Log"}){#>

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static double <#=method#>(this double @this) => Math.<#=method#>(@this);
    
  <#}#>

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static double Log(this double @this, double @base) => Math.Log(@this, @base);
        
    #region fast min/max

  <# foreach (var type in new[]{"sbyte","byte","short","word","int","dword","long","qword","float","double","decimal"}){#>

    #region <#=type#>
    /// <summary>
    /// Gets the minimum value from the given ones.
    /// </summary>
    /// <param name="values">The values.</param>
    /// <returns>The min value.</returns>
#if NETFX_4
    [Pure]
#endif
    public static <#=type#> Min(params <#=type#>[] values) {
      var length = values.Length;
      if (length == 0)
        return (default(<#=type#>));

      var result = values[0];
      for (var i = 1; i < length; ++i) 
        if (values[i] < result)
          result = values[i];

      return (result);
    }

    /// <summary>
    /// Gets the maximum value from the given ones.
    /// </summary>
    /// <param name="values">The values.</param>
    /// <returns>The max value.</returns>
#if NETFX_4
    [Pure]
#endif
    public static <#=type#> Max(params <#=type#>[] values) {
      var length = values.Length;
      if (length == 0)
        return (default(<#=type#>));

      var result = values[0];
      for (var i = 1; i < length; ++i) 
        if (values[i] > result)
          result = values[i];

      return (result);
    }

#if NETFX_4
    [Pure]
#endif
    public static bool IsIn(<#=type#> @this, <#=type#>[] values) {
      var length = values.Length;
      if (length == 0)
        return(false);

      for (var i = 0; i < length; ++i) 
        if (values[i] == @this)
          return(true);

      return(false);
    }

#if NETFX_4
    [Pure]
#endif
    public static bool IsNotIn(<#=type#> @this, <#=type#>[] values) {
      var length = values.Length;
      if (length == 0)
        return(true);

      for (var i = 0; i < length; ++i) 
        if (values[i] == @this)
          return(false);

      return(true);
    }

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsBetween(<#=type#> @this, <#=type#> lowerBoundary, <#=type#> upperBoundary) => lowerBoundary<@this && @this<upperBoundary;
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsInRange(<#=type#> @this, <#=type#> lowerBoundary, <#=type#> upperBoundary) => lowerBoundary<=@this && @this<=upperBoundary;

    #endregion

  <#}#>

    #endregion

  }
}
<#+ private static Tuple<A,B> T<A,B>(A a,B b){ return(Tuple.Create(a,b)); } #>
<#+ private static Tuple<A,B,C> T<A,B,C>(A a,B b,C c){ return(Tuple.Create(a,b,c)); } #>