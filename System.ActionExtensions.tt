<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
#region (c)2010-2020 Hawkynt
/*
  This file is part of Hawkynt's .NET Framework extensions.

    Hawkynt's .NET Framework extensions are free software: 
    you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Hawkynt's .NET Framework extensions is distributed in the hope that 
    it will be useful, but WITHOUT ANY WARRANTY; without even the implied 
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
    the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Hawkynt's .NET Framework extensions.  
    If not, see <http://www.gnu.org/licenses/>.
*/
#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Threading;

namespace System {
  internal static partial class ActionExtensions {
    
    static ActionExtensions() {
      _InitHighResTimer();
    }
    
    /// <summary>
    /// Tries to invoke the given delegate, retrying on exceptions.
    /// </summary>
    /// <param name="this">This Action.</param>
    /// <param name="repeatCount">The repeat count, until execution is aborted.</param>
    /// <param name="dueTime">The time to wait between executions; if any.</param>
    [DebuggerStepThrough]
    public static void RetryOnException(this Action @this, int repeatCount, TimeSpan? dueTime = null) {
      if (@this == null) throw new NullReferenceException();
      if (repeatCount <= 0) throw new ArgumentException("Must be > 0", nameof(repeatCount));

      while (--repeatCount >= 0) {
        try {
          @this();
          return;
        } catch (Exception) {
          if(repeatCount > 0) {
            if( dueTime != null)
              Thread.Sleep(dueTime.Value);
          } else 
            throw;
        }
      }
      
    }

    /// <summary>
    /// Tries to invoke the given delegate.
    /// </summary>
    /// <param name="this">This Action.</param>
    /// <param name="repeatCount">The repeat count, until execution is aborted.</param>
    /// <returns>
    ///   <c>true</c> on success; otherwise, <c>false</c>.
    /// </returns>
    public static bool TryInvoke(this Action @this, int repeatCount = 1) {
      Contract.Requires(@this != null);
      Contract.Requires(repeatCount > 0);

      while (--repeatCount >= 0) {
        try {
          @this();
          return (true);
        } catch (Exception) {

        }
      }
      return (false);
    }

    #region Hi-Res action timer

    private static readonly SortedList<long, Action> _SCHEDULED_ACTIONS = new SortedList<long, Action>();
    private static readonly AutoResetEvent _HIGH_RES_PULSER = new AutoResetEvent(false);
    private static readonly Stopwatch _HIRES_REFERENCE_TIMER = new Stopwatch();
    private const int _MIN_SLEEP_TIME_BEFORE_SPINNING_IN_MS = 50;
    private static readonly double _TICKS_PER_MS = Stopwatch.Frequency / 1000d;
    private static readonly long _MIN_SLEEP_TICKS = (long)(_MIN_SLEEP_TIME_BEFORE_SPINNING_IN_MS * _TICKS_PER_MS);

    private static long _GetHiResReference => _HIRES_REFERENCE_TIMER.ElapsedTicks;

    private static void _InitHighResTimer() {
      _HIRES_REFERENCE_TIMER.Start();
      new Thread(_HiresTimer_Callback) {
        Name = "Hi-Res Timer",
        IsBackground = true,
        Priority = ThreadPriority.Highest
      }.Start()
      ;
    }

    /// <summary>
    /// The high-res callback timer thread - takes elements from the queue and tries to exactly execute them when scheduled.
    /// </summary>
    private static void _HiresTimer_Callback(object _) {
      while (true) {
        KeyValuePair<long, Action> nextElement;
        lock (_SCHEDULED_ACTIONS) {
          nextElement = _SCHEDULED_ACTIONS.FirstOrDefault();

          // NOTE: if no more elements, reset reference timer to avoid overflows
          if (nextElement.Key == 0)
            _HIRES_REFERENCE_TIMER.Restart();
        }

        // when no elements, wait until notified or one hour passed
        if (nextElement.Key == 0) {
          _HIGH_RES_PULSER.WaitOne(TimeSpan.FromHours(1));
          continue;
        }

        // how many ticks remaining on nearest element?
        var remainingTicks = nextElement.Key - _GetHiResReference;

        // sleep longer if enough ticks left
        if (remainingTicks > _MIN_SLEEP_TICKS) {
          _HIGH_RES_PULSER.WaitOne(_MIN_SLEEP_TIME_BEFORE_SPINNING_IN_MS);
          continue;
        }

        // spin wait until exact moment reached, basically waste cpu cycles
        while ((remainingTicks = nextElement.Key - _GetHiResReference) > 0) {
          ;
        }

        // remove element - ignore call if already done
        lock (_SCHEDULED_ACTIONS)
          if (!_SCHEDULED_ACTIONS.Remove(nextElement.Key))
            continue;

        // call on thread pool
        nextElement.Value?.BeginInvoke(nextElement.Value.EndInvoke, null);
      }
    }


    /// <summary>
    /// Adds a new element to the wait queue.
    /// </summary>
    /// <param name="action">This action.</param>
    /// <param name="hiresTicks">The number of hires ticks to wait.</param>
    private static void _WaitTicksBefore(Action action, double hiresTicks) {
      lock (_SCHEDULED_ACTIONS)
        _SCHEDULED_ACTIONS.Add((long)(_GetHiResReference + hiresTicks), action);

      _HIGH_RES_PULSER.Set();
    }

    public static void ExecuteInHours(this Action @this, double hours) => ExecuteInMinutes(@this, hours * 60);
    public static void ExecuteInMinutes(this Action @this, double minutes) => ExecuteInSeconds(@this, minutes * 60);
    public static void ExecuteInSeconds(this Action @this, double seconds) => ExecuteInMilliseconds(@this, seconds * 1000);
    public static void ExecuteInMilliseconds(this Action @this, double milliseconds) => _WaitTicksBefore(@this, milliseconds * _TICKS_PER_MS);
    public static void ExecuteIn(this Action @this, TimeSpan timespan) => _WaitTicksBefore(@this, timespan.TotalMilliseconds * _TICKS_PER_MS);

    #endregion

    #region Async action calls
    <#for(var i=0;i<17;++i){
      var dataType=i<1?string.Empty:string.Format("<{0}>",string.Join(", ",Enumerable.Range(1,i).Select(j=>"T"+j)));
      var paramList=i<1?string.Empty:string.Join(", ",Enumerable.Range(1,i).Select(j=>"T"+j+" arg"+j))+", ";
      var argList=i<1?string.Empty:string.Join(", ",Enumerable.Range(1,i).Select(j=>"arg"+j))+", ";
    #>

    public static IAsyncResult Async<#=dataType#>(this Action<#=dataType#> @this, <#=paramList#>object state = null) {
      Contract.Requires(@this!=null);
      return (@this.BeginInvoke(<#=argList#>@this.EndInvoke, state));
    }

    public static IAsyncResult BeginInvoke<#=dataType#>(this Action<#=dataType#> @this, <#=paramList#>AsyncCallback callback) {
      Contract.Requires(@this!=null);
      Contract.Requires(callback!=null);
      return (@this.BeginInvoke(<#=argList#>callback, null));
    }

    <#}#>

    #endregion
  }
}