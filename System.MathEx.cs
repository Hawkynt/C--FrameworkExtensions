#region (c)2010-2020 Hawkynt
/*
  This file is part of Hawkynt's .NET Framework extensions.

    Hawkynt's .NET Framework extensions are free software: 
    you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Hawkynt's .NET Framework extensions is distributed in the hope that 
    it will be useful, but WITHOUT ANY WARRANTY; without even the implied 
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
    the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Hawkynt's .NET Framework extensions.  
    If not, see <http://www.gnu.org/licenses/>.
*/
#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */

#if NETFX_4
using System.Diagnostics.Contracts;
#endif
#if NETFX_45
using System.Runtime.CompilerServices;
#endif
using word = System.UInt16;
using dword = System.UInt32;
using qword = System.UInt64;

// ReSharper disable UnusedMember.Global
// ReSharper disable RedundantCast
// ReSharper disable CompareOfFloatsByEqualityOperator
namespace System {
  internal static class MathEx {
      
    /// <summary>
    /// Determines whether the specified number is odd.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is odd; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsOdd(this byte @this) => (@this & 1) != 0;
    
    /// <summary>
    /// Determines whether the specified number is even.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is even; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsEven(this byte @this) => (@this & 1) == 0;

      
    /// <summary>
    /// Determines whether the specified number is odd.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is odd; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsOdd(this sbyte @this) => (@this & 1) != 0;
    
    /// <summary>
    /// Determines whether the specified number is even.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is even; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsEven(this sbyte @this) => (@this & 1) == 0;

      
    /// <summary>
    /// Determines whether the specified number is odd.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is odd; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsOdd(this word @this) => (@this & 1) != 0;
    
    /// <summary>
    /// Determines whether the specified number is even.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is even; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsEven(this word @this) => (@this & 1) == 0;

      
    /// <summary>
    /// Determines whether the specified number is odd.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is odd; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsOdd(this short @this) => (@this & 1) != 0;
    
    /// <summary>
    /// Determines whether the specified number is even.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is even; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsEven(this short @this) => (@this & 1) == 0;

      
    /// <summary>
    /// Determines whether the specified number is odd.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is odd; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsOdd(this dword @this) => (@this & 1) != 0;
    
    /// <summary>
    /// Determines whether the specified number is even.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is even; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsEven(this dword @this) => (@this & 1) == 0;

      
    /// <summary>
    /// Determines whether the specified number is odd.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is odd; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsOdd(this int @this) => (@this & 1) != 0;
    
    /// <summary>
    /// Determines whether the specified number is even.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is even; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsEven(this int @this) => (@this & 1) == 0;

      
    /// <summary>
    /// Determines whether the specified number is odd.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is odd; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsOdd(this qword @this) => (@this & 1) != 0;
    
    /// <summary>
    /// Determines whether the specified number is even.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is even; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsEven(this qword @this) => (@this & 1) == 0;

      
    /// <summary>
    /// Determines whether the specified number is odd.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is odd; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsOdd(this long @this) => (@this & 1) != 0;
    
    /// <summary>
    /// Determines whether the specified number is even.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is even; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsEven(this long @this) => (@this & 1) == 0;

    
      
    /// <summary>
    /// Determines whether the specified number is odd.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is odd; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    // ReSharper disable once CompareOfFloatsByEqualityOperator
    public static bool IsOdd(this float @this) => (@this % 2) != 0;
    
    /// <summary>
    /// Determines whether the specified number is even.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is even; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    // ReSharper disable once CompareOfFloatsByEqualityOperator
    public static bool IsEven(this float @this) => (@this % 2) == 0;
    
      
    /// <summary>
    /// Determines whether the specified number is odd.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is odd; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    // ReSharper disable once CompareOfFloatsByEqualityOperator
    public static bool IsOdd(this double @this) => (@this % 2) != 0;
    
    /// <summary>
    /// Determines whether the specified number is even.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is even; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    // ReSharper disable once CompareOfFloatsByEqualityOperator
    public static bool IsEven(this double @this) => (@this % 2) == 0;
    
      
    /// <summary>
    /// Determines whether the specified number is odd.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is odd; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    // ReSharper disable once CompareOfFloatsByEqualityOperator
    public static bool IsOdd(this decimal @this) => (@this % 2) != 0;
    
    /// <summary>
    /// Determines whether the specified number is even.
    /// </summary>
    /// <param name="this">This number.</param>
    /// <returns><c>true</c> if the number is even; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    // ReSharper disable once CompareOfFloatsByEqualityOperator
    public static bool IsEven(this decimal @this) => (@this % 2) == 0;
    
    
      
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static float Floor(this float @this) => (float)Math.Floor(@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static float Ceiling(this float @this) => (float)Math.Ceiling(@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static float Truncate(this float @this) => (float)Math.Truncate(@this);

      
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static double Floor(this double @this) => Math.Floor(@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static double Ceiling(this double @this) => Math.Ceiling(@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static double Truncate(this double @this) => Math.Truncate(@this);

      
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static decimal Floor(this decimal @this) => Math.Floor(@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static decimal Ceiling(this decimal @this) => Math.Ceiling(@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static decimal Truncate(this decimal @this) => Math.Truncate(@this);

      
  
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static float Round(this float @this) => (float)Math.Round(@this);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static float Round(this float @this, int digits) {
#if NETFX_4
      Contract.Requires(digits >= 0 && digits <= 15);
#endif
      return ((float)Math.Round(@this, digits));
    }

  
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static double Round(this double @this) => Math.Round(@this);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static double Round(this double @this, int digits) {
#if NETFX_4
      Contract.Requires(digits >= 0 && digits <= 15);
#endif
      return (Math.Round(@this, digits));
    }

  
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static decimal Round(this decimal @this) => Math.Round(@this);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static decimal Round(this decimal @this, int digits) {
#if NETFX_4
      Contract.Requires(digits >= 0 && digits <= 28);
#endif
      return (Math.Round(@this, digits));
    }

  
      
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static sbyte Abs(this sbyte @this) => Math.Abs(@this);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static sbyte Sign(this sbyte @this) => (sbyte)(@this<0?-1:1);

      
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static short Abs(this short @this) => Math.Abs(@this);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static short Sign(this short @this) => (short)(@this<0?-1:1);

      
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static int Abs(this int @this) => Math.Abs(@this);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static int Sign(this int @this) => (@this<0?-1:1);

      
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static long Abs(this long @this) => Math.Abs(@this);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static long Sign(this long @this) => (@this<0?-1:1);

      
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static float Abs(this float @this) => (float)Math.Abs(@this);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static float Sign(this float @this) => (@this<0?-1:1);

      
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static double Abs(this double @this) => Math.Abs(@this);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static double Sign(this double @this) => (@this<0?-1:1);

      
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static decimal Abs(this decimal @this) => Math.Abs(@this);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static decimal Sign(this decimal @this) => (@this<0?-1:1);

    
      
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsNaN(this float @this) => float.IsNaN(@this);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsInfinity(this float @this) => float.IsInfinity(@this);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsPositiveInfinity(this float @this) => float.IsPositiveInfinity(@this);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsNegativeInfinity(this float @this) => float.IsNegativeInfinity(@this);
    
      
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsNaN(this double @this) => double.IsNaN(@this);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsInfinity(this double @this) => double.IsInfinity(@this);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsPositiveInfinity(this double @this) => double.IsPositiveInfinity(@this);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsNegativeInfinity(this double @this) => double.IsNegativeInfinity(@this);
    
    
      
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static sbyte Squared(this sbyte @this) => (sbyte)(@this*@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static sbyte Cubed(this sbyte @this) => (sbyte)(@this*@this*@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static sbyte ToThePower(this sbyte @this,sbyte exponent) => (sbyte)Math.Pow(@this,exponent);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static sbyte MultipliedWith(this sbyte @this,sbyte factor) => (sbyte)(@this * factor);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static sbyte DividedBy(this sbyte @this,sbyte divisor) => (sbyte)(@this / divisor);

    /// <summary>
    /// Determines whether the given value is zero.
    /// </summary>
    /// <param name="this">This value.</param>
    /// <returns><c>true</c> if the value is zero; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsZero(this sbyte @this) => @this == 0;
    
    /// <summary>
    /// Determines whether the given value is not zero.
    /// </summary>
    /// <param name="this">This value.</param>
    /// <returns><c>true</c> if the value is not zero; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsNotZero(this sbyte @this) => @this != 0;

      
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static byte Squared(this byte @this) => (byte)(@this*@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static byte Cubed(this byte @this) => (byte)(@this*@this*@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static byte ToThePower(this byte @this,byte exponent) => (byte)Math.Pow(@this,exponent);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static byte MultipliedWith(this byte @this,byte factor) => (byte)(@this * factor);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static byte DividedBy(this byte @this,byte divisor) => (byte)(@this / divisor);

    /// <summary>
    /// Determines whether the given value is zero.
    /// </summary>
    /// <param name="this">This value.</param>
    /// <returns><c>true</c> if the value is zero; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsZero(this byte @this) => @this == 0;
    
    /// <summary>
    /// Determines whether the given value is not zero.
    /// </summary>
    /// <param name="this">This value.</param>
    /// <returns><c>true</c> if the value is not zero; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsNotZero(this byte @this) => @this != 0;

      
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static short Squared(this short @this) => (short)(@this*@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static short Cubed(this short @this) => (short)(@this*@this*@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static short ToThePower(this short @this,short exponent) => (short)Math.Pow(@this,exponent);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static short MultipliedWith(this short @this,short factor) => (short)(@this * factor);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static short DividedBy(this short @this,short divisor) => (short)(@this / divisor);

    /// <summary>
    /// Determines whether the given value is zero.
    /// </summary>
    /// <param name="this">This value.</param>
    /// <returns><c>true</c> if the value is zero; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsZero(this short @this) => @this == 0;
    
    /// <summary>
    /// Determines whether the given value is not zero.
    /// </summary>
    /// <param name="this">This value.</param>
    /// <returns><c>true</c> if the value is not zero; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsNotZero(this short @this) => @this != 0;

      
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static word Squared(this word @this) => (word)(@this*@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static word Cubed(this word @this) => (word)(@this*@this*@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static word ToThePower(this word @this,word exponent) => (word)Math.Pow(@this,exponent);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static word MultipliedWith(this word @this,word factor) => (word)(@this * factor);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static word DividedBy(this word @this,word divisor) => (word)(@this / divisor);

    /// <summary>
    /// Determines whether the given value is zero.
    /// </summary>
    /// <param name="this">This value.</param>
    /// <returns><c>true</c> if the value is zero; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsZero(this word @this) => @this == 0;
    
    /// <summary>
    /// Determines whether the given value is not zero.
    /// </summary>
    /// <param name="this">This value.</param>
    /// <returns><c>true</c> if the value is not zero; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsNotZero(this word @this) => @this != 0;

      
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static int Squared(this int @this) => (int)(@this*@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static int Cubed(this int @this) => (int)(@this*@this*@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static int ToThePower(this int @this,int exponent) => (int)Math.Pow(@this,exponent);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static int MultipliedWith(this int @this,int factor) => (int)(@this * factor);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static int DividedBy(this int @this,int divisor) => (int)(@this / divisor);

    /// <summary>
    /// Determines whether the given value is zero.
    /// </summary>
    /// <param name="this">This value.</param>
    /// <returns><c>true</c> if the value is zero; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsZero(this int @this) => @this == 0;
    
    /// <summary>
    /// Determines whether the given value is not zero.
    /// </summary>
    /// <param name="this">This value.</param>
    /// <returns><c>true</c> if the value is not zero; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsNotZero(this int @this) => @this != 0;

      
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static dword Squared(this dword @this) => (dword)(@this*@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static dword Cubed(this dword @this) => (dword)(@this*@this*@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static dword ToThePower(this dword @this,dword exponent) => (dword)Math.Pow(@this,exponent);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static dword MultipliedWith(this dword @this,dword factor) => (dword)(@this * factor);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static dword DividedBy(this dword @this,dword divisor) => (dword)(@this / divisor);

    /// <summary>
    /// Determines whether the given value is zero.
    /// </summary>
    /// <param name="this">This value.</param>
    /// <returns><c>true</c> if the value is zero; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsZero(this dword @this) => @this == 0;
    
    /// <summary>
    /// Determines whether the given value is not zero.
    /// </summary>
    /// <param name="this">This value.</param>
    /// <returns><c>true</c> if the value is not zero; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsNotZero(this dword @this) => @this != 0;

      
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static long Squared(this long @this) => (long)(@this*@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static long Cubed(this long @this) => (long)(@this*@this*@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static long ToThePower(this long @this,long exponent) => (long)Math.Pow(@this,exponent);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static long MultipliedWith(this long @this,long factor) => (long)(@this * factor);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static long DividedBy(this long @this,long divisor) => (long)(@this / divisor);

    /// <summary>
    /// Determines whether the given value is zero.
    /// </summary>
    /// <param name="this">This value.</param>
    /// <returns><c>true</c> if the value is zero; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsZero(this long @this) => @this == 0;
    
    /// <summary>
    /// Determines whether the given value is not zero.
    /// </summary>
    /// <param name="this">This value.</param>
    /// <returns><c>true</c> if the value is not zero; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsNotZero(this long @this) => @this != 0;

      
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static qword Squared(this qword @this) => (qword)(@this*@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static qword Cubed(this qword @this) => (qword)(@this*@this*@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static qword ToThePower(this qword @this,qword exponent) => (qword)Math.Pow(@this,exponent);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static qword MultipliedWith(this qword @this,qword factor) => (qword)(@this * factor);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static qword DividedBy(this qword @this,qword divisor) => (qword)(@this / divisor);

    /// <summary>
    /// Determines whether the given value is zero.
    /// </summary>
    /// <param name="this">This value.</param>
    /// <returns><c>true</c> if the value is zero; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsZero(this qword @this) => @this == 0;
    
    /// <summary>
    /// Determines whether the given value is not zero.
    /// </summary>
    /// <param name="this">This value.</param>
    /// <returns><c>true</c> if the value is not zero; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsNotZero(this qword @this) => @this != 0;

      
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static float Squared(this float @this) => (float)(@this*@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static float Cubed(this float @this) => (float)(@this*@this*@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static float ToThePower(this float @this,float exponent) => (float)Math.Pow(@this,exponent);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static float MultipliedWith(this float @this,float factor) => (float)(@this * factor);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static float DividedBy(this float @this,float divisor) => (float)(@this / divisor);

    /// <summary>
    /// Determines whether the given value is zero.
    /// </summary>
    /// <param name="this">This value.</param>
    /// <returns><c>true</c> if the value is zero; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsZero(this float @this) => @this == 0;
    
    /// <summary>
    /// Determines whether the given value is not zero.
    /// </summary>
    /// <param name="this">This value.</param>
    /// <returns><c>true</c> if the value is not zero; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsNotZero(this float @this) => @this != 0;

      
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static double Squared(this double @this) => (double)(@this*@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static double Cubed(this double @this) => (double)(@this*@this*@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static double ToThePower(this double @this,double exponent) => (double)Math.Pow(@this,exponent);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static double MultipliedWith(this double @this,double factor) => (double)(@this * factor);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static double DividedBy(this double @this,double divisor) => (double)(@this / divisor);

    /// <summary>
    /// Determines whether the given value is zero.
    /// </summary>
    /// <param name="this">This value.</param>
    /// <returns><c>true</c> if the value is zero; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsZero(this double @this) => @this == 0;
    
    /// <summary>
    /// Determines whether the given value is not zero.
    /// </summary>
    /// <param name="this">This value.</param>
    /// <returns><c>true</c> if the value is not zero; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsNotZero(this double @this) => @this != 0;

      
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static decimal Squared(this decimal @this) => (decimal)(@this*@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static decimal Cubed(this decimal @this) => (decimal)(@this*@this*@this);
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static decimal ToThePower(this decimal @this,decimal exponent) => (decimal)Math.Pow((double)@this,(double)exponent);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static decimal MultipliedWith(this decimal @this,decimal factor) => (decimal)(@this * factor);

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static decimal DividedBy(this decimal @this,decimal divisor) => (decimal)(@this / divisor);

    /// <summary>
    /// Determines whether the given value is zero.
    /// </summary>
    /// <param name="this">This value.</param>
    /// <returns><c>true</c> if the value is zero; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsZero(this decimal @this) => @this == 0;
    
    /// <summary>
    /// Determines whether the given value is not zero.
    /// </summary>
    /// <param name="this">This value.</param>
    /// <returns><c>true</c> if the value is not zero; otherwise, <c>false</c>.</returns>
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsNotZero(this decimal @this) => @this != 0;

  
  
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static double Sin(this double @this) => Math.Sin(@this);
    
  
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static double Sinh(this double @this) => Math.Sinh(@this);
    
  
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static double Cos(this double @this) => Math.Cos(@this);
    
  
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static double Cosh(this double @this) => Math.Cosh(@this);
    
  
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static double Tan(this double @this) => Math.Tan(@this);
    
  
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static double Tanh(this double @this) => Math.Tanh(@this);
    
  
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static double Sqrt(this double @this) => Math.Sqrt(@this);
    
  
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static double Log10(this double @this) => Math.Log10(@this);
    
  
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static double Log(this double @this) => Math.Log(@this);
    
  
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static double Log(this double @this, double @base) => Math.Log(@this, @base);
        
    #region fast min/max

  
    #region sbyte
    /// <summary>
    /// Gets the minimum value from the given ones.
    /// </summary>
    /// <param name="values">The values.</param>
    /// <returns>The min value.</returns>
#if NETFX_4
    [Pure]
#endif
    public static sbyte Min(params sbyte[] values) {
      var length = values.Length;
      if (length == 0)
        return (default(sbyte));

      var result = values[0];
      for (var i = 1; i < length; ++i) 
        if (values[i] < result)
          result = values[i];

      return (result);
    }

    /// <summary>
    /// Gets the maximum value from the given ones.
    /// </summary>
    /// <param name="values">The values.</param>
    /// <returns>The max value.</returns>
#if NETFX_4
    [Pure]
#endif
    public static sbyte Max(params sbyte[] values) {
      var length = values.Length;
      if (length == 0)
        return (default(sbyte));

      var result = values[0];
      for (var i = 1; i < length; ++i) 
        if (values[i] > result)
          result = values[i];

      return (result);
    }

#if NETFX_4
    [Pure]
#endif
    public static bool IsIn(sbyte @this, sbyte[] values) {
      var length = values.Length;
      if (length == 0)
        return(false);

      for (var i = 0; i < length; ++i) 
        if (values[i] == @this)
          return(true);

      return(false);
    }

#if NETFX_4
    [Pure]
#endif
    public static bool IsNotIn(sbyte @this, sbyte[] values) {
      var length = values.Length;
      if (length == 0)
        return(true);

      for (var i = 0; i < length; ++i) 
        if (values[i] == @this)
          return(false);

      return(true);
    }

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsBetween(sbyte @this, sbyte lowerBoundary, sbyte upperBoundary) => lowerBoundary<@this && @this<upperBoundary;
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsInRange(sbyte @this, sbyte lowerBoundary, sbyte upperBoundary) => lowerBoundary<=@this && @this<=upperBoundary;

    #endregion

  
    #region byte
    /// <summary>
    /// Gets the minimum value from the given ones.
    /// </summary>
    /// <param name="values">The values.</param>
    /// <returns>The min value.</returns>
#if NETFX_4
    [Pure]
#endif
    public static byte Min(params byte[] values) {
      var length = values.Length;
      if (length == 0)
        return (default(byte));

      var result = values[0];
      for (var i = 1; i < length; ++i) 
        if (values[i] < result)
          result = values[i];

      return (result);
    }

    /// <summary>
    /// Gets the maximum value from the given ones.
    /// </summary>
    /// <param name="values">The values.</param>
    /// <returns>The max value.</returns>
#if NETFX_4
    [Pure]
#endif
    public static byte Max(params byte[] values) {
      var length = values.Length;
      if (length == 0)
        return (default(byte));

      var result = values[0];
      for (var i = 1; i < length; ++i) 
        if (values[i] > result)
          result = values[i];

      return (result);
    }

#if NETFX_4
    [Pure]
#endif
    public static bool IsIn(byte @this, byte[] values) {
      var length = values.Length;
      if (length == 0)
        return(false);

      for (var i = 0; i < length; ++i) 
        if (values[i] == @this)
          return(true);

      return(false);
    }

#if NETFX_4
    [Pure]
#endif
    public static bool IsNotIn(byte @this, byte[] values) {
      var length = values.Length;
      if (length == 0)
        return(true);

      for (var i = 0; i < length; ++i) 
        if (values[i] == @this)
          return(false);

      return(true);
    }

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsBetween(byte @this, byte lowerBoundary, byte upperBoundary) => lowerBoundary<@this && @this<upperBoundary;
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsInRange(byte @this, byte lowerBoundary, byte upperBoundary) => lowerBoundary<=@this && @this<=upperBoundary;

    #endregion

  
    #region short
    /// <summary>
    /// Gets the minimum value from the given ones.
    /// </summary>
    /// <param name="values">The values.</param>
    /// <returns>The min value.</returns>
#if NETFX_4
    [Pure]
#endif
    public static short Min(params short[] values) {
      var length = values.Length;
      if (length == 0)
        return (default(short));

      var result = values[0];
      for (var i = 1; i < length; ++i) 
        if (values[i] < result)
          result = values[i];

      return (result);
    }

    /// <summary>
    /// Gets the maximum value from the given ones.
    /// </summary>
    /// <param name="values">The values.</param>
    /// <returns>The max value.</returns>
#if NETFX_4
    [Pure]
#endif
    public static short Max(params short[] values) {
      var length = values.Length;
      if (length == 0)
        return (default(short));

      var result = values[0];
      for (var i = 1; i < length; ++i) 
        if (values[i] > result)
          result = values[i];

      return (result);
    }

#if NETFX_4
    [Pure]
#endif
    public static bool IsIn(short @this, short[] values) {
      var length = values.Length;
      if (length == 0)
        return(false);

      for (var i = 0; i < length; ++i) 
        if (values[i] == @this)
          return(true);

      return(false);
    }

#if NETFX_4
    [Pure]
#endif
    public static bool IsNotIn(short @this, short[] values) {
      var length = values.Length;
      if (length == 0)
        return(true);

      for (var i = 0; i < length; ++i) 
        if (values[i] == @this)
          return(false);

      return(true);
    }

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsBetween(short @this, short lowerBoundary, short upperBoundary) => lowerBoundary<@this && @this<upperBoundary;
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsInRange(short @this, short lowerBoundary, short upperBoundary) => lowerBoundary<=@this && @this<=upperBoundary;

    #endregion

  
    #region word
    /// <summary>
    /// Gets the minimum value from the given ones.
    /// </summary>
    /// <param name="values">The values.</param>
    /// <returns>The min value.</returns>
#if NETFX_4
    [Pure]
#endif
    public static word Min(params word[] values) {
      var length = values.Length;
      if (length == 0)
        return (default(word));

      var result = values[0];
      for (var i = 1; i < length; ++i) 
        if (values[i] < result)
          result = values[i];

      return (result);
    }

    /// <summary>
    /// Gets the maximum value from the given ones.
    /// </summary>
    /// <param name="values">The values.</param>
    /// <returns>The max value.</returns>
#if NETFX_4
    [Pure]
#endif
    public static word Max(params word[] values) {
      var length = values.Length;
      if (length == 0)
        return (default(word));

      var result = values[0];
      for (var i = 1; i < length; ++i) 
        if (values[i] > result)
          result = values[i];

      return (result);
    }

#if NETFX_4
    [Pure]
#endif
    public static bool IsIn(word @this, word[] values) {
      var length = values.Length;
      if (length == 0)
        return(false);

      for (var i = 0; i < length; ++i) 
        if (values[i] == @this)
          return(true);

      return(false);
    }

#if NETFX_4
    [Pure]
#endif
    public static bool IsNotIn(word @this, word[] values) {
      var length = values.Length;
      if (length == 0)
        return(true);

      for (var i = 0; i < length; ++i) 
        if (values[i] == @this)
          return(false);

      return(true);
    }

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsBetween(word @this, word lowerBoundary, word upperBoundary) => lowerBoundary<@this && @this<upperBoundary;
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsInRange(word @this, word lowerBoundary, word upperBoundary) => lowerBoundary<=@this && @this<=upperBoundary;

    #endregion

  
    #region int
    /// <summary>
    /// Gets the minimum value from the given ones.
    /// </summary>
    /// <param name="values">The values.</param>
    /// <returns>The min value.</returns>
#if NETFX_4
    [Pure]
#endif
    public static int Min(params int[] values) {
      var length = values.Length;
      if (length == 0)
        return (default(int));

      var result = values[0];
      for (var i = 1; i < length; ++i) 
        if (values[i] < result)
          result = values[i];

      return (result);
    }

    /// <summary>
    /// Gets the maximum value from the given ones.
    /// </summary>
    /// <param name="values">The values.</param>
    /// <returns>The max value.</returns>
#if NETFX_4
    [Pure]
#endif
    public static int Max(params int[] values) {
      var length = values.Length;
      if (length == 0)
        return (default(int));

      var result = values[0];
      for (var i = 1; i < length; ++i) 
        if (values[i] > result)
          result = values[i];

      return (result);
    }

#if NETFX_4
    [Pure]
#endif
    public static bool IsIn(int @this, int[] values) {
      var length = values.Length;
      if (length == 0)
        return(false);

      for (var i = 0; i < length; ++i) 
        if (values[i] == @this)
          return(true);

      return(false);
    }

#if NETFX_4
    [Pure]
#endif
    public static bool IsNotIn(int @this, int[] values) {
      var length = values.Length;
      if (length == 0)
        return(true);

      for (var i = 0; i < length; ++i) 
        if (values[i] == @this)
          return(false);

      return(true);
    }

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsBetween(int @this, int lowerBoundary, int upperBoundary) => lowerBoundary<@this && @this<upperBoundary;
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsInRange(int @this, int lowerBoundary, int upperBoundary) => lowerBoundary<=@this && @this<=upperBoundary;

    #endregion

  
    #region dword
    /// <summary>
    /// Gets the minimum value from the given ones.
    /// </summary>
    /// <param name="values">The values.</param>
    /// <returns>The min value.</returns>
#if NETFX_4
    [Pure]
#endif
    public static dword Min(params dword[] values) {
      var length = values.Length;
      if (length == 0)
        return (default(dword));

      var result = values[0];
      for (var i = 1; i < length; ++i) 
        if (values[i] < result)
          result = values[i];

      return (result);
    }

    /// <summary>
    /// Gets the maximum value from the given ones.
    /// </summary>
    /// <param name="values">The values.</param>
    /// <returns>The max value.</returns>
#if NETFX_4
    [Pure]
#endif
    public static dword Max(params dword[] values) {
      var length = values.Length;
      if (length == 0)
        return (default(dword));

      var result = values[0];
      for (var i = 1; i < length; ++i) 
        if (values[i] > result)
          result = values[i];

      return (result);
    }

#if NETFX_4
    [Pure]
#endif
    public static bool IsIn(dword @this, dword[] values) {
      var length = values.Length;
      if (length == 0)
        return(false);

      for (var i = 0; i < length; ++i) 
        if (values[i] == @this)
          return(true);

      return(false);
    }

#if NETFX_4
    [Pure]
#endif
    public static bool IsNotIn(dword @this, dword[] values) {
      var length = values.Length;
      if (length == 0)
        return(true);

      for (var i = 0; i < length; ++i) 
        if (values[i] == @this)
          return(false);

      return(true);
    }

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsBetween(dword @this, dword lowerBoundary, dword upperBoundary) => lowerBoundary<@this && @this<upperBoundary;
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsInRange(dword @this, dword lowerBoundary, dword upperBoundary) => lowerBoundary<=@this && @this<=upperBoundary;

    #endregion

  
    #region long
    /// <summary>
    /// Gets the minimum value from the given ones.
    /// </summary>
    /// <param name="values">The values.</param>
    /// <returns>The min value.</returns>
#if NETFX_4
    [Pure]
#endif
    public static long Min(params long[] values) {
      var length = values.Length;
      if (length == 0)
        return (default(long));

      var result = values[0];
      for (var i = 1; i < length; ++i) 
        if (values[i] < result)
          result = values[i];

      return (result);
    }

    /// <summary>
    /// Gets the maximum value from the given ones.
    /// </summary>
    /// <param name="values">The values.</param>
    /// <returns>The max value.</returns>
#if NETFX_4
    [Pure]
#endif
    public static long Max(params long[] values) {
      var length = values.Length;
      if (length == 0)
        return (default(long));

      var result = values[0];
      for (var i = 1; i < length; ++i) 
        if (values[i] > result)
          result = values[i];

      return (result);
    }

#if NETFX_4
    [Pure]
#endif
    public static bool IsIn(long @this, long[] values) {
      var length = values.Length;
      if (length == 0)
        return(false);

      for (var i = 0; i < length; ++i) 
        if (values[i] == @this)
          return(true);

      return(false);
    }

#if NETFX_4
    [Pure]
#endif
    public static bool IsNotIn(long @this, long[] values) {
      var length = values.Length;
      if (length == 0)
        return(true);

      for (var i = 0; i < length; ++i) 
        if (values[i] == @this)
          return(false);

      return(true);
    }

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsBetween(long @this, long lowerBoundary, long upperBoundary) => lowerBoundary<@this && @this<upperBoundary;
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsInRange(long @this, long lowerBoundary, long upperBoundary) => lowerBoundary<=@this && @this<=upperBoundary;

    #endregion

  
    #region qword
    /// <summary>
    /// Gets the minimum value from the given ones.
    /// </summary>
    /// <param name="values">The values.</param>
    /// <returns>The min value.</returns>
#if NETFX_4
    [Pure]
#endif
    public static qword Min(params qword[] values) {
      var length = values.Length;
      if (length == 0)
        return (default(qword));

      var result = values[0];
      for (var i = 1; i < length; ++i) 
        if (values[i] < result)
          result = values[i];

      return (result);
    }

    /// <summary>
    /// Gets the maximum value from the given ones.
    /// </summary>
    /// <param name="values">The values.</param>
    /// <returns>The max value.</returns>
#if NETFX_4
    [Pure]
#endif
    public static qword Max(params qword[] values) {
      var length = values.Length;
      if (length == 0)
        return (default(qword));

      var result = values[0];
      for (var i = 1; i < length; ++i) 
        if (values[i] > result)
          result = values[i];

      return (result);
    }

#if NETFX_4
    [Pure]
#endif
    public static bool IsIn(qword @this, qword[] values) {
      var length = values.Length;
      if (length == 0)
        return(false);

      for (var i = 0; i < length; ++i) 
        if (values[i] == @this)
          return(true);

      return(false);
    }

#if NETFX_4
    [Pure]
#endif
    public static bool IsNotIn(qword @this, qword[] values) {
      var length = values.Length;
      if (length == 0)
        return(true);

      for (var i = 0; i < length; ++i) 
        if (values[i] == @this)
          return(false);

      return(true);
    }

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsBetween(qword @this, qword lowerBoundary, qword upperBoundary) => lowerBoundary<@this && @this<upperBoundary;
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsInRange(qword @this, qword lowerBoundary, qword upperBoundary) => lowerBoundary<=@this && @this<=upperBoundary;

    #endregion

  
    #region float
    /// <summary>
    /// Gets the minimum value from the given ones.
    /// </summary>
    /// <param name="values">The values.</param>
    /// <returns>The min value.</returns>
#if NETFX_4
    [Pure]
#endif
    public static float Min(params float[] values) {
      var length = values.Length;
      if (length == 0)
        return (default(float));

      var result = values[0];
      for (var i = 1; i < length; ++i) 
        if (values[i] < result)
          result = values[i];

      return (result);
    }

    /// <summary>
    /// Gets the maximum value from the given ones.
    /// </summary>
    /// <param name="values">The values.</param>
    /// <returns>The max value.</returns>
#if NETFX_4
    [Pure]
#endif
    public static float Max(params float[] values) {
      var length = values.Length;
      if (length == 0)
        return (default(float));

      var result = values[0];
      for (var i = 1; i < length; ++i) 
        if (values[i] > result)
          result = values[i];

      return (result);
    }

#if NETFX_4
    [Pure]
#endif
    public static bool IsIn(float @this, float[] values) {
      var length = values.Length;
      if (length == 0)
        return(false);

      for (var i = 0; i < length; ++i) 
        if (values[i] == @this)
          return(true);

      return(false);
    }

#if NETFX_4
    [Pure]
#endif
    public static bool IsNotIn(float @this, float[] values) {
      var length = values.Length;
      if (length == 0)
        return(true);

      for (var i = 0; i < length; ++i) 
        if (values[i] == @this)
          return(false);

      return(true);
    }

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsBetween(float @this, float lowerBoundary, float upperBoundary) => lowerBoundary<@this && @this<upperBoundary;
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsInRange(float @this, float lowerBoundary, float upperBoundary) => lowerBoundary<=@this && @this<=upperBoundary;

    #endregion

  
    #region double
    /// <summary>
    /// Gets the minimum value from the given ones.
    /// </summary>
    /// <param name="values">The values.</param>
    /// <returns>The min value.</returns>
#if NETFX_4
    [Pure]
#endif
    public static double Min(params double[] values) {
      var length = values.Length;
      if (length == 0)
        return (default(double));

      var result = values[0];
      for (var i = 1; i < length; ++i) 
        if (values[i] < result)
          result = values[i];

      return (result);
    }

    /// <summary>
    /// Gets the maximum value from the given ones.
    /// </summary>
    /// <param name="values">The values.</param>
    /// <returns>The max value.</returns>
#if NETFX_4
    [Pure]
#endif
    public static double Max(params double[] values) {
      var length = values.Length;
      if (length == 0)
        return (default(double));

      var result = values[0];
      for (var i = 1; i < length; ++i) 
        if (values[i] > result)
          result = values[i];

      return (result);
    }

#if NETFX_4
    [Pure]
#endif
    public static bool IsIn(double @this, double[] values) {
      var length = values.Length;
      if (length == 0)
        return(false);

      for (var i = 0; i < length; ++i) 
        if (values[i] == @this)
          return(true);

      return(false);
    }

#if NETFX_4
    [Pure]
#endif
    public static bool IsNotIn(double @this, double[] values) {
      var length = values.Length;
      if (length == 0)
        return(true);

      for (var i = 0; i < length; ++i) 
        if (values[i] == @this)
          return(false);

      return(true);
    }

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsBetween(double @this, double lowerBoundary, double upperBoundary) => lowerBoundary<@this && @this<upperBoundary;
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsInRange(double @this, double lowerBoundary, double upperBoundary) => lowerBoundary<=@this && @this<=upperBoundary;

    #endregion

  
    #region decimal
    /// <summary>
    /// Gets the minimum value from the given ones.
    /// </summary>
    /// <param name="values">The values.</param>
    /// <returns>The min value.</returns>
#if NETFX_4
    [Pure]
#endif
    public static decimal Min(params decimal[] values) {
      var length = values.Length;
      if (length == 0)
        return (default(decimal));

      var result = values[0];
      for (var i = 1; i < length; ++i) 
        if (values[i] < result)
          result = values[i];

      return (result);
    }

    /// <summary>
    /// Gets the maximum value from the given ones.
    /// </summary>
    /// <param name="values">The values.</param>
    /// <returns>The max value.</returns>
#if NETFX_4
    [Pure]
#endif
    public static decimal Max(params decimal[] values) {
      var length = values.Length;
      if (length == 0)
        return (default(decimal));

      var result = values[0];
      for (var i = 1; i < length; ++i) 
        if (values[i] > result)
          result = values[i];

      return (result);
    }

#if NETFX_4
    [Pure]
#endif
    public static bool IsIn(decimal @this, decimal[] values) {
      var length = values.Length;
      if (length == 0)
        return(false);

      for (var i = 0; i < length; ++i) 
        if (values[i] == @this)
          return(true);

      return(false);
    }

#if NETFX_4
    [Pure]
#endif
    public static bool IsNotIn(decimal @this, decimal[] values) {
      var length = values.Length;
      if (length == 0)
        return(true);

      for (var i = 0; i < length; ++i) 
        if (values[i] == @this)
          return(false);

      return(true);
    }

#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsBetween(decimal @this, decimal lowerBoundary, decimal upperBoundary) => lowerBoundary<@this && @this<upperBoundary;
    
#if NETFX_4
    [Pure]
#endif
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool IsInRange(decimal @this, decimal lowerBoundary, decimal upperBoundary) => lowerBoundary<=@this && @this<=upperBoundary;

    #endregion

  
    #endregion

  }
}
