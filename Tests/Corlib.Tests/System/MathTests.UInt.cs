using System.Linq;
using NUnit.Framework;

namespace System;

[TestFixture]
public partial class MathTests {

  [Test]
  [TestCase((uint)0b00000000000000000000000000000001, 0, (uint)0b00000000000000000000000000000001)]
  [TestCase((uint)0b00000000000000000000000000000001, 1, (uint)0b00000000000000000000000000000010)]
  [TestCase((uint)0b00000000000000000000000000000001, 31, (uint)0b10000000000000000000000000000000)]
  [TestCase((uint)0b00000000000000000000000000000001, 32, (uint)0b00000000000000000000000000000000)]
  [TestCase((uint)0b00000000000000000000000000000001, 64, (uint)0b00000000000000000000000000000000)]
  public void ArithmeticShiftLeftDWord(uint inp, byte count, uint expected) => Assert.AreEqual(expected, inp.ArithmeticShiftLeft(count));

  [Test]
  [TestCase((uint)0b00000000000000000000000000000001, 0, (uint)0b00000000000000000000000000000001)]
  [TestCase((uint)0b00000000000000000000000000000010, 1, (uint)0b00000000000000000000000000000001)]
  [TestCase((uint)0b10000000000000000000000000000000, 31, (uint)0b00000000000000000000000000000001)]
  [TestCase((uint)0b10000000000000000000000000000000, 32, (uint)0b00000000000000000000000000000000)]
  [TestCase((uint)0b10000000000000000000000000000000, 64, (uint)0b00000000000000000000000000000000)]
  public void ArithmeticShiftRightDWord(uint inp, byte count, uint expected) => Assert.AreEqual(expected, inp.ArithmeticShiftRight(count));

  [Test]
  [TestCase((uint)0b00000000000000000000000000000001, 0, (uint)0b00000000000000000000000000000001)]
  [TestCase((uint)0b00000000000000000000000000000001, 1, (uint)0b00000000000000000000000000000010)]
  [TestCase((uint)0b10000000000000000000000000000001, 1, (uint)0b00000000000000000000000000000011)]
  [TestCase((uint)0b00000000000000000000000000000001, 31, (uint)0b10000000000000000000000000000000)]
  [TestCase((uint)0b00000000000000000000000000000001, 32, (uint)0b00000000000000000000000000000001)]
  [TestCase((uint)0b00000000000000000000000000000001, 64, (uint)0b00000000000000000000000000000001)]
  public void RotateLeftDWord(uint inp, byte count, uint expected) => Assert.AreEqual(expected, inp.RotateLeft(count));

  [Test]
  [TestCase((uint)0b00000000000000000000000000000001, 0, (uint)0b00000000000000000000000000000001)]
  [TestCase((uint)0b00000000000000000000000000000010, 1, (uint)0b00000000000000000000000000000001)]
  [TestCase((uint)0b10000000000000000000000000000001, 1, (uint)0b11000000000000000000000000000000)]
  [TestCase((uint)0b10000000000000000000000000000000, 31, (uint)0b00000000000000000000000000000001)]
  [TestCase((uint)0b10000000000000000000000000000000, 32, (uint)0b10000000000000000000000000000000)]
  [TestCase((uint)0b10000000000000000000000000000000, 64, (uint)0b10000000000000000000000000000000)]
  public void RotateRightDWord(uint inp, byte count, uint expected) => Assert.AreEqual(expected, inp.RotateRight(count));

  [Test]
  [TestCase(0b00011011, 0b11011000, 0b00011000, 0b11011011, 0b11000011, 0b11100111, 0b00100100, 0b00111100)]
  public void BitwiseUInt(byte self, byte operand, byte and, byte or, byte xor, byte nand, byte nor, byte equ) {
    var valuePack = new []{self, operand, and, or, xor, nand, nor, equ};
    var wordPack = valuePack.Select(i=>(ushort)(i<<8|i)).ToArray();
    var dwordPack = wordPack.Select(i => (uint)(i << 16 | i)).ToArray();
    
    Assert.AreEqual(dwordPack[2], dwordPack[0].And(dwordPack[1]), "And broken");
    Assert.AreEqual(dwordPack[3], dwordPack[0].Or(dwordPack[1]), "Or broken");
    Assert.AreEqual(dwordPack[4], dwordPack[0].Xor(dwordPack[1]), "Xor broken");
    Assert.AreEqual(dwordPack[5], dwordPack[0].Nand(dwordPack[1]), "Nand broken");
    Assert.AreEqual(dwordPack[6], dwordPack[0].Nor(dwordPack[1]), "Nor broken");
    Assert.AreEqual(dwordPack[7], dwordPack[0].Equ(dwordPack[1]), "Equ broken");
  }

  [Test]
  [TestCase((uint)0b00000000000000000000000000000000, (uint)0b00000000000000000000000000000000, (uint)0b00000000000000000000000000000000)]
  [TestCase((uint)0b11111111111111111111111111111111, (uint)0b00000000000000000000000000000000, (uint)0b00000000000000000000000000000000)]
  [TestCase((uint)0b11111111111111111111111111111111, (uint)0b11111111111111111111111111111111, (uint)0b11111111111111111111111111111111)]
  [TestCase((uint)0b10101010101010101010101010101010, (uint)0b11111111111111110000000000000000, (uint)0b00000000000000001010101010101010)]
  [TestCase((uint)0b10101010101010101010101010101010, (uint)0b00000000000000001111111111111111, (uint)0b00000000000000001010101010101010)]
  [TestCase((uint)0b11111111111111110000000000000000, (uint)0b00000000000000001111111111111111, (uint)0b00000000000000000000000000000000)]
  [TestCase((uint)0b10101010101010101010101010101010, (uint)0b10101010101010101010101010101010, (uint)0b00000000000000001111111111111111)]
  [TestCase((uint)0b11111111111111111111111111111111, (uint)0b10000000000000000000000000000000, (uint)0b00000000000000000000000000000001)]
  [TestCase((uint)0b11111111111111111111111111111111, (uint)0b01000000000000000000000000000000, (uint)0b00000000000000000000000000000001)]
  [TestCase((uint)0b11111111111111111111111111111111, (uint)0b00000000000000000000000000000100, (uint)0b00000000000000000000000000000001)]
  [TestCase((uint)0b11111111111111111111111111111111, (uint)0b00000000000000000000000000000010, (uint)0b00000000000000000000000000000001)]
  [TestCase((uint)0b11111111111111111111111111111111, (uint)0b00000000000000000000000000000001, (uint)0b00000000000000000000000000000001)]
  public void ParallelBitExtractDWord(uint value, uint mask, uint expected) => Assert.AreEqual(expected, value.ParallelBitExtract(mask));

}