<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
#region (c)2010-2042 Hawkynt
/*
  This file is part of Hawkynt's .NET Framework extensions.

    Hawkynt's .NET Framework extensions are free software:
    you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Hawkynt's .NET Framework extensions is distributed in the hope that
    it will be useful, but WITHOUT ANY WARRANTY; without even the implied
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
    the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Hawkynt's .NET Framework extensions.
    If not, see <http://www.gnu.org/licenses/>.
*/
#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */
<#
  const int LINEAR_BLOCK_COUNTX86 = 16;              // x86 can only copy 16-byte blocks without emitting loop constructs (rep movsb)
  const int LINEAR_BLOCK_COUNTX64 = 64;              // x64 uses vmovdqu for blocks up to 64-bytes
  const int MARSHALL_SWITCH_COUNT = 8;               // how many bytes we'll quickly process using a switch statement (must >= 7)
  const int MARSHALL_LOOP_UNROLL  = 0;               // doesn't give speedup when using Marshal.* because the calls are damn slow anyway
  const int UNSAFE_SWITCH_COUNT   = 8;               // what number of bytes to unroll unsafe
  const int INDEX_LOOP_UNROLL     = 8;               // ldc.i4 8 is the highest opcode available for index operations
  const int BYTE_COUNT_POINTER    = 1 * 1024 * 1024; // we'll use pointer pinning and block-copies when this many bytes need to be copied
  const int ELEMENT_COUNT_BLOCK   = 256;             // we'll use Array.Copy or Buffer.BlockCopy when more than this many elements are present
  
  var typeDatas = new List<TypeData>();
  typeDatas.Add(new TypeData{ name = "sbyte"  , size = 1, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "byte"   , size = 1, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "short"  , size = 2, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "ushort" , size = 2, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "int"    , size = 4, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "uint"   , size = 4, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "long"   , size = 8, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "ulong"  , size = 8, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "float"  , size = 4, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "double" , size = 8, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "char"   , size = 2, useBlockCopyInsteadOfArrayCopy = true, allowByteConversion = true});
  typeDatas.Add(new TypeData{ name = "string"});
  typeDatas.Add(new TypeData{ name = "decimal", size = 16});
  typeDatas.Add(new TypeData{ name = "bool"   , size = 1});
  typeDatas.Add(new TypeData{ name = "IntPtr" , hasHandcraftedCopyToMethod = true, noArraySupport = true});
  typeDatas.Add(new TypeData{ name = "byte*"  , hasHandcraftedCopyToMethod = true, noArraySupport = true, isUnsafeOnly = true});
  
#>

using System.Runtime.InteropServices;
#if NET45_OR_GREATER
using System.Runtime.CompilerServices;
#endif

using Block1 = System.Byte;
using Block2 = System.UInt16;
using Block4 = System.UInt32;
using Block8 = System.UInt64;
using SBlock2 = System.Int16;
using SBlock4 = System.Int32;
using SBlock8 = System.Int64;

// ReSharper disable UnusedMemberInSuper.Global
// ReSharper disable UnusedAutoPropertyAccessor.Global
// ReSharper disable PartialTypeWithSinglePart
// ReSharper disable UnusedMember.Global
// ReSharper disable MemberCanBePrivate.Global
namespace System {

#if COMPILE_TO_EXTENSION_DLL
  public
#else
  internal
#endif
  static partial class ArrayExtensions {
    
    #region nested types

#if PLATFORM_X86
<#  for(var i = 3;i <= LINEAR_BLOCK_COUNTX86; ++i) {#>
<#    if(i == 1 || i == 2 || i == 4 || i == 8 || i == 32 || i == 64) continue;#>
    [StructLayout(LayoutKind.Sequential, Size=<#=i#>)] private struct Block<#=i#>{ }
<#  }#>
#else
<#  for(var i = 3;i <= LINEAR_BLOCK_COUNTX64; ++i) {#>
<#    if(i == 1 || i == 2 || i == 4 || i == 8 || i == 32 || i == 64) continue;#>
    [StructLayout(LayoutKind.Sequential, Size=<#=i#>)] private struct Block<#=i#>{ }
<#  }#>
#endif

    #endregion

    // TODO: Clear for byte[], ushort[], short[], uint[], int[], ulong[], long[], float[], double[]
    // TODO: Fill for byte[], ushort[], short[], uint[], int[], ulong[], long[], float[], double[]
    // TODO: SequenceEquals for byte[], IntPtr, byte*, ushort[], short[], uint[], int[], ulong[], long[], float[], double[]
    // TODO: unchecked versions

    #region Copy
<#  foreach(var typeData in typeDatas) {#>
<#    var typeName = typeData.name;#>
    #region Type: <#=typeName#>
<#    if(typeData.isUnsafeOnly) {#>
#if UNSAFE
<#    }#>
<#    if(!typeData.noArraySupport) {#>

    <#=EmitMethodHeader("Copy", typeData)#>) {
      if (@this == null)
        return null;

      var length = @this.Length;
      var result = new <#=typeName#>[length];
      _CopyTo(@this, 0, result, 0, length);
      return result;
    }

    <#=EmitMethodHeader("Copy", typeData)#>, int index) {
      if (@this == null)
        return null;

      <#=EmitOffsetTooSmallCheck()#>
      var length = @this.Length;
      <#=EmitOffsetTooLargeCheck()#>
      var count = length - index;
      var result = new <#=typeName#>[count];
      _CopyTo(@this, index, result, 0, count);
      return result;
    }

    <#=EmitMethodHeader("Copy", typeData)#>, int index, int count) {
      if (@this == null)
        return null;

      <#=EmitOffsetTooSmallCheck()#>
      var length = @this.Length;
      <#=EmitOffsetTooLargeCheck()#>
      <#=EmitCountTooSmallCheck()#>
      <#=EmitCountTooLargeCheck("length - index")#>

      var result = new <#=typeName#>[count];
      _CopyTo(@this, index, result, 0, count);
      return result;
    }
<#    }#>

<#    if(!typeData.NeedsCount) {#>
    <#=EmitMethodHeader("void", "CopyTo", typeData)#>, <#=EmitTypeDef(typeData)#> target) {
<#      if(typeData.CanBeNull)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#      }#>
      var count = @this.Length;
      <#=EmitCountTooLargeCheck("count", "target.Length", "target")#>
      _CopyTo(@this, 0 , target, 0, count);
    }

    <#=EmitMethodHeader("void", "CopyTo", typeData)#>, int srcIndex, <#=EmitTypeDef(typeData)#> target) {
<#      if(typeData.CanBeNull)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#      }#>
      <#=EmitOffsetTooSmallCheck("srcIndex")#>
      var length = @this.Length;
      <#=EmitOffsetTooLargeCheck("srcIndex", "length")#>
      var count = length - srcIndex;
      <#=EmitCountTooLargeCheck("count", "target.Length", "target")#>
      _CopyTo(@this, srcIndex , target, 0, count);
    }

    <#=EmitMethodHeader("void", "CopyTo", typeData)#>, <#=EmitTypeDef(typeData)#> target, int tgtIndex) {
<#      if(typeData.CanBeNull)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#      }#>
      <#=EmitOffsetTooSmallCheck("tgtIndex")#>
      var length = target.Length;
      <#=EmitOffsetTooLargeCheck("tgtIndex", "length")#>
      var count = @this.Length;
      <#=EmitCountTooLargeCheck("count", "target.Length - tgtIndex", "@this")#>
      _CopyTo(@this, 0 , target, tgtIndex, count);
    }
<#    } else {#>
    <#=EmitMethodHeader("void", "CopyTo", typeData)#>, int count, <#=EmitTypeDef(typeData)#> target) {
<#      if(typeData.CanBeNull)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#      }#>
      <#=EmitCountTooSmallCheck()#>
      _CopyTo(@this, 0 , target, 0, count);
    }

    <#=EmitMethodHeader("void", "CopyTo", typeData)#>, int count, int srcIndex, <#=EmitTypeDef(typeData)#> target) {
<#      if(typeData.CanBeNull)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#      }#>
      <#=EmitOffsetTooSmallCheck("srcIndex")#>
      <#=EmitCountTooSmallCheck()#>
      _CopyTo(@this, srcIndex , target, 0, count);
    }

    <#=EmitMethodHeader("void", "CopyTo", typeData)#>, int count, <#=EmitTypeDef(typeData)#> target, int tgtIndex) {
<#      if(typeData.CanBeNull)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#      }#>
      <#=EmitOffsetTooSmallCheck("tgtIndex")#>
      <#=EmitCountTooSmallCheck()#>
      _CopyTo(@this, 0 , target, tgtIndex, count);
    }
<#    }#>

    <#=EmitMethodHeader("void", "CopyTo", typeData)#>, int srcIndex, <#=EmitTypeDef(typeData)#> target, int tgtIndex, int count) {
<#    if(typeData.CanBeNull)  {#>
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
<#    }#>
      <#=EmitOffsetTooSmallCheck("srcIndex")#>
      <#=EmitOffsetTooSmallCheck("tgtIndex")#>
      <#=EmitCountTooSmallCheck()#>
<#    if(typeData.SupportsLength) {#>
      <#=EmitOffsetTooLargeCheck("srcIndex", "@this.Length")#>
      <#=EmitOffsetTooLargeCheck("tgtIndex", "target.Length")#>
      <#=EmitCountTooLargeCheck("count", "@this.Length - srcIndex")#>
      <#=EmitCountTooLargeCheck("count", "target.Length - tgtIndex")#>
<#    }#>
      _CopyTo(@this, srcIndex , target, tgtIndex, count);
    }
<#    if(typeData.allowByteConversion){#>
<#      foreach(var tgtTypeData in typeDatas.Where(i=>i.name != typeName && i.allowByteConversion)){#>

    <#=EmitMethodHeader("void", "CopyTo", typeData)#>, int srcIndex, <#=EmitTypeDef(tgtTypeData)#> target, int tgtIndex, int count) {
      <#=EmitThisNullCheck()#>
      <#=EmitArgNullCheck("target")#>
      <#=EmitOffsetTooSmallCheck("srcIndex")#>
      <#=EmitOffsetTooSmallCheck("tgtIndex")#>
      <#=EmitOffsetTooLargeCheck("srcIndex", "@this.Length")#>
      <#=EmitOffsetTooLargeCheck("tgtIndex", "target.Length")#>
      <#=EmitCountTooLargeCheck("count", "@this.Length - srcIndex")#>
<#        if(tgtTypeData.size != typeData.size) {#>
      var bytesNeeded = count<#=EmitFastIntegerMultiply(typeData.size)#>;
      var bytesAvailable = (target.Length - tgtIndex)<#=EmitFastIntegerMultiply(tgtTypeData.size)#>;
      <#=EmitCountTooLargeCheck("bytesNeeded", "bytesAvailable", "count")#>
      if ((bytesNeeded<#=EmitFastIntegerModulo(tgtTypeData.size)#>) != 0) throw new ArgumentException("Need more items to fully cover target items", nameof(count));
<#        } else {#>
      <#=EmitCountTooLargeCheck("count", "target.Length - tgtIndex", "count")#>
<#        }#>
      _CopyTo(@this, srcIndex, target, tgtIndex, count);
    }
<#      }#>
<#    }#>
<#    if(typeData.isUnsafeOnly) {#>

#endif
<#    }#>
    #endregion
<#  }#>
<#  foreach(var typeData in typeDatas.Where(i=>!i.hasHandcraftedCopyToMethod)) {#>
<#    var typeName = typeData.name;#>
    
#if NET45_OR_GREATER
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static void _CopyTo(<#=EmitTypeDef(typeData)#> source, int srcIndex,<#=EmitTypeDef(typeData)#> target, int tgtIndex, int count){
label:
      switch(count){
        case 0: return;
<#    for(var i = 1; i < INDEX_LOOP_UNROLL; ++i) {#>
        case <#=i#>:
<#        for(var j = 0; j < i; ++j) {#>
          <#=EmitIndexCopy(j)#>
<#        }#>
          return;
<#    }#>
      }

<#    if(BYTE_COUNT_POINTER > 0 && typeData.size > 0 && typeData.useBlockCopyInsteadOfArrayCopy) {#>
      if( count > <#=(BYTE_COUNT_POINTER / typeData.size)#>) {
#if UNSAFE
        unsafe {
          fixed(<#=typeData.name#>* sourceFixedPointer = &source[srcIndex])
          fixed(<#=typeData.name#>* targetFixedPointer = &target[tgtIndex])
            _CopyTo(<#=(typeData.name == "byte" ? string.Empty : "(byte*)")#>sourceFixedPointer, <#=(typeData.name == "byte" ? string.Empty : "(byte*)")#>targetFixedPointer, count<#=EmitFastIntegerMultiply(typeData.size)#>);
        }
#else
        using (var sourceFixedPointer = DisposableGCHandle.Pin(source))
        using (var targetFixedPointer = DisposableGCHandle.Pin(target))
          _CopyTo(sourceFixedPointer.AddrOfPinnedObject(), srcIndex<#=EmitFastIntegerMultiply(typeData.size)#>, targetFixedPointer.AddrOfPinnedObject(), tgtIndex<#=EmitFastIntegerMultiply(typeData.size)#>, count<#=EmitFastIntegerMultiply(typeData.size)#>);
#endif

        return;
      }

<#    }#>
<#    if(ELEMENT_COUNT_BLOCK > 0) {#>
      if(count > <#=ELEMENT_COUNT_BLOCK#>) {
        <#=(typeData.useBlockCopyInsteadOfArrayCopy ? "Buffer.BlockCopy" : "Array.Copy")#>(source, srcIndex<#=(typeData.useBlockCopyInsteadOfArrayCopy ? EmitFastIntegerMultiply(typeData.size) : string.Empty)#>, target, tgtIndex<#=(typeData.useBlockCopyInsteadOfArrayCopy ? EmitFastIntegerMultiply(typeData.size) : string.Empty)#>, count<#=(typeData.useBlockCopyInsteadOfArrayCopy ? EmitFastIntegerMultiply(typeData.size) : string.Empty)#>);
        return;
      }

<#    }#>
      while(count >= <#=INDEX_LOOP_UNROLL#>) {
<#    for(var i = 0; i < INDEX_LOOP_UNROLL; ++i) {#>
        <#=EmitIndexCopy(i)#>
<#    }#>
          
        srcIndex += <#=INDEX_LOOP_UNROLL#>;
        tgtIndex += <#=INDEX_LOOP_UNROLL#>;
        count -= <#=INDEX_LOOP_UNROLL#>;
      }

      goto label;
    }
<#    if(typeData.allowByteConversion){#>
<#      foreach(var tgtTypeData in typeDatas.Where(i=>i.name != typeName && i.allowByteConversion)){#>

#if NET45_OR_GREATER
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static void _CopyTo(<#=EmitTypeDef(typeData)#> source, int srcIndex, <#=EmitTypeDef(tgtTypeData)#> target, int tgtIndex, int count)
      => Buffer.BlockCopy(source, srcIndex<#=EmitFastIntegerMultiply(typeData.size)#>, target, tgtIndex<#=EmitFastIntegerMultiply(tgtTypeData.size)#>, count<#=EmitFastIntegerMultiply(typeData.size)#>)
    ;
<#      }#>
<#    }#>
<#  }#>

#if UNSAFE

#if NET45_OR_GREATER
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static unsafe void _CopyTo(byte* source, int srcIndex, byte* target, int tgtIndex, int count)
      => _CopyTo(source + srcIndex, target + tgtIndex, count)
    ;

#if NET45_OR_GREATER
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static unsafe void _CopyTo(byte* source, byte* target, int count) {
byteLoop:

#if PLATFORM_X86

      switch(count) {
        case 0: return;
<#  for(var i = 1; i <= LINEAR_BLOCK_COUNTX86; ++i) {#>
        case <#=i#>: 
          <#=EmitCopyBlock(i, 0)#>
          return;
<#  }#>
      }
      
      <#=EmitCopyBlock(LINEAR_BLOCK_COUNTX86, 0)#>
      count -= <#=LINEAR_BLOCK_COUNTX86#>;
      source += <#=LINEAR_BLOCK_COUNTX86#>;
      target += <#=LINEAR_BLOCK_COUNTX86#>;
      
      var blockCount = count<#=EmitFastIntegerDivide(LINEAR_BLOCK_COUNTX86)#>;
      count = count<#=EmitFastIntegerModulo(LINEAR_BLOCK_COUNTX86)#>;

blockLoop:

      switch (blockCount) {
        case 0: goto byteLoop;
<#  for(var i = 1; i <= INDEX_LOOP_UNROLL; ++i) {#>
        case <#=i#>: goto blockDuff<#=(INDEX_LOOP_UNROLL - i)#>;
<#  }#>
        default: goto blockDuffOut;
      }

<#  for(var i = 0; i < INDEX_LOOP_UNROLL; ++i) {#>
blockDuff<#=i#>: <#=EmitCopyBlock(LINEAR_BLOCK_COUNTX86, INDEX_LOOP_UNROLL - i - 1)#>
<#  }#>

      var processed = blockCount<#=EmitFastIntegerMultiply(LINEAR_BLOCK_COUNTX86)#>;
      source += processed;
      target += processed;
      goto byteLoop;

blockDuffOut:

      do {
<#  for(var j = 0; j < INDEX_LOOP_UNROLL; ++j){#>
        <#=EmitCopyBlock(LINEAR_BLOCK_COUNTX86, j)#>
<#  }#>
        source += <#=(INDEX_LOOP_UNROLL * LINEAR_BLOCK_COUNTX86)#>;
        target += <#=(INDEX_LOOP_UNROLL * LINEAR_BLOCK_COUNTX86)#>;
        blockCount -= <#=INDEX_LOOP_UNROLL#>;
      } while (blockCount >= <#=INDEX_LOOP_UNROLL#>);
      goto blockLoop;

#else

      switch(count) {
        case 0: return;
<#  for(var i = 1; i <= LINEAR_BLOCK_COUNTX64; ++i) {#>
        case <#=i#>: 
          <#=EmitCopyBlock(i, 0)#>
          return;
<#  }#>
      }
      
      <#=EmitCopyBlock(LINEAR_BLOCK_COUNTX64, 0)#>
      count -= <#=LINEAR_BLOCK_COUNTX64#>;
      source += <#=LINEAR_BLOCK_COUNTX64#>;
      target += <#=LINEAR_BLOCK_COUNTX64#>;
      
      var blockCount = count<#=EmitFastIntegerDivide(LINEAR_BLOCK_COUNTX64)#>;
      count = count<#=EmitFastIntegerModulo(LINEAR_BLOCK_COUNTX64)#>;

blockLoop:

      switch (blockCount) {
        case 0: goto byteLoop;
<#  for(var i = 1; i <= INDEX_LOOP_UNROLL; ++i) {#>
        case <#=i#>: goto blockDuff<#=(INDEX_LOOP_UNROLL - i)#>;
<#  }#>
        default: goto blockDuffOut;
      }

<#  for(var i = 0; i < INDEX_LOOP_UNROLL; ++i) {#>
blockDuff<#=i#>: <#=EmitCopyBlock(LINEAR_BLOCK_COUNTX64, INDEX_LOOP_UNROLL - i - 1)#>
<#  }#>

      var processed = blockCount<#=EmitFastIntegerMultiply(LINEAR_BLOCK_COUNTX64)#>;
      source += processed;
      target += processed;
      goto byteLoop;

blockDuffOut:

      do {
<#  for(var j = 0; j < INDEX_LOOP_UNROLL; ++j){#>
        <#=EmitCopyBlock(LINEAR_BLOCK_COUNTX64, j)#>
<#  }#>
        source += <#=(INDEX_LOOP_UNROLL * LINEAR_BLOCK_COUNTX64)#>;
        target += <#=(INDEX_LOOP_UNROLL * LINEAR_BLOCK_COUNTX64)#>;
        blockCount -= <#=INDEX_LOOP_UNROLL#>;
      } while (blockCount >= <#=INDEX_LOOP_UNROLL#>);
      goto blockLoop;

#endif

    }
#endif

#if NET45_OR_GREATER
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    private static void _CopyTo(IntPtr source, int srcIndex, IntPtr target, int tgtIndex, int count) {
#if UNSAFE
      unsafe { _CopyTo(&((byte*)source)[srcIndex], &((byte*)target)[tgtIndex], count); }
#else
byteLoop:
      switch(count) {
        case 0: return;
<#  for(var i = 1; i <= MARSHALL_SWITCH_COUNT; ++i) {#>
        case <#=i#>:
          <#=string.Join("\r\n          ",EmitMarshalCopyBytes(i))#>
          return;
<#  }#>
      }

<#  if(MARSHALL_LOOP_UNROLL>1){#>

      <#=string.Join("\r\n      ",EmitMarshalCopyBytes(MARSHALL_SWITCH_COUNT))#>
      count -= <#=MARSHALL_SWITCH_COUNT#>;
      srcIndex += <#=MARSHALL_SWITCH_COUNT#>;
      tgtIndex += <#=MARSHALL_SWITCH_COUNT#>;
    
      var qwordCount = count<#=EmitFastIntegerDivide(8)#>;
      count = count<#=EmitFastIntegerModulo(8)#>;

qwordLoop:

      switch (qwordCount) {
        case 0: goto byteLoop;
<#    for(var i = 1; i <= MARSHALL_LOOP_UNROLL; ++i) {#>
        case <#=i#>: goto qwordDuff<#=(MARSHALL_LOOP_UNROLL - i)#>;
<#    }#>
        default: goto qwordDuffOut;
      }

<#    for(var i = 0; i < MARSHALL_LOOP_UNROLL; ++i) {#>
qwordDuff<#=i#>: <#=EmitMarshalCopyQWord((MARSHALL_LOOP_UNROLL - i - 1) * 8)#>;
<#    }#>

      var processed = qwordCount<#=EmitFastIntegerMultiply(8)#>;
      srcIndex += processed;
      tgtIndex += processed;
      goto byteLoop;

qwordDuffOut:

      do {
        <#=string.Join("\r\n        ",EmitMarshalCopyBytes(MARSHALL_LOOP_UNROLL * 8))#>
        srcIndex += <#=(MARSHALL_LOOP_UNROLL * 8)#>;
        tgtIndex += <#=(MARSHALL_LOOP_UNROLL * 8)#>;
        qwordCount -= <#=MARSHALL_LOOP_UNROLL#>;
      } while (qwordCount >= <#=MARSHALL_LOOP_UNROLL#>);

      goto qwordLoop;
<#  } else {#>
      var qwordCount = count<#=EmitFastIntegerDivide(8)#>;
      count = count<#=EmitFastIntegerModulo(8)#>;
      do {
        <#=string.Join("\r\n        ",EmitMarshalCopyBytes(8))#>
        srcIndex += 8;
        tgtIndex += 8;
        --qwordCount;
      } while (qwordCount > 0);
      goto byteLoop;
<#  }#>

#endif
    }

    #endregion

    #region Fill

#if UNSAFE

#if NET45_OR_GREATER
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static unsafe void Fill(this IntPtr @this, int count, byte value)
      => Fill((byte*)@this, count, value)
    ;

    public static unsafe void Fill(byte* @this, int count, byte value) {
      <#=EmitCountTooSmallCheck()#>

      for(;;)
        switch (count) {
          case 0: return;
<#    for(var i = 1; i <= UNSAFE_SWITCH_COUNT; ++i) {#>
          case <#=i#>:
            <#=string.Join("\r\n            ",EmitSetBytes(i, "value"))#>
            return;
<#    }#>
          default: {
            var blocks = count >> 3;
            var block8 = 0x0101010101010101UL * value;

#if !PLATFORM_X86
            const int MAX_MANAGED_BLOCKS = 16;
#else
            const int MAX_MANAGED_BLOCKS = 50;
#endif
            if (blocks < MAX_MANAGED_BLOCKS) {
              count &= 0b111;
              for (;;)
                switch (blocks) {
<#    for(var i = 0; i <= INDEX_LOOP_UNROLL; ++i) {#>
                  case <#=i#>: goto blockCount<#=i#>;
<#    }#>
                  default: {
                    do {
                      *(Block8*) @this = block8;
<#    for(var i = 1; i < INDEX_LOOP_UNROLL; ++i) {#>
                      ((Block8*) @this)[<#=i#>] = block8;
<#    }#>
                      @this += <#=(INDEX_LOOP_UNROLL * 8)#>;
                      blocks -= <#=INDEX_LOOP_UNROLL#>;
                    } while (blocks >= <#=INDEX_LOOP_UNROLL#>);

                    continue; // next blocks
                  }
                }

<#    for(var i = INDEX_LOOP_UNROLL; i > 0; --i) {#>
              blockCount<#=i#>: *(Block8*) @this = block8;
<#    }#>
              @this += blocks << 3;
              blockCount0:
              continue; // copy single bytes left
            } // medium-sized blocks

            // large blocks
            var start = @this;

            *(Block8*)@this = block8;
<#    for(var i = 1; i < INDEX_LOOP_UNROLL; ++i) {#>
            ((Block8*)@this)[<#=i#>] = block8;
<#    }#>
            @this += <#=(INDEX_LOOP_UNROLL * 8)#>;
            count -=<#=(INDEX_LOOP_UNROLL * 8)#>;

#if !PLATFORM_X86

            var block64 = *(Block64*)start;
<#    var lastBlockCount = int.MaxValue;#>
<#    foreach(var blockCount in new[]{16, 8, 1}){#>
<#      var bytesPerLoop = 64 * blockCount;#>
<#      var canHaveMoreThanOneIteration = blockCount < (lastBlockCount / 2);#>
            <#=(canHaveMoreThanOneIteration ? "while" : "if")#> (count >= <#=bytesPerLoop#>) {
<#      lastBlockCount = blockCount;#>
              count -= <#=bytesPerLoop#>;
              *(Block64*)@this = block64;
<#      for(var i = 1; i < blockCount; ++i) {#>
              ((Block64*)@this)[<#=i#>] = block64;
<#      }#>
              @this += <#=bytesPerLoop#>;
            }
<#    }#>
            
            if (count != 0)
              continue;

#else

            _MemoryFill(@this, value, count);
            
#endif

            return;

            } // single-byte default
        } // single-byte switch
    }

#else

    public static void Fill(this IntPtr @this, int count, byte value) {
      <#=EmitCountTooSmallCheck()#>
      
      for (;;)
        switch (count) {
          case 0: return;
<#    for(var i = 1; i <= MARSHALL_SWITCH_COUNT; ++i) {#>
          case <#=i#>: 
            <#=string.Join("\r\n            ", EmitMarshalSetBytes(i, "value"))#>
            return;
<#    }#>
          default: {
            var block8 = (SBlock8) (0x0101010101010101UL * value);
            var blocks = count >> 3;
            
#if !MONO
            const int MAX_MANAGED_BLOCKS = 50;

            if (blocks < MAX_MANAGED_BLOCKS) {
#endif
              count &= 0b111;
              for (;;)
                switch (blocks) {
<#    for(var i = 0; i <= MARSHALL_SWITCH_COUNT; ++i) {#>
                  case <#=i#>: goto blockCount<#=i#>;
<#    }#>
                  default: {
                    var block64=(object)new Block64((ulong)block8);

                    do {
                      Marshal.StructureToPtr(block64, @this, false);
                      @this += 64;
                      blocks -= 8;
                    } while (blocks >= 8);

                    continue; // next blocks
                  }
                }
              
<#    for(var i = MARSHALL_SWITCH_COUNT; i > 1; --i) {#>
              blockCount<#=i#>: Marshal.WriteInt64(@this, <#=((i - 1) * 8)#>, block8);
<#    }#>
              blockCount1: Marshal.WriteInt64(@this, block8);
              @this += blocks << 3;
              blockCount0: continue; // copy single bytes left
#if !MONO
            } // medium-sized blocks

            // large blocks
            _MemoryFill(@this, value, count);
            return;
#endif              
          } // single-byte default
        } // single-byte switch
    }

#endif

    #endregion

    #region Clear

#if UNSAFE

#if NET45_OR_GREATER
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static unsafe void Clear(this IntPtr @this, int count)
      => Clear((byte*)@this, count)
    ;

    public static unsafe void Clear(byte* @this, int count) {
      <#=EmitCountTooSmallCheck()#>

      for(;;)
        switch (count) {
          case 0: return;
<#    for(var i = 1; i <= UNSAFE_SWITCH_COUNT; ++i) {#>
          case <#=i#>:
            <#=string.Join("\r\n            ",EmitSetBytes(i))#>
            return;
<#    }#>
          default: {
            var blocks = count >> 3;

#if !PLATFORM_X86
            const int MAX_MANAGED_BLOCKS = 16;
#else
            const int MAX_MANAGED_BLOCKS = 50;
#endif
            if (blocks < MAX_MANAGED_BLOCKS) {
              count &= 0b111;
              for (;;)
                switch (blocks) {
<#    for(var i = 0; i <= INDEX_LOOP_UNROLL; ++i) {#>
                  case <#=i#>: goto blockCount<#=i#>;
<#    }#>
                  default: {
                    do {
                      *(Block8*) @this = 0;
<#    for(var i = 1; i < INDEX_LOOP_UNROLL; ++i) {#>
                      ((Block8*) @this)[<#=i#>] = 0;
<#    }#>
                      @this += <#=(INDEX_LOOP_UNROLL * 8)#>;
                      blocks -= <#=INDEX_LOOP_UNROLL#>;
                    } while (blocks >= <#=INDEX_LOOP_UNROLL#>);

                    continue; // next blocks
                  }
                }

<#    for(var i = INDEX_LOOP_UNROLL; i > 0; --i) {#>
              blockCount<#=i#>: *(Block8*) @this = 0;
<#    }#>
              @this += blocks << 3;
              blockCount0:
              continue; // copy single bytes left
            } // medium-sized blocks

            // large blocks
            var start = @this;

            *(Block8*)@this = 0;
<#    for(var i = 1; i < INDEX_LOOP_UNROLL; ++i) {#>
            ((Block8*)@this)[<#=i#>] = 0;
<#    }#>
            @this += <#=(INDEX_LOOP_UNROLL * 8)#>;
            count -=<#=(INDEX_LOOP_UNROLL * 8)#>;

#if !PLATFORM_X86

            var block64 = *(Block64*)start;
<#    lastBlockCount = int.MaxValue;#>
<#    foreach(var blockCount in new[]{16, 8, 1}){#>
<#      var bytesPerLoop = 64 * blockCount;#>
<#      var canHaveMoreThanOneIteration = blockCount < (lastBlockCount / 2);#>
            <#=(canHaveMoreThanOneIteration ? "while" : "if")#> (count >= <#=bytesPerLoop#>) {
<#      lastBlockCount = blockCount;#>
              count -= <#=bytesPerLoop#>;
              *(Block64*)@this = block64;
<#      for(var i = 1; i < blockCount; ++i) {#>
              ((Block64*)@this)[<#=i#>] = block64;
<#      }#>
              @this += <#=bytesPerLoop#>;
            }
<#    }#>
            
            if (count != 0)
              continue;

#else

            _MemoryFill(@this, 0, count);
            
#endif

            return;

            } // single-byte default
        } // single-byte switch
    }

#else

    public static void Clear(this IntPtr @this, int count) {
      <#=EmitCountTooSmallCheck()#>
      
      for (;;)
        switch (count) {
          case 0: return;
<#    for(var i = 1; i <= MARSHALL_SWITCH_COUNT; ++i) {#>
          case <#=i#>: 
            <#=string.Join("\r\n            ", EmitMarshalSetBytes(i))#>
            return;
<#    }#>
          default: {
            var blocks = count >> 3;
            
#if !MONO
            const int MAX_MANAGED_BLOCKS = 50;

            if (blocks < MAX_MANAGED_BLOCKS) {
#endif
              count &= 0b111;
              for (;;)
                switch (blocks) {
<#    for(var i = 0; i <= MARSHALL_SWITCH_COUNT; ++i) {#>
                  case <#=i#>: goto blockCount<#=i#>;
<#    }#>
                  default: {
                    var block64=(object)new Block64();

                    do {
                      Marshal.StructureToPtr(block64, @this, false);
                      @this += 64;
                      blocks -= 8;
                    } while (blocks >= 8);

                    continue; // next blocks
                  }
                }
              
<#    for(var i = MARSHALL_SWITCH_COUNT; i > 1; --i) {#>
              blockCount<#=i#>: Marshal.WriteInt64(@this, <#=((i - 1) * 8)#>, 0);
<#    }#>
              blockCount1: Marshal.WriteInt64(@this, 0);
              @this += blocks << 3;
              blockCount0: continue; // copy single bytes left
#if !MONO
            } // medium-sized blocks

            // large blocks
            _MemoryFill(@this, 0, count);
            return;
#endif              
          } // single-byte default
        } // single-byte switch
    }

#endif

    #endregion
  }
}

<#+

struct TypeData {
  
  public string name;
  public int size;
  public bool useBlockCopyInsteadOfArrayCopy;
  public bool allowByteConversion;
  public bool noArraySupport;
  public bool hasHandcraftedCopyToMethod;
  public bool isUnsafeOnly;

  public bool NeedsCount => this.noArraySupport;
  public bool SupportsLength => !this.noArraySupport;
  public bool IsValueType => this.noArraySupport;
  public bool CanBeNull => !this.IsValueType;

}

double Log2(int i) => Math.Log(i) / Math.Log(2);

string EmitFastIntegerMultiply(int i) {
  var exponent = Log2(i);
  if(exponent == (int)exponent)
    return exponent == 0 ? string.Empty : " << " + exponent;
  else
    return " * " + i;
}

string EmitFastIntegerDivide(int i) {
  var exponent = Log2(i);
  if(exponent == (int)exponent)
    return exponent == 0 ? string.Empty : " >> " + exponent;
  else
    return " / " + i;
}
  
string EmitFastIntegerModulo(int i) {
  var exponent = Log2(i);
  if(exponent == (int)exponent)
    return exponent == 0 ? string.Empty : " & " + (exponent == 1 ? "1" : "0b" + new string('1', (int)exponent));
  else
    return " % " + i;
}

string EmitTypeDef(TypeData type) => type.noArraySupport ? type.name : type.name + "[]"; 

string EmitIndexCopy(int i) => string.Format(@"target[tgtIndex{0}] = source[srcIndex{0}];", i == 0 ? string.Empty : " + " + i);

string EmitCopyByte(int i)  => i == 0 ? "*target = *source;"                 : string.Format("target[{0}] = source[{0}];", i);
string EmitCopyWord(int i)  => i == 0 ? "*(short*)target = *(short*)source;" : string.Format("((short*)target)[{0}] = ((short*)source)[{0}];", i);
string EmitCopyDWord(int i) => i == 0 ? "*(int*)target = *(int*)source;"     : string.Format("((int*)target)[{0}] = ((int*)source)[{0}];", i);
string EmitCopyQWord(int i) => i == 0 ? "*(long*)target = *(long*)source;"   : string.Format("((long*)target)[{0}] = ((long*)source)[{0}];", i);

string EmitMarshalCopyByte(int i)  => string.Format("Marshal.WriteByte(target, tgtIndex{0}, Marshal.ReadByte(source, srcIndex{0}));", i == 0 ? string.Empty : " + " + i);
string EmitMarshalCopyWord(int i)  => string.Format("Marshal.WriteInt16(target, tgtIndex{0}, Marshal.ReadInt16(source, srcIndex{0}));", i == 0 ? string.Empty : " + " + i);
string EmitMarshalCopyDWord(int i) => string.Format("Marshal.WriteInt32(target, tgtIndex{0}, Marshal.ReadInt32(source, srcIndex{0}));", i == 0 ? string.Empty : " + " + i);
string EmitMarshalCopyQWord(int i) => string.Format("Marshal.WriteInt64(target, tgtIndex{0}, Marshal.ReadInt64(source, srcIndex{0}));", i == 0 ? string.Empty : " + " + i);

IEnumerable<string> EmitCopyBytes(int count) {
  var offset = 0;
  while(count >= 8) {
    yield return EmitCopyQWord(offset >> 3);
    count -= 8;
    offset += 8;
  }

  if (count >= 4) {
    yield return EmitCopyDWord(offset >> 2);
    count -= 4;
    offset += 4;
  }

  if (count >= 2) {
    yield return EmitCopyWord(offset >> 1);
    count -= 2;
    offset += 2;
  }

  if (count >= 1) 
    yield return EmitCopyByte(offset);
}

IEnumerable<string> EmitMarshalCopyBytes(int count) {
  var offset = 0;
  while (count >= 8) {
    yield return EmitMarshalCopyQWord(offset);
    offset += 8;
    count-= 8;
  }

  if (count >= 4) {
    yield return EmitMarshalCopyDWord(offset);
    offset += 4;
    count-= 4;
  }

  if (count >= 2) {
    yield return EmitMarshalCopyWord(offset);
    offset += 2;
    count-= 2;
  }
  
  if(count > 0)
    yield return EmitMarshalCopyByte(offset);
}

string EmitCopyBlock(int sizeInBytes, int index) {
  if (sizeInBytes == 1)
    return index == 0 ? "*target = *source;" : string.Format("target[{1}] = source[{1}];", sizeInBytes, index);
  else
    return index == 0 ? string.Format("*(Block{0}*)target = *(Block{0}*)source;", sizeInBytes) : string.Format("((Block{0}*)target)[{1}] = ((Block{0}*)source)[{1}];", sizeInBytes, index);
}


string EmitMarshalSetByte(int offset) => EmitMarshalSetByte(offset, null);
string EmitMarshalSetByte(string value) => EmitMarshalSetByte(0, value);
string EmitMarshalSetByte(int offset, string value) => string.Format("Marshal.WriteByte(@this, {0}{1});", offset == 0 ? string.Empty : offset + ", ", value ?? "0");

string EmitMarshalSetWord(int offset) => EmitMarshalSetWord(offset, null);
string EmitMarshalSetWord(string value) => EmitMarshalSetWord(0, value);
string EmitMarshalSetWord(int offset, string value) => string.Format("Marshal.WriteInt16(@this, {0}{1});", offset == 0 ? string.Empty : offset + ", ", value ?? "0");

string EmitMarshalSetDWord(int offset) => EmitMarshalSetDWord(offset, null);
string EmitMarshalSetDWord(string value) => EmitMarshalSetDWord(0, value);
string EmitMarshalSetDWord(int offset, string value) => string.Format("Marshal.WriteInt32(@this, {0}{1});", offset == 0 ? string.Empty : offset + ", ", value ?? "0");

string EmitMarshalSetQWord(int offset) => EmitMarshalSetQWord(offset, null);
string EmitMarshalSetQWord(string value) => EmitMarshalSetQWord(0, value);
string EmitMarshalSetQWord(int offset, string value) => string.Format("Marshal.WriteInt64(@this, {0}{1});", offset == 0 ? string.Empty : offset + ", ", value ?? "0");

IEnumerable<string> EmitMarshalSetBytes(int count) => EmitMarshalSetBytes(count, null);
IEnumerable<string> EmitMarshalSetBytes(int count, string value) {
  var offset = 0;

  if (count >= 8 ) {
    var reuseValue = value != null && count >= 16;
  
    if(reuseValue) {
      yield return "{";
      yield return "  var temp = (SBlock8)(0x0101010101010101UL * " + value + ");";
    }

    while (count >= 8) {
      yield return (reuseValue ? "  " : string.Empty) + EmitMarshalSetQWord(offset, reuseValue ? "temp" : value != null ? "(SBlock8)(0x0101010101010101UL * " + value + ")" : null);
      offset += 8;
      count-= 8;
    }

    if(reuseValue)
      yield return "}";
  }

  if (count >= 4) {
    yield return EmitMarshalSetDWord(offset, value != null ? "(SBlock4)(0x01010101U * " + value + ")" : null);
    offset += 4;
    count-= 4;
  }

  if (count >= 2) {
    yield return EmitMarshalSetWord(offset, value != null ? "(SBlock2)(0x0101 * " + value + ")" : null);
    offset += 2;
    count-= 2;
  }
  
  if(count > 0)
    yield return EmitMarshalSetByte(offset, value);
}

string EmitSetByte(int offset) => EmitSetByte(offset, null);
string EmitSetByte(string value) => EmitSetByte(0, value);
string EmitSetByte(int offset, string value) => string.Format("{0} = {1};", offset == 0 ? "*@this" : "@this[" + offset + "]", value ?? "0");

string EmitSetWord(int offset) => EmitSetWord(offset, null);
string EmitSetWord(string value) => EmitSetWord(0, value);
string EmitSetWord(int offset, string value) => string.Format("{0} = {1};", offset == 0 ? "*(Block2*)@this" : "*(Block2*)(@this + " + offset + ")", value ?? "0");

string EmitSetDWord(int offset) => EmitSetDWord(offset, null);
string EmitSetDWord(string value) => EmitSetDWord(0, value);
string EmitSetDWord(int offset, string value) => string.Format("{0} = {1};", offset == 0 ? "*(Block4*)@this" : "*(Block4*)(@this + " + offset + ")", value ?? "0");

string EmitSetQWord(int offset) => EmitSetQWord(offset, null);
string EmitSetQWord(string value) => EmitSetQWord(0, value);
string EmitSetQWord(int offset, string value) => string.Format("{0} = {1};", offset == 0 ? "*(Block8*)@this" : "*(Block8*)(@this + " + offset + ")", value ?? "0");

IEnumerable<string> EmitSetBytes(int count) => EmitSetBytes(count, null);
IEnumerable<string> EmitSetBytes(int count, string value) {
  var offset = 0;

  if (count >= 8 ) {
    var reuseValue = value != null && count >= 16;
  
    if(reuseValue) {
      yield return "{";
      yield return "  var temp = 0x0101010101010101UL * " + value + ";";
    }

    while (count >= 8) {
      yield return (reuseValue ? "  " : string.Empty) + EmitSetQWord(offset, reuseValue ? "temp" : value != null ? "0x0101010101010101UL * " + value : null);
      offset += 8;
      count-= 8;
    }

    if(reuseValue)
      yield return "}";
  }

  if (count >= 4) {
    yield return EmitSetDWord(offset, value != null ? "0x01010101U * " + value : null);
    offset += 4;
    count-= 4;
  }

  if (count >= 2) {
    yield return EmitSetWord(offset, value != null ? "(Block2)(0x0101 * " + value + ")": null);
    offset += 2;
    count-= 2;
  }
  
  if(count > 0)
    yield return EmitSetByte(offset, value);
}



string EmitThisNullCheck() => @"if (@this == null) throw new NullReferenceException();";
string EmitArgNullCheck(string paramName) => string.Format(@"if ({0} == null) throw new ArgumentNullException(nameof({0}));", paramName);

string EmitOffsetTooSmallCheck(string paramName) => string.Format(@"if ({0} < 0) throw new ArgumentOutOfRangeException(nameof({0}), $""Index too small {{{0}}} < 0"");", paramName);
string EmitOffsetTooSmallCheck() => EmitOffsetTooSmallCheck("index");

string EmitOffsetTooLargeCheck(string paramName, string limit) => string.Format(@"if ({0} >= {1}) throw new ArgumentOutOfRangeException(nameof({0}), $""Index too large {{{0}}} >= {{{1}}}"");", paramName, limit);
string EmitOffsetTooLargeCheck(string limit) => EmitOffsetTooLargeCheck("index", limit);
string EmitOffsetTooLargeCheck() => EmitOffsetTooLargeCheck("length");

string EmitCountTooSmallCheck(string paramName) => string.Format(@"if ({0} < 0) throw new ArgumentOutOfRangeException(nameof({0}), $""Count too small {{{0}}} < 0"");", paramName);
string EmitCountTooSmallCheck() => EmitCountTooSmallCheck("count");

string EmitCountTooLargeCheck(string source, string length, string paramName) => string.Format(@"if ({0} > {1}) throw new ArgumentOutOfRangeException(nameof({2}), $""Count too large {{{0}}} > {{{1}}}"");", source, length, paramName);
string EmitCountTooLargeCheck(string source, string length) => EmitCountTooLargeCheck(source, length, source);
string EmitCountTooLargeCheck(string length) => EmitCountTooLargeCheck("count", length);
string EmitCountTooLargeCheck() => EmitCountTooLargeCheck("length");

string EmitMethodHeader(string returnType, string name, TypeData type) => string.Format("public static {0}{1} {2}({3}{4} @this", type.isUnsafeOnly ? "unsafe " : string.Empty, returnType, name, type.isUnsafeOnly ? string.Empty : "this ", EmitTypeDef(type));
string EmitMethodHeader(string name, TypeData type) => EmitMethodHeader(EmitTypeDef(type), name, type);

#>
