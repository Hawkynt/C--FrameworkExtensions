<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
#region (c)2010-2020 Hawkynt
/*
  This file is part of Hawkynt's .NET Framework extensions.

    Hawkynt's .NET Framework extensions are free software: 
    you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Hawkynt's .NET Framework extensions is distributed in the hope that 
    it will be useful, but WITHOUT ANY WARRANTY; without even the implied 
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
    the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Hawkynt's .NET Framework extensions.  
    If not, see <http://www.gnu.org/licenses/>.
*/
#endregion

/* ATTENTION: This file is generated by a tool. All changes will be reverted upon next run ! */

using System.Runtime.CompilerServices;
#if !NETFX_45
using System.Diagnostics;
#endif

// ReSharper disable UnusedMember.Global
// ReSharper disable PartialTypeWithSinglePart

namespace System.ComponentModel {
  internal static partial class PropertyChangedExtensions {

    /// <summary>
    /// The synchornization context to use for all safe invocations if any.
    /// </summary>
    public static ISynchronizeInvoke SynchronizationContext;

    /// <summary>
    /// Safely invokes the event.
    /// </summary>
    /// <param name="This">This event.</param>
    /// <param name="sender">The sender.</param>
    /// <param name="e">The <see cref="System.ComponentModel.PropertyChangedEventArgs"/> instance containing the event data.</param>
    public static void SafeInvoke(this PropertyChangedEventHandler This, object sender, PropertyChangedEventArgs e) {
      if (This == null)
        return;

      var context = SynchronizationContext;
      if (context != null) {
        context.Invoke(new Action(() => This(sender, e)), null);
        return;
      }

      foreach (var subscriber in This.GetInvocationList()) {
        var sync = subscriber.Target as ISynchronizeInvoke;
        if (sync != null) {
          if (sync.InvokeRequired) {
            sync.Invoke(subscriber, new[] { sender, e });
            continue;
          }
        }
        subscriber.DynamicInvoke(sender, e);

      }
    }

  <#foreach(var type in new[]{"bool","byte","sbyte","char","short","ushort","int","uint","long","ulong","float","double","decimal","string"}){#>

    /// <summary>
    /// Checks if a property already matches a desired value.  Sets the property and
    /// notifies listeners only when necessary.
    /// </summary>
    /// <typeparam name="This">Type of the object.</typeparam>
    /// <param name="this">This object.</param>
    /// <param name="onPropertyChanged">The property changed event invocator.</param>
    /// <param name="backingField">Reference to a property with both getter and setter.</param>
    /// <param name="value">Desired value for the property.</param>
    /// <param name="propertyName">Name of the property used to notify listeners.  This
    /// value is optional and can be provided automatically when invoked from compilers that
    /// support CallerMemberName.</param>
    /// <returns>
    /// True if the value was changed, false if the existing value matched the
    /// desired value.
    /// </returns>
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#else
    [MethodImpl(MethodImplOptions.NoInlining)]
#endif
    // ReSharper disable once UnusedParameter.Global
    // ReSharper disable once UnusedMethodReturnValue.Global
    public static bool SetProperty<This>(
      this This @this, 
      Action<string> onPropertyChanged, 
      ref <#=type#> backingField, 
      <#=type#> value, 
#if NETFX_45
      [CallerMemberName]string propertyName = null
#else
      string propertyName = null
#endif
    ) where This:INotifyPropertyChanged {
      if (backingField == value)
        return (false);

      backingField = value;
#if !NETFX_45
      if(propertyName==null){
        var method=new StackTrace().GetFrame(1).GetMethod();
        var name = method.Name;
        if (method.IsSpecialName && ((name.StartsWith("get_") && method.DeclaringType.GetProperties().Any(p => p.GetGetMethod() == method)) || (name.StartsWith("set_") && method.DeclaringType.GetProperties().Any(p => p.GetSetMethod() == method))))
          name = name.Substring(4);
        propertyName=name;
      }
#endif
      onPropertyChanged(propertyName);
      return (true);
    }

  <#}#>

    /// <summary>
    /// Checks if a property already matches a desired value.  Sets the property and
    /// notifies listeners only when necessary.
    /// </summary>
    /// <typeparam name="This">Type of the object.</typeparam>
    /// <typeparam name="T">Type of the property.</typeparam>
    /// <param name="this">This object.</param>
    /// <param name="onPropertyChanged">The property changed event invocator.</param>
    /// <param name="backingField">Reference to a property with both getter and setter.</param>
    /// <param name="value">Desired value for the property.</param>
    /// <param name="propertyName">Name of the property used to notify listeners.  This
    /// value is optional and can be provided automatically when invoked from compilers that
    /// support CallerMemberName.</param>
    /// <returns>
    /// True if the value was changed, false if the existing value matched the
    /// desired value.
    /// </returns>
#if NETFX_45
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#else
    [MethodImpl(MethodImplOptions.NoInlining)]
#endif
    // ReSharper disable once UnusedParameter.Global
    // ReSharper disable once UnusedMethodReturnValue.Global
    public static bool SetProperty<This,T>(
      this This @this, 
      Action<string> onPropertyChanged, 
      ref T backingField, 
      T value, 
#if NETFX_45
      [CallerMemberName]string propertyName = null
#else
      string propertyName = null
#endif
    ) where This:INotifyPropertyChanged {
      if (Equals(backingField, value))
        return (false);

      backingField = value;
#if !NETFX_45
      if(propertyName==null){
        var method=new StackTrace().GetFrame(1).GetMethod();
        var name = method.Name;
        if (method.IsSpecialName && ((name.StartsWith("get_") && method.DeclaringType.GetProperties().Any(p => p.GetGetMethod() == method)) || (name.StartsWith("set_") && method.DeclaringType.GetProperties().Any(p => p.GetSetMethod() == method))))
          name = name.Substring(4);
        propertyName=name;
      }
#endif
      onPropertyChanged(propertyName);
      return (true);
    }
  }
}